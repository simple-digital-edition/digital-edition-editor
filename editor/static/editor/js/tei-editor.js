(function() {
    window.teiEditorConfig = Object.assign(window.teiEditorConfig || {}, {
        // Configure editor tabs
        sections: {

            // ================
            // Metadaten Header
            // ================
            header: {
                title: 'Metadaten',
                type: 'header',
                tag: 'tei:teiHeader',
                schema: [
                    {
                        tag: 'tei:fileDesc',
                        children: [
                            {
                                tag: 'tei:titleStmt',
                                children: [
                                    {
                                        tag: 'tei:title',
                                        text: 'fileDesc.titleStmt.title._text'
                                    },
                                    {
                                        tag: 'tei:author',
                                        text: 'fileDesc.titleStmt.author._text'
                                    },
                                    {
                                        tag: 'tei:respStmt',
                                        multiple: true,
                                        attrs: {
                                            'xml:id': '_attrs.xml:id'
                                        },
                                        children: [
                                            {
                                                tag: 'tei:resp',
                                                text: 'resp._text'
                                            },
                                            {
                                                tag: 'tei:name',
                                                text: 'name._text'
                                            }
                                        ]
                                    }
                                ]
                            },
                            {
                                tag: 'tei:publicationStmt',
                                children: [
                                    {
                                        tag: 'tei:distributor',
                                        text: 'fileDesc.publicationStmt.distributor._text'
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        tag: 'tei:encodingDesc',
                        children: [
                            {
                                tag: 'tei:classDecl',
                                children: [
                                    {
                                        tag: 'tei:taxonomy',
                                        attrs: {
                                            'xml:id': 'encodingDesc.classDecl.taxonomy._attrs.xml:id'
                                        },
                                        children: [
                                            {
                                                tag: 'tei:bibl',
                                                text: 'encodingDesc.classDecl.taxonomy.bibl._text'
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        tag: 'tei:sourceDesc',
                        children: [
                            {
                                tag: 'tei:bibl',
                                text: 'sourceDesc.bibl._text'
                            }
                        ]
                    },
                    {
                        tag: 'tei:profileDesc',
                        children: [
                            {
                                tag: 'tei:creation',
                                children: [
                                    {
                                        tag: 'tei:date',
                                        attrs: {
                                            when: 'profileDesc.creation.date._attrs.when'
                                        },
                                        text: 'profileDesc.creation.date._text'
                                    }
                                ]
                            },
                            {
                                tag: 'tei:textClass',
                                children: [
                                    {
                                        tag: 'tei:catRef',
                                        attrs: {
                                            target: 'profileDesc.textClass.catRef._attrs.target'
                                        },
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        tag: 'tei:revisionDesc',
                        children: [
                            {
                                tag: 'tei:change',
                                multiple: true,
                                attrs: {
                                    when: '_attrs.when',
                                    who: '_attrs.who'
                                },
                                text: '_text'
                            }
                        ]
                    }
                ],
                ui: [
                    {
                        title: 'Bibliographie',
                        entries: [
                            {
                                type: 'single-text',
                                label: 'Titel',
                                path: 'fileDesc.titleStmt.title._text'
                            },
                            {
                                type: 'single-text',
                                label: 'Autor',
                                path: 'fileDesc.titleStmt.author._text'
                            },
                            {
                                type: 'single-text',
                                label: 'Quelle',
                                path: 'sourceDesc.bibl._text'
                            },
                            {
                                type: 'single-text',
                                label: 'Veröffentlichungsdatum (JJJJ-MM-TT)',
                                path: 'profileDesc.creation.date._attrs.when'
                            },
                            {
                                type: 'single-text',
                                label: 'Veröffentlichungsdatum (natürlichsprachlich)',
                                path: 'profileDesc.creation.date._text'
                            }
                        ]
                    },
                    {
                        title: 'Digitale Version',
                        entries: [
                            {
                                type: 'single-text',
                                label: 'Distributor',
                                path: 'fileDesc.publicationStmt.distributor._text'
                            },
                            {
                                type: 'single-text',
                                label: 'Taxonomie: Schlüssel',
                                path: 'encodingDesc.classDecl.taxonomy._attrs.xml:id'
                            },
                            {
                                type: 'single-text',
                                label: 'Taxonomie: Name',
                                path: 'encodingDesc.classDecl.taxonomy.bibl._text'
                            },
                            {
                                type: 'single-text',
                                label: 'Kategorie',
                                path: 'profileDesc.textClass.catRef._attrs.target'
                            }
                        ]
                    },
                    {
                        title: 'Verantwortliche',
                        entries: [
                            {
                                type: 'multi-field',
                                path: 'fileDesc.titleStmt.respStmt',
                                entries: [
                                    {
                                        type: 'single-text',
                                        label: 'Schlüssel',
                                        path: '_attrs.xml:id'
                                    },
                                    {
                                        type: 'single-text',
                                        label: 'Verantwortlich für',
                                        path: 'resp._text'
                                    },
                                    {
                                        type: 'single-text',
                                        label: 'Name',
                                        path: 'name._text'
                                    }
                                ]
                            }
                        ]
                    },
                    {
                        title: 'Änderungsgeschichte',
                        entries: [
                            {
                                type: 'multi-field',
                                path: 'revisionDesc.change',
                                entries: [
                                    {
                                        type: 'single-text',
                                        label: 'Änderung',
                                        path: '_text'
                                    },
                                    {
                                        type: 'single-text',
                                        label: 'Durch',
                                        path: '_attrs.who'
                                    },
                                    {
                                        type: 'single-text',
                                        label: 'Datum (JJJJ-MM-TT)',
                                        path: '_attrs.when'
                                    }
                                ]
                            }
                        ]
                    }
                ]
            },

            // =========
            // Haupttext
            // =========
            mainText: {
                title: 'Haupttext',
                type: 'single-text',
                parser: {
                    selector: 'tei:text/tei:body',
                },
                serializer: {
                    tag: 'tei:text'
                },
                schema: {
                    nodes: {
                        doc: {
                            content: 'block+',
                            parser: {
                                selector: 'tei:body'
                            },
                            serializer: {
                                tag: 'tei:body'
                            }
                        },
                        paragraph: {
                            group: 'block',
                            content: 'inline*',
                            parser: {
                                selector: 'tei:p'
                            },
                            serializer: {
                                tag: 'tei:p'
                            },
                            attrs: {
                                noIndent: {
                                    default: false,
                                    parser: {
                                        selector: 'contains(@style, "no-indent")',
                                        type: 'boolean'
                                    },
                                    serializer: {
                                        attr: 'style',
                                        values: {
                                            true: 'no-indent'
                                        }
                                    }
                                },
                                textAlign: {
                                    default: 'left',
                                    parsers: [
                                        {
                                            selector: "contains(@style, 'text-left')",
                                            type: 'static',
                                            value: 'left'
                                        },
                                        {
                                            selector: "contains(@style, 'text-center')",
                                            type: 'static',
                                            value: 'center'
                                        },
                                        {
                                            selector: "contains(@style, 'text-right')",
                                            type: 'static',
                                            value: 'right'
                                        },
                                        {
                                            selector: "contains(@style, 'text-justify')",
                                            type: 'static',
                                            value: 'justify'
                                        }
                                    ],
                                    serializer: {
                                        attr: 'style',
                                        values: {
                                            center: 'text-center',
                                            right: 'text-right',
                                            justify: 'text-justify'
                                        }
                                    }
                                }
                            },
                        },
                        heading: {
                            group: 'block',
                            content: 'inline*',
                            parser: {
                                selector: 'tei:head'
                            },
                            serializer: {
                                tag: 'tei:head'
                            },
                            attrs: {
                                headingId: {
                                    default: null,
                                    parser: {
                                        selector: '@data-heading-id'
                                    },
                                    serializer: {
                                        attr: 'data-heading-id'
                                    }
                                },
                                level: {
                                    default: 1,
                                    parser: {
                                        selector: 'substring(@type, 7)'
                                    },
                                    serializer: {
                                        attr: 'type',
                                        value: 'level-${value}'
                                    }
                                }
                            },
                            defining: true
                        },
                        line: {
                            group: 'block',
                            content: 'inline*',
                            parser: {
                                selector: 'tei:l'
                            },
                            serializer: {
                                tag: 'tei:l'
                            }
                        },
                        lineGroup: {
                            group: 'block',
                            content: 'line+',
                            parser: {
                                selector: 'tei:lg'
                            },
                            serializer: {
                                tag: 'tei:lg'
                            }
                        },
                        text: {
                            group: 'inline',
                            inline: true,
                            parsers: [
                                {
                                    selector: 'tei:seg',
                                    text: 'text()'
                                },
                                {
                                    selector: 'tei:hi',
                                    text: 'text()'
                                },
                            ],
                            serializer: {
                                tag: 'tei:seg'
                            }
                        },
                        annotationGlobal: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:ref[@target="#global"]',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:ref'
                            },
                            attrs: {
                                target: {
                                    default: 'global',
                                    parser: {
                                        selector: 'substring(@target, 2)'
                                    },
                                    serializer: {
                                        attr: 'target',
                                        value: '#${value}'
                                    }
                                },
                                headingId: {
                                    default: null,
                                    parser: {
                                        selector: '@data-heading-id'
                                    },
                                    serializer: {
                                        attr: 'data-heading-id'
                                    }
                                }
                            }
                        },
                        annotation: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:ref',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:ref'
                            },
                            attrs: {
                                target: {
                                    default: 'unknown',
                                    parser: {
                                        selector: 'substring(@target, 2)'
                                    },
                                    serializer: {
                                        attr: 'target',
                                        value: '#${value}'
                                    }
                                }
                            }
                        },
                        pageBegin: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:pb',
                                text: '@n'
                            },
                            serializer: {
                                tag: 'tei:pb',
                                text: {
                                    attr: 'n'
                                }
                            }
                        },
                        footnote: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:note[@type="footnote"]',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:note',
                            },
                            attrs: {
                                type: {
                                    default: 'footnote',
                                    serializer: {
                                        attr: 'type',
                                        value: 'footnote'
                                    }
                                },
                                marker: {
                                    default: '',
                                    parser: {
                                        selector: '@data-marker'
                                    },
                                    serializer: {
                                        attr: 'data-marker'
                                    }
                                }
                            }
                        },
                        foreignLanguage: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:foreign',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:foreign'
                            }
                        },
                    },
                    marks: {
                        letterSparse: {
                            parser: {
                                selector: 'contains(@style, "letter-sparse")'
                            },
                            serializer: {
                                tag: 'tei:hi',
                                attrs: {
                                    style: {
                                        value: 'letter-sparse'
                                    }
                                }
                            }
                        },
                        sup: {
                            parser: {
                                selector: 'contains(@style, "sup")'
                            },
                            serializer: {
                                tag: 'tei:hi',
                                attrs: {
                                    style: {
                                        value: 'sup'
                                    }
                                }
                            }
                        },
                        fontSize: {
                            parsers: [
                                {
                                    selector: "contains(@style, 'font-size-small')"
                                },
                                {
                                    selector: "contains(@style, 'font-size-medium')"
                                },
                                {
                                    selector: "contains(@style, 'font-size-large')"
                                }
                            ],
                            serializer: {
                                tag: 'tei:hi'
                            },
                            attrs: {
                                size: {
                                    default: '',
                                    parsers: [
                                        {
                                            selector: "contains(@style, 'font-size-small')",
                                            type: 'static',
                                            value: 'small'
                                        },
                                        {
                                            selector: "contains(@style, 'font-size-medium')",
                                            type: 'static',
                                            value: 'medium'
                                        },
                                        {
                                            selector: "contains(@style, 'font-size-large')",
                                            type: 'static',
                                            value: 'large'
                                        }
                                    ],
                                    serializer: {
                                        attr: 'style',
                                        values: {
                                            small: 'font-size-small',
                                            medium: 'font-size-medium',
                                            large: 'font-size-large'
                                        }
                                    }
                                }
                            }
                        },
                        fontWeightBold: {
                            parser: {
                                selector: 'contains(@style, "font-weight-bold")'
                            },
                            serializer: {
                                tag: 'tei:hi',
                                attrs: {
                                    style: {
                                        value: 'font-weight-bold'
                                    }
                                }
                            }
                        },
                        fontStyleItalic: {
                            parser: {
                                selector: 'contains(@style, "font-style-italic")'
                            },
                            serializer: {
                                tag: 'tei:hi',
                                attrs: {
                                    style: {
                                        value: 'font-style-italic'
                                    }
                                }
                            }
                        }
                    }
                },
                ui: [
                    {
                        title: 'Blocktypen',
                        type: 'block-type',
                        blocks: [
                            {
                                type: 'heading',
                                label: 'Überschrift'
                            },
                            {
                                type: 'paragraph',
                                label: 'Absatz'
                            },
                            {
                                type: 'lineGroup',
                                label: 'Vers',
                                wrapping: true
                            },
                            {
                                type: 'line',
                                label: 'Zeile'
                            },
                        ]
                    },
                    {
                        title: 'Auszeichnungen',
                        type: 'block-type',
                        blocks: [
                            {
                                type: 'annotation',
                                label: 'Einzelstellenverweis'
                            },
                            {
                                type: 'annotationGlobal',
                                label: 'Globalkommentarverweis'
                            },
                            {
                                type: 'pageBegin',
                                label: 'Seitenanfang'
                            },
                            {
                                type: 'footnote',
                                label: 'Fußnote'
                            },
                            {
                                type: 'foreignLanguage',
                                label: 'Fremdsprachiger Text'
                            }
                        ]
                    },
                    {
                        title: 'Überschrift',
                        type: 'toolbar',
                        context: 'blocks.heading',
                        entries: [
                            {
                                type: 'select-attr',
                                attr: 'level',
                                values: [
                                    {
                                        key: '1',
                                        value: 'Ebene 1'
                                    },
                                    {
                                        key: '2',
                                        value: 'Ebene 2'
                                    },
                                    {
                                        key: '3',
                                        value: 'Ebene 3'
                                    }
                                ]
                            },
                            {
                                type: 'text-attr',
                                attr: 'headingId',
                                dataType: 'text'
                            }
                        ]
                    },
                    {
                        title: 'Absatz',
                        type: 'toolbar',
                        context: 'blocks.paragraph',
                        entries: [
                            {
                                type: 'toggle-attr',
                                attr: 'noIndent',
                                label: "Nicht einrücken",
                                icon: {
                                    on: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M11,13H21V11H11M11,9H21V7H11M3,3V5H21V3M11,17H21V15H11M3,8V16L7,12M3,21H21V19H3V21Z" /></svg>',
                                    off: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M11,13H21V11H11M11,9H21V7H11M3,3V5H21V3M3,21H21V19H3M3,12L7,16V8M11,17H21V15H11V17Z" /></svg>'
                                }
                            },
                            {
                                type: 'separator'
                            },
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'left',
                                label: 'Linksbündig',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M3,7H15V9H3V7M3,11H21V13H3V11M3,15H15V17H3V15M3,19H21V21H3V19Z" /></svg>'
                            },
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'center',
                                label: 'Zentriert',
                                icon: '<svg style="viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M7,7H17V9H7V7M3,11H21V13H3V11M7,15H17V17H7V15M3,19H21V21H3V19Z" /></svg>'
                            },
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'right',
                                label: 'Rechtsbündig',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M9,7H21V9H9V7M3,11H21V13H3V11M9,15H21V17H9V15M3,19H21V21H3V19Z" /></svg>'
                            },
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'justify',
                                label: 'Block',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M3,7H21V9H3V7M3,11H21V13H3V11M3,15H21V17H3V15M3,19H21V21H3V19Z" /></svg>'
                            },
                        ]
                    },
                    {
                        title: 'Darstellung',
                        type: 'toolbar',
                        context: 'marks',
                        entries: [
                            {
                                type: 'select-mark-attr',
                                mark: 'fontSize',
                                attr: 'size',
                                values: [
                                    {
                                        key: '',
                                        label: 'Normal'
                                    },
                                    {
                                        key: 'small',
                                        label: 'Klein',
                                    },
                                    {
                                        key: 'medium',
                                        label: 'Mittel',
                                    },
                                    {
                                        key: 'large',
                                        label: 'Groß'
                                    }
                                ]
                            },
                            {
                                type: 'toggle-mark',
                                mark: 'fontWeightBold',
                                label: 'Fettdruck',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M13.5,15.5H10V12.5H13.5A1.5,1.5 0 0,1 15,14A1.5,1.5 0 0,1 13.5,15.5M10,6.5H13A1.5,1.5 0 0,1 14.5,8A1.5,1.5 0 0,1 13,9.5H10M15.6,10.79C16.57,10.11 17.25,9 17.25,8C17.25,5.74 15.5,4 13.25,4H7V18H14.04C16.14,18 17.75,16.3 17.75,14.21C17.75,12.69 16.89,11.39 15.6,10.79Z" /></svg>'
                            },
                            {
                                type: 'toggle-mark',
                                mark: 'fontStyleItalic',
                                label: 'Kursiv',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M10,4V7H12.21L8.79,15H6V18H14V15H11.79L15.21,7H18V4H10Z" /></svg>'
                            },
                            {
                                type: 'toggle-mark',
                                mark: 'letterSparse',
                                label: 'Sperrung',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M7,8L2.5,12L7,16V8M17,8V16L21.5,12L17,8M12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12A2,2 0 0,0 12,10Z" /></svg>'
                            },
                            {
                                type: 'toggle-mark',
                                mark: 'sup',
                                label: 'Hochgestellt',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M16,7.41L11.41,12L16,16.59L14.59,18L10,13.41L5.41,18L4,16.59L8.59,12L4,7.41L5.41,6L10,10.59L14.59,6L16,7.41M21.85,9H16.97V8L17.86,7.18C18.62,6.54 19.18,6 19.56,5.55C19.93,5.11 20.12,4.7 20.13,4.32C20.14,4.04 20.05,3.8 19.86,3.62C19.68,3.43 19.39,3.34 19,3.33C18.69,3.34 18.42,3.4 18.16,3.5L17.5,3.89L17.05,2.72C17.32,2.5 17.64,2.33 18.03,2.19C18.42,2.05 18.85,2 19.32,2C20.1,2 20.7,2.2 21.1,2.61C21.5,3 21.72,3.54 21.72,4.18C21.71,4.74 21.53,5.26 21.18,5.73C20.84,6.21 20.42,6.66 19.91,7.09L19.27,7.61V7.63H21.85V9Z" /></svg>'
                            }
                        ]
                    },
                    {
                        title: 'Einzelstellenverweis',
                        type: 'toolbar',
                        context: 'blocks.annotation',
                        entries: [
                            {
                                type: 'select-attr',
                                attr: 'target',
                                valueSource: 'annotations'
                            }
                        ]
                    },
                    {
                        title: 'Globalkommentarverweis Abschnitt (optional)',
                        type: 'toolbar',
                        context: 'blocks.annotationGlobal',
                        entries: [
                            {
                                type: 'text-attr',
                                attr: 'headingId',
                                dataType: 'text'
                            }
                        ]
                    },
                    {
                        title: 'Fußnotenmarkierung',
                        type: 'toolbar',
                        context: 'blocks.footnote',
                        entries: [
                            {
                                type: 'text-attr',
                                attr: 'marker',
                                dataType: 'text'
                            }
                        ]
                    }
                ]
            },

            // ===============
            // Globalkommentar
            // ===============
            globalComment: {
                title: 'Kommentierung',
                type: 'single-text',
                parser: {
                    selector: 'tei:text/tei:interpGrp[@type="global"]',
                },
                serializer: {
                    tag: 'tei:text'
                },
                schema: {
                    nodes: {
                        doc: {
                            content: 'block+',
                            parser: {
                                selector: 'tei:interpGrp[@type="global"]'
                            },
                            serializer: {
                                tag: 'tei:interpGrp',
                                attrs: {
                                    type: 'global',
                                    'xml:id': 'global'
                                }
                            }
                        },
                        paragraph: {
                            group: 'block',
                            content: 'inline*',
                            parser: {
                                selector: 'tei:p'
                            },
                            serializer: {
                                tag: 'tei:p'
                            },
                            attrs: {
                                noIndent: {
                                    default: false,
                                    parser: {
                                        selector: 'contains(@style, "no-indent")',
                                        type: 'boolean'
                                    },
                                    serializer: {
                                        attr: 'style',
                                        values: {
                                            true: 'no-indent'
                                        }
                                    }
                                },
                                textAlign: {
                                    default: 'left',
                                    parsers: [
                                        {
                                            selector: "contains(@style, 'text-left')",
                                            type: 'static',
                                            value: 'left'
                                        },
                                        {
                                            selector: "contains(@style, 'text-center')",
                                            type: 'static',
                                            value: 'center'
                                        },
                                        {
                                            selector: "contains(@style, 'text-right')",
                                            type: 'static',
                                            value: 'right'
                                        },
                                        {
                                            selector: "contains(@style, 'text-justify')",
                                            type: 'static',
                                            value: 'justify'
                                        }
                                    ],
                                    serializer: {
                                        attr: 'style',
                                        values: {
                                            center: 'text-center',
                                            right: 'text-right',
                                            justify: 'text-justify'
                                        }
                                    }
                                }
                            },
                        },
                        heading: {
                            group: 'block',
                            content: 'inline*',
                            parser: {
                                selector: 'tei:head'
                            },
                            serializer: {
                                tag: 'tei:head'
                            },
                            attrs: {
                                headingId: {
                                    default: null,
                                    parser: {
                                        selector: '@data-heading-id'
                                    },
                                    serializer: {
                                        attr: 'data-heading-id'
                                    }
                                },
                                level: {
                                    default: 1,
                                    parser: {
                                        selector: 'substring(@type, 7)'
                                    },
                                    serializer: {
                                        attr: 'type',
                                        value: 'level-${value}'
                                    }
                                }
                            },
                            defining: true
                        },
                        source: {
                            group: 'block',
                            content: 'inline*',
                            parser: {
                                selector: 'tei:item'
                            },
                            serializer: {
                                tag: 'tei:item'
                            },
                            attrs: {
                                sourceId: {
                                    default: '',
                                    parser: {
                                        selector: '@data-source-id'
                                    },
                                    serializer: {
                                        attr: 'data-source-id',
                                        value: '${value}'
                                    }
                                }
                            }
                        },
                        sourceList: {
                            group: 'block',
                            content: 'source+',
                            parser: {
                                selector: 'tei:list[@type="sources"]'
                            },
                            serializer: {
                                tag: 'tei:list',
                                attrs: {
                                    type: 'sources'
                                }
                            }
                        },
                        text: {
                            group: 'inline',
                            inline: true,
                            parsers: [
                                {
                                    selector: 'tei:seg',
                                    text: 'text()'
                                },
                                {
                                    selector: 'tei:hi',
                                    text: 'text()'
                                },
                            ],
                            serializer: {
                                tag: 'tei:seg'
                            }
                        },
                        pageLineRef: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:citedRange[@type="page-line-ref"]',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:citedRange',
                                attrs: {
                                    type: 'page-line-ref'
                                }
                            }
                        },
                        wordRange: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:citedRange[@type="word-range"]',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:citedRange',
                                attrs: {
                                    type: 'word-range'
                                }
                            }
                        },
                        annotationGlobal: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:ref[@target="#global"]',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:ref'
                            },
                            attrs: {
                                target: {
                                    default: 'global',
                                    parser: {
                                        selector: 'substring(@target, 2)'
                                    },
                                    serializer: {
                                        attr: 'target',
                                        value: '#${value}'
                                    }
                                },
                                headingId: {
                                    default: null,
                                    parser: {
                                        selector: '@data-heading-id'
                                    },
                                    serializer: {
                                        attr: 'data-heading-id'
                                    }
                                }
                            }
                        },
                        annotation: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:ref',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:ref'
                            },
                            attrs: {
                                target: {
                                    default: 'unknown',
                                    parser: {
                                        selector: 'substring(@target, 2)'
                                    },
                                    serializer: {
                                        attr: 'target',
                                        value: '#${value}'
                                    }
                                }
                            }
                        },
                        foreignLanguage: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:foreign',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:foreign'
                            }
                        },
                        quotation: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:q',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:q'
                            }
                        },
                        lemma: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:lem',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:lem',
                            }
                        },
                        sic: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:sic',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:sic',
                            }
                        },
                        missing: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:metamark[@function="missing"]',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:metamark'
                            },
                            attrs: {
                                function: {
                                    default: 'missing',
                                    serializer: {
                                        attr: 'function',
                                        value: 'missing'
                                    }
                                },
                            },
                        },
                    },
                    marks: {
                        letterSparse: {
                            parser: {
                                selector: 'contains(@style, "letter-sparse")'
                            },
                            serializer: {
                                tag: 'tei:hi',
                                attrs: {
                                    style: {
                                        value: 'letter-sparse'
                                    }
                                }
                            }
                        },
                        sup: {
                            parser: {
                                selector: 'contains(@style, "sup")'
                            },
                            serializer: {
                                tag: 'tei:hi',
                                attrs: {
                                    style: {
                                        value: 'sup'
                                    }
                                }
                            }
                        },
                        fontSize: {
                            parsers: [
                                {
                                    selector: "contains(@style, 'font-size-small')"
                                },
                                {
                                    selector: "contains(@style, 'font-size-medium')"
                                },
                                {
                                    selector: "contains(@style, 'font-size-large')"
                                }
                            ],
                            serializer: {
                                tag: 'tei:hi'
                            },
                            attrs: {
                                size: {
                                    default: '',
                                    parsers: [
                                        {
                                            selector: "contains(@style, 'font-size-small')",
                                            type: 'static',
                                            value: 'small'
                                        },
                                        {
                                            selector: "contains(@style, 'font-size-medium')",
                                            type: 'static',
                                            value: 'medium'
                                        },
                                        {
                                            selector: "contains(@style, 'font-size-large')",
                                            type: 'static',
                                            value: 'large'
                                        }
                                    ],
                                    serializer: {
                                        attr: 'style',
                                        values: {
                                            small: 'font-size-small',
                                            medium: 'font-size-medium',
                                            large: 'font-size-large'
                                        }
                                    }
                                }
                            }
                        },
                        fontWeightBold: {
                            parser: {
                                selector: 'contains(@style, "font-weight-bold")'
                            },
                            serializer: {
                                tag: 'tei:hi',
                                attrs: {
                                    style: {
                                        value: 'font-weight-bold'
                                    }
                                }
                            }
                        },
                    }
                },
                ui: [
                    {
                        title: 'Blocktypen',
                        type: 'block-type',
                        blocks: [
                            {
                                type: 'heading',
                                label: 'Überschrift'
                            },
                            {
                                type: 'paragraph',
                                label: 'Absatz'
                            },
                            {
                                type: 'sourceList',
                                label: 'Quellenliste',
                                wrapping: true
                            },
                            {
                                type: 'source',
                                label: 'Quelle'
                            },
                        ]
                    },
                    {
                        title: 'Auszeichnungen',
                        type: 'block-type',
                        blocks: [
                            {
                                type: 'pageLineRef',
                                label: 'Seite & Zeile'
                            },
                            {
                                type: 'wordRange',
                                label: 'Wortspanne'
                            },
                            {
                                type: 'annotation',
                                label: 'Einzelstellenverweis'
                            },
                            {
                                type: 'annotationGlobal',
                                label: 'Globalkommentarverweis'
                            },
                            {
                                type: 'foreignLanguage',
                                label: 'Fremdsprachiger Text'
                            },
                            {
                                type: 'quotation',
                                label: 'Zitat'
                            },
                            {
                                type: 'lemma',
                                label: 'Lemma'
                            },
                            {
                                type: 'sic',
                                label: 'Korrigierter Text'
                            },
                            {
                                type: 'missing',
                                label: 'Nicht ermittelt'
                            },
                        ]
                    },
                    {
                        title: 'Überschrift',
                        type: 'toolbar',
                        context: 'blocks.heading',
                        entries: [
                            {
                                type: 'select-attr',
                                attr: 'level',
                                values: [
                                    {
                                        key: '1',
                                        value: 'Ebene 1'
                                    },
                                    {
                                        key: '2',
                                        value: 'Ebene 2'
                                    },
                                    {
                                        key: '3',
                                        value: 'Ebene 3'
                                    }
                                ]
                            },
                            {
                                type: 'text-attr',
                                attr: 'headingId',
                                dataType: 'text'
                            }
                        ]
                    },
                    {
                        title: 'Absatz',
                        type: 'toolbar',
                        context: 'blocks.paragraph',
                        entries: [
                            {
                                type: 'toggle-attr',
                                attr: 'noIndent',
                                label: "Nicht einrücken",
                                icon: {
                                    on: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M11,13H21V11H11M11,9H21V7H11M3,3V5H21V3M11,17H21V15H11M3,8V16L7,12M3,21H21V19H3V21Z" /></svg>',
                                    off: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M11,13H21V11H11M11,9H21V7H11M3,3V5H21V3M3,21H21V19H3M3,12L7,16V8M11,17H21V15H11V17Z" /></svg>'
                                }
                            },
                            {
                                type: 'separator'
                            },
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'left',
                                label: 'Linksbündig',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M3,7H15V9H3V7M3,11H21V13H3V11M3,15H15V17H3V15M3,19H21V21H3V19Z" /></svg>'
                            },
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'center',
                                label: 'Zentriert',
                                icon: '<svg style="viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M7,7H17V9H7V7M3,11H21V13H3V11M7,15H17V17H7V15M3,19H21V21H3V19Z" /></svg>'
                            },
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'right',
                                label: 'Rechtsbündig',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M9,7H21V9H9V7M3,11H21V13H3V11M9,15H21V17H9V15M3,19H21V21H3V19Z" /></svg>'
                            },
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'justify',
                                label: 'Block',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M3,7H21V9H3V7M3,11H21V13H3V11M3,15H21V17H3V15M3,19H21V21H3V19Z" /></svg>'
                            }
                        ]
                    },
                    {
                        title: 'Quelle',
                        type: 'toolbar',
                        context: 'blocks.source',
                        entries: [
                            {
                                type: 'text-attr',
                                attr: 'sourceId',
                                dataType: 'text'
                            }
                        ]
                    },
                    {
                        title: 'Darstellung',
                        type: 'toolbar',
                        context: 'marks',
                        entries: [
                            {
                                type: 'select-mark-attr',
                                mark: 'fontSize',
                                attr: 'size',
                                values: [
                                    {
                                        key: '',
                                        label: 'Normal'
                                    },
                                    {
                                        key: 'small',
                                        label: 'Klein',
                                    },
                                    {
                                        key: 'medium',
                                        label: 'Mittel',
                                    },
                                    {
                                        key: 'large',
                                        label: 'Groß'
                                    }
                                ]
                            },
                            {
                                type: 'toggle-mark',
                                mark: 'fontWeightBold',
                                label: 'Fettdruck',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M13.5,15.5H10V12.5H13.5A1.5,1.5 0 0,1 15,14A1.5,1.5 0 0,1 13.5,15.5M10,6.5H13A1.5,1.5 0 0,1 14.5,8A1.5,1.5 0 0,1 13,9.5H10M15.6,10.79C16.57,10.11 17.25,9 17.25,8C17.25,5.74 15.5,4 13.25,4H7V18H14.04C16.14,18 17.75,16.3 17.75,14.21C17.75,12.69 16.89,11.39 15.6,10.79Z" /></svg>'
                            },
                            {
                                type: 'toggle-mark',
                                mark: 'letterSparse',
                                label: 'Sperrung',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M7,8L2.5,12L7,16V8M17,8V16L21.5,12L17,8M12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12A2,2 0 0,0 12,10Z" /></svg>'
                            },
                            {
                                type: 'toggle-mark',
                                mark: 'sup',
                                label: 'Hochgestellt',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M16,7.41L11.41,12L16,16.59L14.59,18L10,13.41L5.41,18L4,16.59L8.59,12L4,7.41L5.41,6L10,10.59L14.59,6L16,7.41M21.85,9H16.97V8L17.86,7.18C18.62,6.54 19.18,6 19.56,5.55C19.93,5.11 20.12,4.7 20.13,4.32C20.14,4.04 20.05,3.8 19.86,3.62C19.68,3.43 19.39,3.34 19,3.33C18.69,3.34 18.42,3.4 18.16,3.5L17.5,3.89L17.05,2.72C17.32,2.5 17.64,2.33 18.03,2.19C18.42,2.05 18.85,2 19.32,2C20.1,2 20.7,2.2 21.1,2.61C21.5,3 21.72,3.54 21.72,4.18C21.71,4.74 21.53,5.26 21.18,5.73C20.84,6.21 20.42,6.66 19.91,7.09L19.27,7.61V7.63H21.85V9Z" /></svg>'
                            }
                        ]
                    },
                    {
                        title: 'Einzelstellenverweis',
                        type: 'toolbar',
                        context: 'blocks.annotation',
                        entries: [
                            {
                                type: 'select-attr',
                                attr: 'target',
                                valueSource: 'annotations'
                            }
                        ]
                    },
                    {
                        title: 'Globalkommentarverweis Abschnitt (optional)',
                        type: 'toolbar',
                        context: 'blocks.annotationGlobal',
                        entries: [
                            {
                                type: 'text-attr',
                                attr: 'headingId',
                                dataType: 'text'
                            }
                        ]
                    }
                ]
            },

            // ========================
            // Einstelstellenkommentare
            // ========================
            annotations: {
                title: 'Einzelstellenerläuterungen',
                type: 'multi-text',
                parser: {
                    selector: 'tei:text/tei:interpGrp[@type="individual"]',
                },
                serializer: {
                    tag: 'tei:text'
                },
                parts: {
                    parser: {
                        selector: 'tei:interp'
                    },
                    serializer: {
                        tag: 'tei:interpGrp',
                        attrs: {
                            type: 'individual'
                        }
                    }
                },
                schema: {
                    nodes: {
                        doc: {
                            content: 'block+',
                            parser: {
                                selector: 'tei:interp'
                            },
                            serializer: {
                                tag: 'tei:interp'
                            },
                            attrs: {
                                id: {
                                    default: 'unknown',
                                    parser: {
                                        selector: '@xml:id'
                                    },
                                    serializer: {
                                        attr: 'xml:id',
                                        value: '${value}'
                                    }
                                }
                            }
                        },
                        paragraph: {
                            group: 'block',
                            content: 'inline*',
                            parser: {
                                selector: 'tei:p'
                            },
                            serializer: {
                                tag: 'tei:p'
                            },
                            attrs: {
                                textAlign: {
                                    default: 'left',
                                    parsers: [
                                        {
                                            selector: "contains(@style, 'text-left')",
                                            type: 'static',
                                            value: 'left'
                                        },
                                        {
                                            selector: "contains(@style, 'text-center')",
                                            type: 'static',
                                            value: 'center'
                                        },
                                        {
                                            selector: "contains(@style, 'text-right')",
                                            type: 'static',
                                            value: 'right'
                                        },
                                        {
                                            selector: "contains(@style, 'text-justify')",
                                            type: 'static',
                                            value: 'justify'
                                        }
                                    ],
                                    serializer: {
                                        attr: 'style',
                                        values: {
                                            center: 'text-center',
                                            right: 'text-right',
                                            justify: 'text-justify'
                                        }
                                    }
                                }
                            },
                        },
                        text: {
                            group: 'inline',
                            inline: true,
                            parsers: [
                                {
                                    selector: 'tei:seg',
                                    text: 'text()'
                                },
                                {
                                    selector: 'tei:hi',
                                    text: 'text()'
                                },
                                {
                                    selector: 'tei:foreign',
                                    text: 'text()'
                                },
                                {
                                    selector: 'tei:q',
                                    text: 'text()'
                                }
                            ],
                            serializer: {
                                tag: 'tei:seg'
                            }
                        },
                        pageLineRef: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:citedRange[@type="page-line-ref"]',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:citedRange',
                                attrs: {
                                    type: 'page-line-ref'
                                }
                            }
                        },
                        wordRange: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:citedRange[@type="word-range"]',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:citedRange',
                                attrs: {
                                    type: 'word-range'
                                }
                            }
                        },
                        annotationGlobal: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:ref[@target="#global"]',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:ref'
                            },
                            attrs: {
                                target: {
                                    default: 'global',
                                    parser: {
                                        selector: 'substring(@target, 2)'
                                    },
                                    serializer: {
                                        attr: 'target',
                                        value: '#${value}'
                                    }
                                },
                                headingId: {
                                    default: null,
                                    parser: {
                                        selector: '@data-heading-id'
                                    },
                                    serializer: {
                                        attr: 'data-heading-id'
                                    }
                                }
                            }
                        },
                        annotation: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:ref',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:ref'
                            },
                            attrs: {
                                target: {
                                    default: 'unknown',
                                    parser: {
                                        selector: 'substring(@target, 2)'
                                    },
                                    serializer: {
                                        attr: 'target',
                                        value: '#${value}'
                                    }
                                }
                            }
                        },
                        foreignLanguage: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:foreign',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:foreign'
                            }
                        },
                        quotation: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:q',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:q'
                            }
                        },
                        missing: {
                            group: 'inline',
                            inline: true,
                            content: 'text*',
                            parser: {
                                selector: 'tei:metamark[@function="missing"]',
                                text: 'text()'
                            },
                            serializer: {
                                tag: 'tei:metamark'
                            },
                            attrs: {
                                function: {
                                    default: 'missing',
                                    serializer: {
                                        attr: 'function',
                                        value: 'missing'
                                    }
                                },
                            },
                        },
                    },
                    marks: {
                        letterSparse: {
                            parser: {
                                selector: 'contains(@style, "letter-sparse")'
                            },
                            serializer: {
                                tag: 'tei:hi',
                                attrs: {
                                    style: {
                                        value: 'letter-sparse'
                                    }
                                }
                            }
                        },
                        sup: {
                            parser: {
                                selector: 'contains(@style, "sup")'
                            },
                            serializer: {
                                tag: 'tei:hi',
                                attrs: {
                                    style: {
                                        value: 'sup'
                                    }
                                }
                            }
                        },
                        fontSize: {
                            parsers: [
                                {
                                    selector: "contains(@style, 'font-size-small')"
                                },
                                {
                                    selector: "contains(@style, 'font-size-medium')"
                                },
                                {
                                    selector: "contains(@style, 'font-size-large')"
                                }
                            ],
                            serializer: {
                                tag: 'tei:hi'
                            },
                            attrs: {
                                size: {
                                    default: '',
                                    parsers: [
                                        {
                                            selector: "contains(@style, 'font-size-small')",
                                            type: 'static',
                                            value: 'small'
                                        },
                                        {
                                            selector: "contains(@style, 'font-size-medium')",
                                            type: 'static',
                                            value: 'medium'
                                        },
                                        {
                                            selector: "contains(@style, 'font-size-large')",
                                            type: 'static',
                                            value: 'large'
                                        }
                                    ],
                                    serializer: {
                                        attr: 'style',
                                        values: {
                                            small: 'font-size-small',
                                            medium: 'font-size-medium',
                                            large: 'font-size-large'
                                        }
                                    }
                                }
                            }
                        },
                    }
                },
                ui: [
                    {
                        title: 'Schlüssel',
                        type: 'toolbar',
                        context: 'blocks.doc',
                        entries: [
                            {
                                type: 'doc-text-attr',
                                attr: 'id'
                            }
                        ]
                    },
                    {
                        title: 'Auszeichnungen',
                        type: 'block-type',
                        blocks: [
                            {
                                type: 'pageLineRef',
                                label: 'Seite & Zeile'
                            },
                            {
                                type: 'wordRange',
                                label: 'Wortspanne'
                            },
                            {
                                type: 'annotation',
                                label: 'Einzelstellenverweis'
                            },
                            {
                                type: 'annotationGlobal',
                                label: 'Globalkommentarverweis'
                            },
                            {
                                type: 'foreignLanguage',
                                label: 'Fremdsprachiger Text'
                            },
                            {
                                type: 'quotation',
                                label: 'Zitat'
                            },
                            {
                                type: 'missing',
                                label: 'Nicht ermittelt'
                            },
                        ]
                    },
                    {
                        title: 'Absatz',
                        type: 'toolbar',
                        context: 'blocks.paragraph',
                        entries: [
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'left',
                                label: 'Linksbündig',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M3,7H15V9H3V7M3,11H21V13H3V11M3,15H15V17H3V15M3,19H21V21H3V19Z" /></svg>'
                            },
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'center',
                                label: 'Zentriert',
                                icon: '<svg style="viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M7,7H17V9H7V7M3,11H21V13H3V11M7,15H17V17H7V15M3,19H21V21H3V19Z" /></svg>'
                            },
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'right',
                                label: 'Rechtsbündig',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M9,7H21V9H9V7M3,11H21V13H3V11M9,15H21V17H9V15M3,19H21V21H3V19Z" /></svg>'
                            },
                            {
                                type: 'set-attr',
                                attr: 'textAlign',
                                value: 'justify',
                                label: 'Block',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M3,3H21V5H3V3M3,7H21V9H3V7M3,11H21V13H3V11M3,15H21V17H3V15M3,19H21V21H3V19Z" /></svg>'
                            }
                        ]
                    },
                    {
                        title: 'Styling',
                        type: 'toolbar',
                        context: 'marks',
                        entries: [
                            {
                                type: 'select-mark-attr',
                                mark: 'fontSize',
                                attr: 'size',
                                values: [
                                    {
                                        key: '',
                                        label: 'Normal'
                                    },
                                    {
                                        key: 'small',
                                        label: 'Klein',
                                    },
                                    {
                                        key: 'medium',
                                        label: 'Mittel',
                                    },
                                    {
                                        key: 'large',
                                        label: 'Groß'
                                    }
                                ]
                            },
                            {
                                type: 'toggle-mark',
                                mark: 'fontWeightBold',
                                label: 'Fettdruck',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M13.5,15.5H10V12.5H13.5A1.5,1.5 0 0,1 15,14A1.5,1.5 0 0,1 13.5,15.5M10,6.5H13A1.5,1.5 0 0,1 14.5,8A1.5,1.5 0 0,1 13,9.5H10M15.6,10.79C16.57,10.11 17.25,9 17.25,8C17.25,5.74 15.5,4 13.25,4H7V18H14.04C16.14,18 17.75,16.3 17.75,14.21C17.75,12.69 16.89,11.39 15.6,10.79Z" /></svg>'
                            },
                            {
                                type: 'toggle-mark',
                                mark: 'letterSparse',
                                label: 'Sperrung',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M7,8L2.5,12L7,16V8M17,8V16L21.5,12L17,8M12,10A2,2 0 0,0 10,12A2,2 0 0,0 12,14A2,2 0 0,0 14,12A2,2 0 0,0 12,10Z" /></svg>'
                            },
                            {
                                type: 'toggle-mark',
                                mark: 'sup',
                                label: 'Hochgestellt',
                                icon: '<svg viewBox="0 0 24 24" class="mdi-icon"><path d="M16,7.41L11.41,12L16,16.59L14.59,18L10,13.41L5.41,18L4,16.59L8.59,12L4,7.41L5.41,6L10,10.59L14.59,6L16,7.41M21.85,9H16.97V8L17.86,7.18C18.62,6.54 19.18,6 19.56,5.55C19.93,5.11 20.12,4.7 20.13,4.32C20.14,4.04 20.05,3.8 19.86,3.62C19.68,3.43 19.39,3.34 19,3.33C18.69,3.34 18.42,3.4 18.16,3.5L17.5,3.89L17.05,2.72C17.32,2.5 17.64,2.33 18.03,2.19C18.42,2.05 18.85,2 19.32,2C20.1,2 20.7,2.2 21.1,2.61C21.5,3 21.72,3.54 21.72,4.18C21.71,4.74 21.53,5.26 21.18,5.73C20.84,6.21 20.42,6.66 19.91,7.09L19.27,7.61V7.63H21.85V9Z" /></svg>'
                            }
                        ]
                    },
                    {
                        title: 'Einzelstellenverweis',
                        type: 'toolbar',
                        context: 'blocks.annotation',
                        entries: [
                            {
                                type: 'select-attr',
                                attr: 'target',
                                valueSource: 'annotations'
                            }
                        ]
                    },
                    {
                        title: 'Globalkommentarverweis Abschnitt (optional)',
                        type: 'toolbar',
                        context: 'blocks.annotationGlobal',
                        entries: [
                            {
                                type: 'text-attr',
                                attr: 'headingId',
                                dataType: 'text'
                            }
                        ]
                    },
                ],
                default: {
                    type: 'doc',
                    content: [
                        {
                            type: 'paragraph',
                            content: [
                                {
                                    type: 'pageLineRef',
                                    content: [
                                        {
                                            type: 'text',
                                            text: 'Seite & Zeile'
                                        }
                                    ],
                                },
                                {
                                    type: 'text',
                                    text: ' '
                                },
                                {
                                    type: 'wordRange',
                                    content: [
                                        {
                                            type: 'text',
                                            text: 'Textspanne'
                                        }
                                    ],
                                }
                            ]
                        },
                        {
                            type: 'paragraph',
                            content: [
                                {
                                    type: 'text',
                                    text: 'Neuer Einzelstellenkommentar'
                                }
                            ]
                        }
                    ]
                }
            }
        }
    });
})();

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (factory());
}(this, (function () { 'use strict';

    function unreachable(message = 'unreachable') {
        return new Error(message);
    }

    // import Logger from './logger';
    // let alreadyWarned = false;
    function debugAssert(test, msg) {
        // if (!alreadyWarned) {
        //   alreadyWarned = true;
        //   Logger.warn("Don't leave debug assertions on in public builds");
        // }
        if (!test) {
            throw new Error(msg || 'assertion failure');
        }
    }

    function fillNulls(count) {
        let arr = new Array(count);
        for (let i = 0; i < count; i++) {
            arr[i] = null;
        }
        return arr;
    }

    let GUID = 0;
    function initializeGuid(object) {
        return object._guid = ++GUID;
    }

    function dict() {
        return Object.create(null);
    }

    const EMPTY_ARRAY = Object.freeze([]);

    const CONSTANT = 0;
    const INITIAL = 1;
    const VOLATILE = NaN;
    class RevisionTag {
        validate(snapshot) {
            return this.value() === snapshot;
        }
    }
    RevisionTag.id = 0;
    const VALUE = [];
    const VALIDATE = [];
    class TagWrapper {
        constructor(type, inner) {
            this.type = type;
            this.inner = inner;
        }
        value() {
            let func = VALUE[this.type];
            return func(this.inner);
        }
        validate(snapshot) {
            let func = VALIDATE[this.type];
            return func(this.inner, snapshot);
        }
    }
    function register(Type) {
        let type = VALUE.length;
        VALUE.push(tag => tag.value());
        VALIDATE.push((tag, snapshot) => tag.validate(snapshot));
        Type.id = type;
    }
    ///
    // CONSTANT: 0
    VALUE.push(() => CONSTANT);
    VALIDATE.push((_tag, snapshot) => snapshot === CONSTANT);
    const CONSTANT_TAG = new TagWrapper(0, null);
    // VOLATILE: 1
    VALUE.push(() => VOLATILE);
    VALIDATE.push((_tag, snapshot) => snapshot === VOLATILE);
    const VOLATILE_TAG = new TagWrapper(1, null);
    // CURRENT: 2
    VALUE.push(() => $REVISION);
    VALIDATE.push((_tag, snapshot) => snapshot === $REVISION);
    const CURRENT_TAG = new TagWrapper(2, null);
    function isConst({ tag }) {
        return tag === CONSTANT_TAG;
    }
    function isConstTag(tag) {
        return tag === CONSTANT_TAG;
    }
    ///
    let $REVISION = INITIAL;
    class DirtyableTag extends RevisionTag {
        static create(revision = $REVISION) {
            return new TagWrapper(this.id, new DirtyableTag(revision));
        }
        constructor(revision = $REVISION) {
            super();
            this.revision = revision;
        }
        value() {
            return this.revision;
        }
        dirty() {
            this.revision = ++$REVISION;
        }
    }
    register(DirtyableTag);
    function combineTagged(tagged) {
        let optimized = [];
        for (let i = 0, l = tagged.length; i < l; i++) {
            let tag = tagged[i].tag;
            if (tag === VOLATILE_TAG) return VOLATILE_TAG;
            if (tag === CONSTANT_TAG) continue;
            optimized.push(tag);
        }
        return _combine(optimized);
    }
    function combineSlice(slice) {
        let optimized = [];
        let node = slice.head();
        while (node !== null) {
            let tag = node.tag;
            if (tag === VOLATILE_TAG) return VOLATILE_TAG;
            if (tag !== CONSTANT_TAG) optimized.push(tag);
            node = slice.nextNode(node);
        }
        return _combine(optimized);
    }
    function combine(tags) {
        let optimized = [];
        for (let i = 0, l = tags.length; i < l; i++) {
            let tag = tags[i];
            if (tag === VOLATILE_TAG) return VOLATILE_TAG;
            if (tag === CONSTANT_TAG) continue;
            optimized.push(tag);
        }
        return _combine(optimized);
    }
    function _combine(tags) {
        switch (tags.length) {
            case 0:
                return CONSTANT_TAG;
            case 1:
                return tags[0];
            case 2:
                return TagsPair.create(tags[0], tags[1]);
            default:
                return TagsCombinator.create(tags);
        }
    }
    class CachedTag extends RevisionTag {
        constructor() {
            super(...arguments);
            this.lastChecked = null;
            this.lastValue = null;
        }
        value() {
            let lastChecked = this.lastChecked,
                lastValue = this.lastValue;

            if (lastChecked !== $REVISION) {
                this.lastChecked = $REVISION;
                this.lastValue = lastValue = this.compute();
            }
            return this.lastValue;
        }
        invalidate() {
            this.lastChecked = null;
        }
    }
    class TagsPair extends CachedTag {
        static create(first, second) {
            return new TagWrapper(this.id, new TagsPair(first, second));
        }
        constructor(first, second) {
            super();
            this.first = first;
            this.second = second;
        }
        compute() {
            return Math.max(this.first.value(), this.second.value());
        }
    }
    register(TagsPair);
    class TagsCombinator extends CachedTag {
        static create(tags) {
            return new TagWrapper(this.id, new TagsCombinator(tags));
        }
        constructor(tags) {
            super();
            this.tags = tags;
        }
        compute() {
            let tags = this.tags;

            let max = -1;
            for (let i = 0; i < tags.length; i++) {
                let value = tags[i].value();
                max = Math.max(value, max);
            }
            return max;
        }
    }
    register(TagsCombinator);
    class UpdatableTag extends CachedTag {
        static create(tag) {
            return new TagWrapper(this.id, new UpdatableTag(tag));
        }
        constructor(tag) {
            super();
            this.tag = tag;
            this.lastUpdated = INITIAL;
        }
        compute() {
            return Math.max(this.lastUpdated, this.tag.value());
        }
        update(tag) {
            if (tag !== this.tag) {
                this.tag = tag;
                this.lastUpdated = $REVISION;
                this.invalidate();
            }
        }
    }
    register(UpdatableTag);
    class CachedReference {
        constructor() {
            this.lastRevision = null;
            this.lastValue = null;
        }
        value() {
            let tag = this.tag,
                lastRevision = this.lastRevision,
                lastValue = this.lastValue;

            if (lastRevision === null || !tag.validate(lastRevision)) {
                lastValue = this.lastValue = this.compute();
                this.lastRevision = tag.value();
            }
            return lastValue;
        }
        invalidate() {
            this.lastRevision = null;
        }
    }
    //////////
    class ReferenceCache {
        constructor(reference) {
            this.lastValue = null;
            this.lastRevision = null;
            this.initialized = false;
            this.tag = reference.tag;
            this.reference = reference;
        }
        peek() {
            if (!this.initialized) {
                return this.initialize();
            }
            return this.lastValue;
        }
        revalidate() {
            if (!this.initialized) {
                return this.initialize();
            }
            let reference = this.reference,
                lastRevision = this.lastRevision;

            let tag = reference.tag;
            if (tag.validate(lastRevision)) return NOT_MODIFIED;
            this.lastRevision = tag.value();
            let lastValue = this.lastValue;

            let value = reference.value();
            if (value === lastValue) return NOT_MODIFIED;
            this.lastValue = value;
            return value;
        }
        initialize() {
            let reference = this.reference;

            let value = this.lastValue = reference.value();
            this.lastRevision = reference.tag.value();
            this.initialized = true;
            return value;
        }
    }
    const NOT_MODIFIED = 'adb3b78e-3d22-4e4b-877a-6317c2c5c145';
    function isModified(value) {
        return value !== NOT_MODIFIED;
    }

    class ConstReference {
        constructor(inner) {
            this.inner = inner;
            this.tag = CONSTANT_TAG;
        }
        value() {
            return this.inner;
        }
    }

    // import Logger from './logger';

    function dict$1() {
        return Object.create(null);
    }

    class ListNode$1 {
        constructor(value) {
            this.next = null;
            this.prev = null;
            this.value = value;
        }
    }
    class LinkedList$1 {
        constructor() {
            this.clear();
        }
        head() {
            return this._head;
        }
        tail() {
            return this._tail;
        }
        clear() {
            this._head = this._tail = null;
        }
        toArray() {
            let out = [];
            this.forEachNode(n => out.push(n));
            return out;
        }
        nextNode(node) {
            return node.next;
        }
        forEachNode(callback) {
            let node = this._head;
            while (node !== null) {
                callback(node);
                node = node.next;
            }
        }
        insertBefore(node, reference = null) {
            if (reference === null) return this.append(node);
            if (reference.prev) reference.prev.next = node;else this._head = node;
            node.prev = reference.prev;
            node.next = reference;
            reference.prev = node;
            return node;
        }
        append(node) {
            let tail = this._tail;
            if (tail) {
                tail.next = node;
                node.prev = tail;
                node.next = null;
            } else {
                this._head = node;
            }
            return this._tail = node;
        }
        remove(node) {
            if (node.prev) node.prev.next = node.next;else this._head = node.next;
            if (node.next) node.next.prev = node.prev;else this._tail = node.prev;
            return node;
        }
    }

    const EMPTY_ARRAY$1 = Object.freeze([]);

    class ListItem extends ListNode$1 {
        constructor(iterable, result) {
            super(iterable.valueReferenceFor(result));
            this.retained = false;
            this.seen = false;
            this.key = result.key;
            this.iterable = iterable;
            this.memo = iterable.memoReferenceFor(result);
        }
        update(item) {
            this.retained = true;
            this.iterable.updateValueReference(this.value, item);
            this.iterable.updateMemoReference(this.memo, item);
        }
        shouldRemove() {
            return !this.retained;
        }
        reset() {
            this.retained = false;
            this.seen = false;
        }
    }
    class IterationArtifacts {
        constructor(iterable) {
            this.iterator = null;
            this.map = dict$1();
            this.list = new LinkedList$1();
            this.tag = iterable.tag;
            this.iterable = iterable;
        }
        isEmpty() {
            let iterator = this.iterator = this.iterable.iterate();
            return iterator.isEmpty();
        }
        iterate() {
            let iterator;
            if (this.iterator === null) {
                iterator = this.iterable.iterate();
            } else {
                iterator = this.iterator;
            }
            this.iterator = null;
            return iterator;
        }
        has(key) {
            return !!this.map[key];
        }
        get(key) {
            return this.map[key];
        }
        wasSeen(key) {
            let node = this.map[key];
            return node !== undefined && node.seen;
        }
        append(item) {
            let map = this.map,
                list = this.list,
                iterable = this.iterable;

            let node = map[item.key] = new ListItem(iterable, item);
            list.append(node);
            return node;
        }
        insertBefore(item, reference) {
            let map = this.map,
                list = this.list,
                iterable = this.iterable;

            let node = map[item.key] = new ListItem(iterable, item);
            node.retained = true;
            list.insertBefore(node, reference);
            return node;
        }
        move(item, reference) {
            let list = this.list;

            item.retained = true;
            list.remove(item);
            list.insertBefore(item, reference);
        }
        remove(item) {
            let list = this.list;

            list.remove(item);
            delete this.map[item.key];
        }
        nextNode(item) {
            return this.list.nextNode(item);
        }
        head() {
            return this.list.head();
        }
    }
    class ReferenceIterator {
        // if anyone needs to construct this object with something other than
        // an iterable, let @wycats know.
        constructor(iterable) {
            this.iterator = null;
            let artifacts = new IterationArtifacts(iterable);
            this.artifacts = artifacts;
        }
        next() {
            let artifacts = this.artifacts;

            let iterator = this.iterator = this.iterator || artifacts.iterate();
            let item = iterator.next();
            if (item === null) return null;
            return artifacts.append(item);
        }
    }
    var Phase;
    (function (Phase) {
        Phase[Phase["Append"] = 0] = "Append";
        Phase[Phase["Prune"] = 1] = "Prune";
        Phase[Phase["Done"] = 2] = "Done";
    })(Phase || (Phase = {}));
    class IteratorSynchronizer {
        constructor({ target, artifacts }) {
            this.target = target;
            this.artifacts = artifacts;
            this.iterator = artifacts.iterate();
            this.current = artifacts.head();
        }
        sync() {
            let phase = Phase.Append;
            while (true) {
                switch (phase) {
                    case Phase.Append:
                        phase = this.nextAppend();
                        break;
                    case Phase.Prune:
                        phase = this.nextPrune();
                        break;
                    case Phase.Done:
                        this.nextDone();
                        return;
                }
            }
        }
        advanceToKey(key) {
            let current = this.current,
                artifacts = this.artifacts;

            let seek = current;
            while (seek !== null && seek.key !== key) {
                seek.seen = true;
                seek = artifacts.nextNode(seek);
            }
            if (seek !== null) {
                this.current = artifacts.nextNode(seek);
            }
        }
        nextAppend() {
            let iterator = this.iterator,
                current = this.current,
                artifacts = this.artifacts;

            let item = iterator.next();
            if (item === null) {
                return this.startPrune();
            }
            let key = item.key;

            if (current !== null && current.key === key) {
                this.nextRetain(item);
            } else if (artifacts.has(key)) {
                this.nextMove(item);
            } else {
                this.nextInsert(item);
            }
            return Phase.Append;
        }
        nextRetain(item) {
            let artifacts = this.artifacts,
                current = this.current;

            current = current;
            current.update(item);
            this.current = artifacts.nextNode(current);
            this.target.retain(item.key, current.value, current.memo);
        }
        nextMove(item) {
            let current = this.current,
                artifacts = this.artifacts,
                target = this.target;
            let key = item.key;

            let found = artifacts.get(item.key);
            found.update(item);
            if (artifacts.wasSeen(item.key)) {
                artifacts.move(found, current);
                target.move(found.key, found.value, found.memo, current ? current.key : null);
            } else {
                this.advanceToKey(key);
            }
        }
        nextInsert(item) {
            let artifacts = this.artifacts,
                target = this.target,
                current = this.current;

            let node = artifacts.insertBefore(item, current);
            target.insert(node.key, node.value, node.memo, current ? current.key : null);
        }
        startPrune() {
            this.current = this.artifacts.head();
            return Phase.Prune;
        }
        nextPrune() {
            let artifacts = this.artifacts,
                target = this.target,
                current = this.current;

            if (current === null) {
                return Phase.Done;
            }
            let node = current;
            this.current = artifacts.nextNode(node);
            if (node.shouldRemove()) {
                artifacts.remove(node);
                target.delete(node.key);
            } else {
                node.reset();
            }
            return Phase.Prune;
        }
        nextDone() {
            this.target.done();
        }
    }

    /**
     * An object that that tracks @tracked properties that were consumed.
     */
    class Tracker {
        constructor() {
            this.tags = new Set();
        }
        add(tag) {
            this.tags.add(tag);
        }
        combine() {
            let tags = this.tags;

            if (tags.size === 0) return CONSTANT_TAG;
            return combine([...tags]);
        }
    }
    function tracked(...args) {
        let target = args[0],
            key = args[1],
            descriptor = args[2];

        {
            if (typeof target === 'string') {
                throw new Error(`ERROR: You attempted to use @tracked with ${args.length > 1 ? 'arguments' : 'an argument'} ( @tracked(${args.map(d => `'${d}'`).join(', ')}) ), which is no longer necessary nor supported. Dependencies are now automatically tracked, so you can just use ${'`@tracked`'}.`);
            }
            if (target === undefined) {
                throw new Error('ERROR: You attempted to use @tracked(), which is no longer necessary nor supported. Remove the parentheses and you will be good to go!');
            }
        }
        if (descriptor) {
            return descriptorForTrackedComputedProperty(target, key, descriptor);
        } else {
            installTrackedProperty(target, key);
        }
    }
    /**
     * Whenever a tracked computed property is entered, the current tracker is
     * saved off and a new tracker is replaced.
     *
     * Any tracked properties consumed are added to the current tracker.
     *
     * When a tracked computed property is exited, the tracker's tags are
     * combined and added to the parent tracker.
     *
     * The consequence is that each tracked computed property has a tag
     * that corresponds to the tracked properties consumed inside of
     * itself, including child tracked computed properties.
     */
    let CURRENT_TRACKER = null;
    function descriptorForTrackedComputedProperty(target, key, descriptor) {
        let meta = metaFor(target);
        meta.trackedProperties[key] = true;
        meta.trackedComputedProperties[key] = true;
        let get = descriptor.get;
        let set = descriptor.set;
        function getter() {
            // Swap the parent tracker for a new tracker
            let old = CURRENT_TRACKER;
            let tracker = CURRENT_TRACKER = new Tracker();
            // Call the getter
            let ret = get.call(this);
            // Swap back the parent tracker
            CURRENT_TRACKER = old;
            // Combine the tags in the new tracker
            let tag = tracker.combine();
            if (CURRENT_TRACKER) CURRENT_TRACKER.add(tag);
            // Update the UpdatableTag for this property with the tag for all of the
            // consumed dependencies.
            metaFor(this).updatableTagFor(key).inner.update(tag);
            return ret;
        }
        function setter() {
            EPOCH.inner.dirty();
            // Mark the UpdatableTag for this property with the current tag.
            metaFor(this).updatableTagFor(key).inner.update(DirtyableTag.create());
            set.apply(this, arguments);
        }
        return {
            enumerable: true,
            configurable: false,
            get: getter,
            set: set ? setter : undefined
        };
    }
    function trackedGet(obj, key) {
        if (CURRENT_TRACKER) CURRENT_TRACKER.add(metaFor(obj).updatableTagFor(key));
    }
    /**
      Installs a getter/setter for change tracking. The accessor
      acts just like a normal property, but it triggers the `propertyDidChange`
      hook when written to.

      Values are saved on the object using a "shadow key," or a symbol based on the
      tracked property name. Sets write the value to the shadow key, and gets read
      from it.
     */
    function installTrackedProperty(target, key) {
        let shadowKey = Symbol(key);
        let meta = metaFor(target);
        meta.trackedProperties[key] = true;
        Object.defineProperty(target, key, {
            configurable: true,
            get() {
                trackedGet(this, key);
                return this[shadowKey];
            },
            set(newValue) {
                // Bump the global revision counter
                EPOCH.inner.dirty();
                // Mark the UpdatableTag for this property with the current tag.
                metaFor(this).updatableTagFor(key).inner.update(DirtyableTag.create());
                this[shadowKey] = newValue;
                propertyDidChange();
            }
        });
    }
    /**
     * Stores bookkeeping information about tracked properties on the target object
     * and includes helper methods for manipulating and retrieving that data.
     *
     * Computed properties (i.e., tracked getters/setters) deserve some explanation.
     * A computed property is invalidated when either it is set, or one of its
     * dependencies is invalidated. Therefore, we store two tags for each computed
     * property:
     *
     * 1. The dirtyable tag that we invalidate when the setter is invoked.
     * 2. A union tag (tag combinator) of the dirtyable tag and all of the computed
     *    property's dependencies' tags, used by Glimmer to determine "does this
     *    computed property need to be recomputed?"
     */
    class Meta {
        constructor(parent) {
            this.tags = dict();
            this.computedPropertyTags = dict();
            this.trackedProperties = parent ? Object.create(parent.trackedProperties) : dict();
            this.trackedComputedProperties = parent ? Object.create(parent.trackedComputedProperties) : dict();
        }
        /**
         * The tag representing whether the given property should be recomputed. Used
         * by e.g. Glimmer VM to detect when a property should be re-rendered. Think
         * of this as the "public-facing" tag.
         *
         * For static tracked properties, this is a single UpdatableTag. For computed
         * properties, it is a combinator of the property's UpdatableTag as well as
         * all of its dependencies' tags.
         */
        tagFor(key) {
            let tag = this.tags[key];
            if (tag) {
                return tag;
            }
            if (this.trackedComputedProperties[key]) {
                return this.tags[key] = this.updatableTagFor(key);
            }
            return this.tags[key] = DirtyableTag.create();
        }
        /**
         * The tag used internally to invalidate when a tracked property is set. For
         * static properties, this is the same UpdatableTag returned from `tagFor`.
         * For computed properties, it is the UpdatableTag used as one of the tags in
         * the tag combinator of the CP and its dependencies.
        */
        updatableTagFor(key) {
            let isComputed = this.trackedComputedProperties[key];
            let tag;
            if (isComputed) {
                // The key is for a computed property.
                tag = this.computedPropertyTags[key];
                if (tag) {
                    return tag;
                }
                return this.computedPropertyTags[key] = UpdatableTag.create(CONSTANT_TAG);
            } else {
                // The key is for a static property.
                tag = this.tags[key];
                if (tag) {
                    return tag;
                }
                return this.tags[key] = UpdatableTag.create(CONSTANT_TAG);
            }
        }
    }
    /**
     *  A shared WeakMap for tracking an object's Meta instance, so any metadata
     *  will be garbage collected automatically with the associated object.
    */
    const META_MAP = new WeakMap();
    /**
     * Returns the Meta instance for an object. If no existing Meta is found,
     * creates a new instance and returns it. An object's Meta inherits from any
     * existing Meta in its prototype chain.
     */
    function metaFor(obj) {
        // Return the Meta for this object if we already have it.
        let meta = META_MAP.get(obj);
        if (meta) {
            return meta;
        }
        // Otherwise, we need to walk the object's prototype chain to until we find a
        // parent Meta to inherit from. If we reach the end of the chain and have not
        // found a Meta, there is nothing to inherit.
        let protoMeta = findPrototypeMeta(obj);
        meta = new Meta(protoMeta);
        // Save the object's Meta and return it.
        META_MAP.set(obj, meta);
        return meta;
    }
    const getPrototypeOf = Object.getPrototypeOf;
    // Finds the nearest Meta instance in an object's prototype chain. Returns null
    // if the end of the prototype chain is reached without finding a Meta.
    function findPrototypeMeta(obj) {
        let meta = null;
        let proto = obj;
        while (!meta) {
            proto = getPrototypeOf(proto);
            if (!proto) {
                return meta;
            }
            meta = META_MAP.get(proto);
        }
        return meta;
    }
    const EPOCH = DirtyableTag.create();
    let propertyDidChange = function propertyDidChange() {};
    function setPropertyDidChange(cb) {
        propertyDidChange = cb;
    }
    function hasTag(obj, key) {
        let meta = META_MAP.get(obj);
        if (!meta || !meta.trackedProperties[key]) {
            return false;
        }
        return true;
    }
    class UntrackedPropertyError extends Error {
        constructor(target, key, message) {
            super(message);
            this.target = target;
            this.key = key;
        }
        static for(obj, key) {
            return new UntrackedPropertyError(obj, key, `The property '${key}' on ${obj} was changed after being rendered. If you want to change a property used in a template after the component has rendered, mark the property as a tracked property with the @tracked decorator.`);
        }
    }
    function defaultErrorThrower(obj, key) {
        throw UntrackedPropertyError.for(obj, key);
    }
    function tagForProperty(obj, key, throwError = defaultErrorThrower) {
        if (typeof obj === "object" && obj) {
            if (true && !hasTag(obj, key)) {
                installDevModeErrorInterceptor(obj, key, throwError);
            }
            let meta = metaFor(obj);
            return meta.tagFor(key);
        } else {
            return CONSTANT_TAG;
        }
    }
    /**
     * In development mode only, we install an ad hoc setter on properties where a
     * tag is requested (i.e., it was used in a template) without being tracked. In
     * cases where the property is set, we raise an error.
     */
    function installDevModeErrorInterceptor(obj, key, throwError) {
        let target = obj;
        let descriptor = null;
        // Find the descriptor for the current property. We may need to walk the
        // prototype chain to do so. If the property is undefined, we may never get a
        // descriptor here.
        let hasOwnDescriptor = true;
        while (target) {
            descriptor = Object.getOwnPropertyDescriptor(target, key);
            if (descriptor) {
                break;
            }
            hasOwnDescriptor = false;
            target = Object.getPrototypeOf(target);
        }
        // If possible, define a property descriptor that passes through the current
        // value on reads but throws an exception on writes.
        if (descriptor) {
            var _descriptor = descriptor;
            let get = _descriptor.get,
                value = _descriptor.value;

            if (descriptor.configurable || !hasOwnDescriptor) {
                Object.defineProperty(obj, key, {
                    configurable: descriptor.configurable,
                    enumerable: descriptor.enumerable,
                    get() {
                        if (get) {
                            return get.call(this);
                        } else {
                            return value;
                        }
                    },
                    set() {
                        throwError(this, key);
                    }
                });
            }
        } else {
            Object.defineProperty(obj, key, {
                set() {
                    throwError(this, key);
                }
            });
        }
    }

    /**
     * The `Component` class defines an encapsulated UI element that is rendered to
     * the DOM. A component is made up of a template and, optionally, this component
     * object.
     *
     * ## Defining a Component
     *
     * To define a component, subclass `Component` and add your own properties,
     * methods and lifecycle hooks:
     *
     * ```ts
     * import Component from '@glimmer/component';
     *
     * export default class extends Component {
     * }
     * ```
     *
     * ## Lifecycle Hooks
     *
     * Lifecycle hooks allow you to respond to changes to a component, such as when
     * it gets created, rendered, updated or destroyed. To add a lifecycle hook to a
     * component, implement the hook as a method on your component subclass.
     *
     * For example, to be notified when Glimmer has rendered your component so you
     * can attach a legacy jQuery plugin, implement the `didInsertElement()` method:
     *
     * ```ts
     * import Component from '@glimmer/component';
     *
     * export default class extends Component {
     *   didInsertElement() {
     *     $(this.element).pickadate();
     *   }
     * }
     * ```
     *
     * ## Data for Templates
     *
     * `Component`s have two different kinds of data, or state, that can be
     * displayed in templates:
     *
     * 1. Arguments
     * 2. Properties
     *
     * Arguments are data that is passed in to a component from its parent
     * component. For example, if I have a `UserGreeting` component, I can pass it
     * a name and greeting to use:
     *
     * ```hbs
     * <UserGreeting @name="Ricardo" @greeting="Olá" />
     * ```
     *
     * Inside my `UserGreeting` template, I can access the `@name` and `@greeting`
     * arguments that I've been given:
     *
     * ```hbs
     * {{@greeting}}, {{@name}}!
     * ```
     *
     * Arguments are also available inside my component:
     *
     * ```ts
     * console.log(this.args.greeting); // prints "Olá"
     * ```
     *
     * Properties, on the other hand, are internal to the component and declared in
     * the class. You can use properties to store data that you want to show in the
     * template, or pass to another component as an argument.
     *
     * ```ts
     * import Component from '@glimmer/component';
     *
     * export default class extends Component {
     *   user = {
     *     name: 'Robbie'
     *   }
     * }
     * ```
     *
     * In the above example, we've defined a component with a `user` property that
     * contains an object with its own `name` property.
     *
     * We can render that property in our template:
     *
     * ```hbs
     * Hello, {{user.name}}!
     * ```
     *
     * We can also take that property and pass it as an argument to the
     * `UserGreeting` component we defined above:
     *
     * ```hbs
     * <UserGreeting @greeting="Hello" @name={{user.name}} />
     * ```
     *
     * ## Arguments vs. Properties
     *
     * Remember, arguments are data that was given to your component by its parent
     * component, and properties are data your component has defined for itself.
     *
     * You can tell the difference between arguments and properties in templates
     * because arguments always start with an `@` sign (think "A is for arguments"):
     *
     * ```hbs
     * {{@firstName}}
     * ```
     *
     * We know that `@firstName` came from the parent component, not the current
     * component, because it starts with `@` and is therefore an argument.
     *
     * On the other hand, if we see:
     *
     * ```hbs
     * {{name}}
     * ```
     *
     * We know that `name` is a property on the component. If we want to know where
     * the data is coming from, we can go look at our component class to find out.
     *
     * Inside the component itself, arguments always show up inside the component's
     * `args` property. For example, if `{{@firstName}}` is `Tom` in the template,
     * inside the component `this.args.firstName` would also be `Tom`.
     */
    class Component {
      /**
       * Constructs a new component and assigns itself the passed properties. You
       * should not construct new components yourself. Instead, Glimmer will
       * instantiate new components automatically as it renders.
       *
       * @param options
       */
      constructor(options) {
        /**
         * Development-mode only name of the component, useful for debugging.
         */
        this.debugName = null;
        /** @private
         * Slot on the component to save Arguments object passed to the `args` setter.
         */
        this.__args__ = null;
        Object.assign(this, options);
      }
      /**
       * The element corresponding to the main element of the component's template.
       * The main element is the element in the template that has `...attributes` set on it:
       *
       * ```hbs
       * <h1>Modal</h1>
       * <div class="contents" ...attributes>
       *   {{yield}}
       * </div>
       * ```
       *
       * In this example, `this.element` would be the `div` with the class `contents`.
       *
       * You should not try to access this property until after the component's `didInsertElement()`
       * lifecycle hook is called.
       */
      get element() {
        let bounds = this.bounds;

        debugAssert(bounds && bounds.firstNode === bounds.lastNode, `The 'element' property can only be accessed on components that contain a single root element in their template. Try using 'bounds' instead to access the first and last nodes.`);
        return bounds.firstNode;
      }
      /**
       * Named arguments passed to the component from its parent component.
       * They can be accessed in JavaScript via `this.args.argumentName` and in the template via `@argumentName`.
       *
       * Say you have the following component, which will have two `args`, `firstName` and `lastName`:
       *
       * ```hbs
       * <my-component @firstName="Arthur" @lastName="Dent" />
       * ```
       *
       * If you needed to calculate `fullName` by combining both of them, you would do:
       *
       * ```ts
       * didInsertElement() {
       *   console.log(`Hi, my full name is ${this.args.firstName} ${this.args.lastName}`);
       * }
       * ```
       *
       * While in the template you could do:
       *
       * ```hbs
       * <p>Welcome, {{@firstName}} {{@lastName}}!</p>
       * ```
       *
       */
      get args() {
        trackedGet(this, 'args');
        return this.__args__;
      }
      set args(args) {
        this.__args__ = args;
        metaFor(this).updatableTagFor("args").inner.update(CURRENT_TAG);
      }
      static create(injections) {
        return new this(injections);
      }
      /**
       * Called when the component has been inserted into the DOM.
       * Override this function to do any set up that requires an element in the document body.
       */
      didInsertElement() {}
      /**
       * Called when the component has updated and rerendered itself.
       * Called only during a rerender, not during an initial render.
       */
      didUpdate() {}
      /**
       * Called before the component has been removed from the DOM.
       */
      willDestroy() {}
      destroy() {
        this.willDestroy();
      }
      toString() {
        return `${this.debugName} component`;
      }
    }

    const CAPABILITIES = {
        attributeHook: true,
        createArgs: true,
        createCaller: false,
        createInstance: true,
        dynamicLayout: false,
        dynamicScope: false,
        dynamicTag: true,
        elementHook: true,
        prepareArgs: false,
        updateHook: true
    };

    class ComponentDefinition {
        constructor(name, manager, ComponentClass, handle) {
            this.name = name;
            this.manager = manager;
            this.ComponentClass = ComponentClass;
            this.handle = handle;
            this.state = {
                name,
                capabilities: CAPABILITIES,
                ComponentClass,
                handle
            };
        }
        toJSON() {
            return { GlimmerDebug: `<component-definition name="${this.name}">` };
        }
    }

    /**
     * Contains the first and last DOM nodes in a component's rendered
     * template. These nodes can be used to traverse the section of DOM
     * that belongs to a particular component.
     *
     * Note that these nodes *can* change over the lifetime of a component
     * if the beginning or ending of the template is dynamic.
     */
    class Bounds {
        constructor(_bounds) {
            this._bounds = _bounds;
        }
        get firstNode() {
            return this._bounds.firstNode();
        }
        get lastNode() {
            return this._bounds.lastNode();
        }
    }

    // these import bindings will be stripped from build

    class AppendOpcodes {
        constructor() {
            this.evaluateOpcode = fillNulls(98 /* Size */).slice();
        }
        add(name, evaluate, kind = 'syscall') {
            this.evaluateOpcode[name] = { syscall: kind === 'syscall', evaluate };
        }
        debugBefore(vm, opcode, type) {
            
            let sp;
            let state;

            return { sp: sp, state };
        }
        debugAfter(vm, opcode, type, pre) {
            let expectedChange;
            let sp = pre.sp,
                state = pre.state;

            let metadata = null;
            if (metadata !== null) {
                if (typeof metadata.stackChange === 'number') {
                    expectedChange = metadata.stackChange;
                } else {
                    expectedChange = metadata.stackChange({ opcode, constants: vm.constants, state });
                    if (isNaN(expectedChange)) throw unreachable();
                }
            }
            
        }
        evaluate(vm, opcode, type) {
            let operation = this.evaluateOpcode[type];
            if (operation.syscall) {

                operation.evaluate(vm, opcode);
            } else {

                operation.evaluate(vm.inner, opcode);
            }
        }
    }
    const APPEND_OPCODES = new AppendOpcodes();
    class AbstractOpcode {
        constructor() {
            initializeGuid(this);
        }
    }
    class UpdatingOpcode extends AbstractOpcode {
        constructor() {
            super(...arguments);
            this.next = null;
            this.prev = null;
        }
    }

    /**
     * Registers
     *
     * For the most part, these follows MIPS naming conventions, however the
     * register numbers are different.
     */
    var Register;
    (function (Register) {
        // $0 or $pc (program counter): pointer into `program` for the next insturction; -1 means exit
        Register[Register["pc"] = 0] = "pc";
        // $1 or $ra (return address): pointer into `program` for the return
        Register[Register["ra"] = 1] = "ra";
        // $2 or $fp (frame pointer): pointer into the `evalStack` for the base of the stack
        Register[Register["fp"] = 2] = "fp";
        // $3 or $sp (stack pointer): pointer into the `evalStack` for the top of the stack
        Register[Register["sp"] = 3] = "sp";
        // $4-$5 or $s0-$s1 (saved): callee saved general-purpose registers
        Register[Register["s0"] = 4] = "s0";
        Register[Register["s1"] = 5] = "s1";
        // $6-$7 or $t0-$t1 (temporaries): caller saved general-purpose registers
        Register[Register["t0"] = 6] = "t0";
        Register[Register["t1"] = 7] = "t1";
        // $8 or $v0 (return value)
        Register[Register["v0"] = 8] = "v0";
    })(Register || (Register = {}));

    class PrimitiveReference extends ConstReference {
        constructor(value) {
            super(value);
        }
        static create(value) {
            if (value === undefined) {
                return UNDEFINED_REFERENCE;
            } else if (value === null) {
                return NULL_REFERENCE;
            } else if (value === true) {
                return TRUE_REFERENCE;
            } else if (value === false) {
                return FALSE_REFERENCE;
            } else if (typeof value === 'number') {
                return new ValueReference(value);
            } else {
                return new StringReference(value);
            }
        }
        get(_key) {
            return UNDEFINED_REFERENCE;
        }
    }
    class StringReference extends PrimitiveReference {
        constructor() {
            super(...arguments);
            this.lengthReference = null;
        }
        get(key) {
            if (key === 'length') {
                let lengthReference = this.lengthReference;

                if (lengthReference === null) {
                    lengthReference = this.lengthReference = new ValueReference(this.inner.length);
                }
                return lengthReference;
            } else {
                return super.get(key);
            }
        }
    }
    class ValueReference extends PrimitiveReference {
        constructor(value) {
            super(value);
        }
    }
    const UNDEFINED_REFERENCE = new ValueReference(undefined);
    const NULL_REFERENCE = new ValueReference(null);
    const TRUE_REFERENCE = new ValueReference(true);
    const FALSE_REFERENCE = new ValueReference(false);
    class ConditionalReference {
        constructor(inner) {
            this.inner = inner;
            this.tag = inner.tag;
        }
        value() {
            return this.toBool(this.inner.value());
        }
        toBool(value) {
            return !!value;
        }
    }

    class ConcatReference extends CachedReference {
        constructor(parts) {
            super();
            this.parts = parts;
            this.tag = combineTagged(parts);
        }
        compute() {
            let parts = new Array();
            for (let i = 0; i < this.parts.length; i++) {
                let value = this.parts[i].value();
                if (value !== null && value !== undefined) {
                    parts[i] = castToString(value);
                }
            }
            if (parts.length > 0) {
                return parts.join('');
            }
            return null;
        }
    }
    function castToString(value) {
        if (typeof value.toString !== 'function') {
            return '';
        }
        return String(value);
    }

    APPEND_OPCODES.add(1 /* Helper */, (vm, { op1: handle }) => {
        let stack = vm.stack;
        let helper = vm.constants.resolveHandle(handle);
        let args = stack.pop();
        let value = helper(vm, args);
        vm.loadValue(Register.v0, value);
    });
    APPEND_OPCODES.add(6 /* GetVariable */, (vm, { op1: symbol }) => {
        let expr = vm.referenceForSymbol(symbol);
        vm.stack.push(expr);
    });
    APPEND_OPCODES.add(4 /* SetVariable */, (vm, { op1: symbol }) => {
        let expr = vm.stack.pop();
        vm.scope().bindSymbol(symbol, expr);
    });
    APPEND_OPCODES.add(5 /* SetBlock */, (vm, { op1: symbol }) => {
        let handle = vm.stack.pop();
        let scope = vm.stack.pop(); // FIXME(mmun): shouldn't need to cast this
        let table = vm.stack.pop();
        let block = table ? [handle, scope, table] : null;
        vm.scope().bindBlock(symbol, block);
    });
    APPEND_OPCODES.add(96 /* ResolveMaybeLocal */, (vm, { op1: _name }) => {
        let name = vm.constants.getString(_name);
        let locals = vm.scope().getPartialMap();
        let ref = locals[name];
        if (ref === undefined) {
            ref = vm.getSelf().get(name);
        }
        vm.stack.push(ref);
    });
    APPEND_OPCODES.add(20 /* RootScope */, (vm, { op1: symbols, op2: bindCallerScope }) => {
        vm.pushRootScope(symbols, !!bindCallerScope);
    });
    APPEND_OPCODES.add(7 /* GetProperty */, (vm, { op1: _key }) => {
        let key = vm.constants.getString(_key);
        let expr = vm.stack.pop();
        vm.stack.push(expr.get(key));
    });
    APPEND_OPCODES.add(8 /* GetBlock */, (vm, { op1: _block }) => {
        let stack = vm.stack;

        let block = vm.scope().getBlock(_block);
        if (block) {
            stack.push(block[2]);
            stack.push(block[1]);
            stack.push(block[0]);
        } else {
            stack.push(null);
            stack.push(null);
            stack.push(null);
        }
    });
    APPEND_OPCODES.add(9 /* HasBlock */, (vm, { op1: _block }) => {
        let hasBlock = !!vm.scope().getBlock(_block);
        vm.stack.push(hasBlock ? TRUE_REFERENCE : FALSE_REFERENCE);
    });
    APPEND_OPCODES.add(10 /* HasBlockParams */, vm => {
        // FIXME(mmun): should only need to push the symbol table
        let block = vm.stack.pop();
        let scope = vm.stack.pop();

        let table = vm.stack.pop();

        let hasBlockParams = table && table.parameters.length;
        vm.stack.push(hasBlockParams ? TRUE_REFERENCE : FALSE_REFERENCE);
    });
    APPEND_OPCODES.add(11 /* Concat */, (vm, { op1: count }) => {
        let out = new Array(count);
        for (let i = count; i > 0; i--) {
            let offset = i - 1;
            out[offset] = vm.stack.pop();
        }
        vm.stack.push(new ConcatReference(out));
    });

    const CURRIED_COMPONENT_DEFINITION_BRAND = 'CURRIED COMPONENT DEFINITION [id=6f00feb9-a0ef-4547-99ea-ac328f80acea]';
    function isCurriedComponentDefinition(definition) {
        return !!(definition && definition[CURRIED_COMPONENT_DEFINITION_BRAND]);
    }
    function isComponentDefinition(definition) {
        return definition && definition[CURRIED_COMPONENT_DEFINITION_BRAND];
    }
    class CurriedComponentDefinition {
        /** @internal */
        constructor(inner, args) {
            this.inner = inner;
            this.args = args;
            this[CURRIED_COMPONENT_DEFINITION_BRAND] = true;
        }
        unwrap(args) {
            args.realloc(this.offset);
            let definition = this;
            while (true) {
                var _definition = definition;
                let curriedArgs = _definition.args,
                    inner = _definition.inner;

                if (curriedArgs) {
                    args.positional.prepend(curriedArgs.positional);
                    args.named.merge(curriedArgs.named);
                }
                if (!isCurriedComponentDefinition(inner)) {
                    return inner;
                }
                definition = inner;
            }
        }
        /** @internal */
        get offset() {
            let inner = this.inner,
                args = this.args;

            let length = args ? args.positional.length : 0;
            return isCurriedComponentDefinition(inner) ? length + inner.offset : length;
        }
    }

    function normalizeStringValue(value) {
        if (isEmpty(value)) {
            return '';
        }
        return String(value);
    }
    function shouldCoerce(value) {
        return isString(value) || isEmpty(value) || typeof value === 'boolean' || typeof value === 'number';
    }
    function isEmpty(value) {
        return value === null || value === undefined || typeof value.toString !== 'function';
    }
    function isSafeString(value) {
        return typeof value === 'object' && value !== null && typeof value.toHTML === 'function';
    }
    function isNode(value) {
        return typeof value === 'object' && value !== null && typeof value.nodeType === 'number';
    }
    function isFragment(value) {
        return isNode(value) && value.nodeType === 11;
    }
    function isString(value) {
        return typeof value === 'string';
    }

    class DynamicTextContent extends UpdatingOpcode {
        constructor(node, reference, lastValue) {
            super();
            this.node = node;
            this.reference = reference;
            this.lastValue = lastValue;
            this.type = 'dynamic-text';
            this.tag = reference.tag;
            this.lastRevision = this.tag.value();
        }
        evaluate() {
            let reference = this.reference,
                tag = this.tag;

            if (!tag.validate(this.lastRevision)) {
                this.lastRevision = tag.value();
                this.update(reference.value());
            }
        }
        update(value) {
            let lastValue = this.lastValue;

            if (value === lastValue) return;
            let normalized;
            if (isEmpty(value)) {
                normalized = '';
            } else if (isString(value)) {
                normalized = value;
            } else {
                normalized = String(value);
            }
            if (normalized !== lastValue) {
                let textNode = this.node;
                textNode.nodeValue = this.lastValue = normalized;
            }
        }
    }

    class IsCurriedComponentDefinitionReference extends ConditionalReference {
        static create(inner) {
            return new IsCurriedComponentDefinitionReference(inner);
        }
        toBool(value) {
            return isCurriedComponentDefinition(value);
        }
    }
    class ContentTypeReference {
        constructor(inner) {
            this.inner = inner;
            this.tag = inner.tag;
        }
        value() {
            let value = this.inner.value();
            if (shouldCoerce(value)) {
                return 1 /* String */;
            } else if (isComponentDefinition(value)) {
                return 0 /* Component */;
            } else if (isSafeString(value)) {
                return 3 /* SafeString */;
            } else if (isFragment(value)) {
                return 4 /* Fragment */;
            } else if (isNode(value)) {
                return 5 /* Node */;
            } else {
                    return 1 /* String */;
                }
        }
    }
    APPEND_OPCODES.add(28 /* AppendHTML */, vm => {
        let reference = vm.stack.pop();
        let rawValue = reference.value();
        let value = isEmpty(rawValue) ? '' : String(rawValue);
        vm.elements().appendDynamicHTML(value);
    });
    APPEND_OPCODES.add(29 /* AppendSafeHTML */, vm => {
        let reference = vm.stack.pop();
        let rawValue = reference.value().toHTML();
        let value = isEmpty(rawValue) ? '' : rawValue;
        vm.elements().appendDynamicHTML(value);
    });
    APPEND_OPCODES.add(32 /* AppendText */, vm => {
        let reference = vm.stack.pop();
        let rawValue = reference.value();
        let value = isEmpty(rawValue) ? '' : String(rawValue);
        let node = vm.elements().appendDynamicText(value);
        if (!isConst(reference)) {
            vm.updateWith(new DynamicTextContent(node, reference, value));
        }
    });
    APPEND_OPCODES.add(30 /* AppendDocumentFragment */, vm => {
        let reference = vm.stack.pop();
        let value = reference.value();
        vm.elements().appendDynamicFragment(value);
    });
    APPEND_OPCODES.add(31 /* AppendNode */, vm => {
        let reference = vm.stack.pop();
        let value = reference.value();
        vm.elements().appendDynamicNode(value);
    });

    APPEND_OPCODES.add(22 /* ChildScope */, vm => vm.pushChildScope());
    APPEND_OPCODES.add(23 /* PopScope */, vm => vm.popScope());
    APPEND_OPCODES.add(44 /* PushDynamicScope */, vm => vm.pushDynamicScope());
    APPEND_OPCODES.add(45 /* PopDynamicScope */, vm => vm.popDynamicScope());
    APPEND_OPCODES.add(12 /* Constant */, (vm, { op1: other }) => {
        vm.stack.push(vm.constants.getOther(other));
    });
    APPEND_OPCODES.add(13 /* Primitive */, (vm, { op1: primitive }) => {
        let stack = vm.stack;
        let flag = primitive & 7; // 111
        let value = primitive >> 3;
        switch (flag) {
            case 0 /* NUMBER */:
                stack.push(value);
                break;
            case 1 /* FLOAT */:
                stack.push(vm.constants.getNumber(value));
                break;
            case 2 /* STRING */:
                stack.push(vm.constants.getString(value));
                break;
            case 3 /* BOOLEAN_OR_VOID */:
                stack.pushEncodedImmediate(primitive);
                break;
            case 4 /* NEGATIVE */:
                stack.push(vm.constants.getNumber(value));
                break;
            case 5 /* BIG_NUM */:
                stack.push(vm.constants.getNumber(value));
                break;
        }
    });
    APPEND_OPCODES.add(14 /* PrimitiveReference */, vm => {
        let stack = vm.stack;
        stack.push(PrimitiveReference.create(stack.pop()));
    });
    APPEND_OPCODES.add(15 /* ReifyU32 */, vm => {
        let stack = vm.stack;
        stack.push(stack.peek().value());
    });
    APPEND_OPCODES.add(16 /* Dup */, (vm, { op1: register, op2: offset }) => {
        let position = vm.fetchValue(register) - offset;
        vm.stack.dup(position);
    });
    APPEND_OPCODES.add(17 /* Pop */, (vm, { op1: count }) => {
        vm.stack.pop(count);
    });
    APPEND_OPCODES.add(18 /* Load */, (vm, { op1: register }) => {
        vm.load(register);
    });
    APPEND_OPCODES.add(19 /* Fetch */, (vm, { op1: register }) => {
        vm.fetch(register);
    });
    APPEND_OPCODES.add(43 /* BindDynamicScope */, (vm, { op1: _names }) => {
        let names = vm.constants.getArray(_names);
        vm.bindDynamicScope(names);
    });
    APPEND_OPCODES.add(61 /* Enter */, (vm, { op1: args }) => {
        vm.enter(args);
    });
    APPEND_OPCODES.add(62 /* Exit */, vm => {
        vm.exit();
    });
    APPEND_OPCODES.add(48 /* PushSymbolTable */, (vm, { op1: _table }) => {
        let stack = vm.stack;
        stack.push(vm.constants.getSerializable(_table));
    });
    APPEND_OPCODES.add(47 /* PushBlockScope */, vm => {
        let stack = vm.stack;
        stack.push(vm.scope());
    });
    APPEND_OPCODES.add(46 /* CompileBlock */, vm => {
        let stack = vm.stack;
        let block = stack.pop();
        if (block) {
            stack.pushSmi(block.compile());
        } else {
            stack.pushNull();
        }
    });
    APPEND_OPCODES.add(51 /* InvokeYield */, vm => {
        let stack = vm.stack;

        let handle = stack.pop();
        let scope = stack.pop(); // FIXME(mmun): shouldn't need to cast this
        let table = stack.pop();

        let args = stack.pop();
        if (table === null) {
            // To balance the pop{Frame,Scope}
            vm.pushFrame();
            vm.pushScope(scope); // Could be null but it doesnt matter as it is immediatelly popped.
            return;
        }
        let invokingScope = scope;
        // If necessary, create a child scope
        {
            let locals = table.parameters;
            let localsCount = locals.length;
            if (localsCount > 0) {
                invokingScope = invokingScope.child();
                for (let i = 0; i < localsCount; i++) {
                    invokingScope.bindSymbol(locals[i], args.at(i));
                }
            }
        }
        vm.pushFrame();
        vm.pushScope(invokingScope);
        vm.call(handle);
    });
    APPEND_OPCODES.add(53 /* JumpIf */, (vm, { op1: target }) => {
        let reference = vm.stack.pop();
        if (isConst(reference)) {
            if (reference.value()) {
                vm.goto(target);
            }
        } else {
            let cache = new ReferenceCache(reference);
            if (cache.peek()) {
                vm.goto(target);
            }
            vm.updateWith(new Assert(cache));
        }
    });
    APPEND_OPCODES.add(54 /* JumpUnless */, (vm, { op1: target }) => {
        let reference = vm.stack.pop();
        if (isConst(reference)) {
            if (!reference.value()) {
                vm.goto(target);
            }
        } else {
            let cache = new ReferenceCache(reference);
            if (!cache.peek()) {
                vm.goto(target);
            }
            vm.updateWith(new Assert(cache));
        }
    });
    APPEND_OPCODES.add(55 /* JumpEq */, (vm, { op1: target, op2: comparison }) => {
        let other = vm.stack.peek();
        if (other === comparison) {
            vm.goto(target);
        }
    });
    APPEND_OPCODES.add(56 /* AssertSame */, vm => {
        let reference = vm.stack.peek();
        if (!isConst(reference)) {
            vm.updateWith(Assert.initialize(new ReferenceCache(reference)));
        }
    });
    APPEND_OPCODES.add(63 /* ToBoolean */, vm => {
        let env = vm.env,
            stack = vm.stack;

        stack.push(env.toConditionalReference(stack.pop()));
    });
    class Assert extends UpdatingOpcode {
        constructor(cache) {
            super();
            this.type = 'assert';
            this.tag = cache.tag;
            this.cache = cache;
        }
        static initialize(cache) {
            let assert = new Assert(cache);
            cache.peek();
            return assert;
        }
        evaluate(vm) {
            let cache = this.cache;

            if (isModified(cache.revalidate())) {
                vm.throw();
            }
        }
    }

    APPEND_OPCODES.add(26 /* Text */, (vm, { op1: text }) => {
        vm.elements().appendText(vm.constants.getString(text));
    });
    APPEND_OPCODES.add(27 /* Comment */, (vm, { op1: text }) => {
        vm.elements().appendComment(vm.constants.getString(text));
    });
    APPEND_OPCODES.add(33 /* OpenElement */, (vm, { op1: tag }) => {
        vm.elements().openElement(vm.constants.getString(tag));
    });
    APPEND_OPCODES.add(34 /* OpenDynamicElement */, vm => {
        let tagName = vm.stack.pop().value();
        vm.elements().openElement(tagName);
    });
    APPEND_OPCODES.add(41 /* PushRemoteElement */, vm => {
        let elementRef = vm.stack.pop();
        let nextSiblingRef = vm.stack.pop();
        let guidRef = vm.stack.pop();
        let element;
        let nextSibling;
        let guid = guidRef.value();
        if (isConst(elementRef)) {
            element = elementRef.value();
        } else {
            let cache = new ReferenceCache(elementRef);
            element = cache.peek();
            vm.updateWith(new Assert(cache));
        }
        if (isConst(nextSiblingRef)) {
            nextSibling = nextSiblingRef.value();
        } else {
            let cache = new ReferenceCache(nextSiblingRef);
            nextSibling = cache.peek();
            vm.updateWith(new Assert(cache));
        }
        vm.elements().pushRemoteElement(element, guid, nextSibling);
    });
    APPEND_OPCODES.add(42 /* PopRemoteElement */, vm => {
        vm.elements().popRemoteElement();
    });
    APPEND_OPCODES.add(38 /* FlushElement */, vm => {
        let operations = vm.fetchValue(Register.t0);
        if (operations) {
            operations.flush(vm);
            vm.loadValue(Register.t0, null);
        }
        vm.elements().flushElement();
    });
    APPEND_OPCODES.add(39 /* CloseElement */, vm => {
        vm.elements().closeElement();
    });
    APPEND_OPCODES.add(40 /* Modifier */, (vm, { op1: handle }) => {
        let manager = vm.constants.resolveHandle(handle);
        let stack = vm.stack;
        let args = stack.pop();

        var _vm$elements = vm.elements();

        let element = _vm$elements.constructing,
            updateOperations = _vm$elements.updateOperations;

        let dynamicScope = vm.dynamicScope();
        let modifier = manager.create(element, args, dynamicScope, updateOperations);
        vm.env.scheduleInstallModifier(modifier, manager);
        let destructor = manager.getDestructor(modifier);
        if (destructor) {
            vm.newDestroyable(destructor);
        }
        let tag = manager.getTag(modifier);
        if (!isConstTag(tag)) {
            vm.updateWith(new UpdateModifierOpcode(tag, manager, modifier));
        }
    });
    class UpdateModifierOpcode extends UpdatingOpcode {
        constructor(tag, manager, modifier) {
            super();
            this.tag = tag;
            this.manager = manager;
            this.modifier = modifier;
            this.type = 'update-modifier';
            this.lastUpdated = tag.value();
        }
        evaluate(vm) {
            let manager = this.manager,
                modifier = this.modifier,
                tag = this.tag,
                lastUpdated = this.lastUpdated;

            if (!tag.validate(lastUpdated)) {
                vm.env.scheduleUpdateModifier(modifier, manager);
                this.lastUpdated = tag.value();
            }
        }
    }
    APPEND_OPCODES.add(35 /* StaticAttr */, (vm, { op1: _name, op2: _value, op3: _namespace }) => {
        let name = vm.constants.getString(_name);
        let value = vm.constants.getString(_value);
        let namespace = _namespace ? vm.constants.getString(_namespace) : null;
        vm.elements().setStaticAttribute(name, value, namespace);
    });
    APPEND_OPCODES.add(36 /* DynamicAttr */, (vm, { op1: _name, op2: trusting, op3: _namespace }) => {
        let name = vm.constants.getString(_name);
        let reference = vm.stack.pop();
        let value = reference.value();
        let namespace = _namespace ? vm.constants.getString(_namespace) : null;
        let attribute = vm.elements().setDynamicAttribute(name, value, !!trusting, namespace);
        if (!isConst(reference)) {
            vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute));
        }
    });
    class UpdateDynamicAttributeOpcode extends UpdatingOpcode {
        constructor(reference, attribute) {
            super();
            this.reference = reference;
            this.attribute = attribute;
            this.type = 'patch-element';
            this.tag = reference.tag;
            this.lastRevision = this.tag.value();
        }
        evaluate(vm) {
            let attribute = this.attribute,
                reference = this.reference,
                tag = this.tag;

            if (!tag.validate(this.lastRevision)) {
                this.lastRevision = tag.value();
                attribute.update(reference.value(), vm.env);
            }
        }
    }

    function resolveComponent(resolver, name, meta) {
        let definition = resolver.lookupComponentDefinition(name, meta);

        return definition;
    }

    class CurryComponentReference {
        constructor(inner, resolver, meta, args) {
            this.inner = inner;
            this.resolver = resolver;
            this.meta = meta;
            this.args = args;
            this.tag = inner.tag;
            this.lastValue = null;
            this.lastDefinition = null;
        }
        value() {
            let inner = this.inner,
                lastValue = this.lastValue;

            let value = inner.value();
            if (value === lastValue) {
                return this.lastDefinition;
            }
            let definition = null;
            if (isCurriedComponentDefinition(value)) {
                definition = value;
            } else if (typeof value === 'string' && value) {
                let resolver = this.resolver,
                    meta = this.meta;

                definition = resolveComponent(resolver, value, meta);
            }
            definition = this.curry(definition);
            this.lastValue = value;
            this.lastDefinition = definition;
            return definition;
        }
        get() {
            return UNDEFINED_REFERENCE;
        }
        curry(definition) {
            let args = this.args;

            if (!args && isCurriedComponentDefinition(definition)) {
                return definition;
            } else if (!definition) {
                return null;
            } else {
                return new CurriedComponentDefinition(definition, args);
            }
        }
    }

    class ClassListReference {
        constructor(list) {
            this.list = list;
            this.tag = combineTagged(list);
            this.list = list;
        }
        value() {
            let ret = [];
            let list = this.list;

            for (let i = 0; i < list.length; i++) {
                let value = normalizeStringValue(list[i].value());
                if (value) ret.push(value);
            }
            return ret.length === 0 ? null : ret.join(' ');
        }
    }

    /**
     * Converts a ComponentCapabilities object into a 32-bit integer representation.
     */
    function capabilityFlagsFrom(capabilities) {
        return 0 | (capabilities.dynamicLayout ? 1 /* DynamicLayout */ : 0) | (capabilities.dynamicTag ? 2 /* DynamicTag */ : 0) | (capabilities.prepareArgs ? 4 /* PrepareArgs */ : 0) | (capabilities.createArgs ? 8 /* CreateArgs */ : 0) | (capabilities.attributeHook ? 16 /* AttributeHook */ : 0) | (capabilities.elementHook ? 32 /* ElementHook */ : 0) | (capabilities.dynamicScope ? 64 /* DynamicScope */ : 0) | (capabilities.createCaller ? 128 /* CreateCaller */ : 0) | (capabilities.updateHook ? 256 /* UpdateHook */ : 0) | (capabilities.createInstance ? 512 /* CreateInstance */ : 0);
    }
    function hasCapability(capabilities, capability) {
        return !!(capabilities & capability);
    }

    APPEND_OPCODES.add(69 /* IsComponent */, vm => {
        let stack = vm.stack;
        let ref = stack.pop();
        stack.push(IsCurriedComponentDefinitionReference.create(ref));
    });
    APPEND_OPCODES.add(70 /* ContentType */, vm => {
        let stack = vm.stack;
        let ref = stack.peek();
        stack.push(new ContentTypeReference(ref));
    });
    APPEND_OPCODES.add(71 /* CurryComponent */, (vm, { op1: _meta }) => {
        let stack = vm.stack;
        let definition = stack.pop();
        let capturedArgs = stack.pop();
        let meta = vm.constants.getSerializable(_meta);
        let resolver = vm.constants.resolver;
        vm.loadValue(Register.v0, new CurryComponentReference(definition, resolver, meta, capturedArgs));
        // expectStackChange(vm.stack, -args.length - 1, 'CurryComponent');
    });
    APPEND_OPCODES.add(72 /* PushComponentDefinition */, (vm, { op1: handle }) => {
        let definition = vm.constants.resolveHandle(handle);

        let manager = definition.manager;

        let capabilities = capabilityFlagsFrom(manager.getCapabilities(definition.state));
        let instance = {
            definition,
            manager,
            capabilities,
            state: null,
            handle: null,
            table: null,
            lookup: null
        };
        vm.stack.push(instance);
    });
    APPEND_OPCODES.add(75 /* ResolveDynamicComponent */, (vm, { op1: _meta }) => {
        let stack = vm.stack;
        let component = stack.pop().value();
        let meta = vm.constants.getSerializable(_meta);
        vm.loadValue(Register.t1, null); // Clear the temp register
        let definition;
        if (typeof component === 'string') {
            let resolver = vm.constants.resolver;

            let resolvedDefinition = resolveComponent(resolver, component, meta);
            definition = resolvedDefinition;
        } else if (isCurriedComponentDefinition(component)) {
            definition = component;
        } else {
            throw unreachable();
        }
        stack.push(definition);
    });
    APPEND_OPCODES.add(73 /* PushDynamicComponentInstance */, vm => {
        let stack = vm.stack;

        let definition = stack.pop();
        let capabilities, manager;
        if (isCurriedComponentDefinition(definition)) {
            manager = capabilities = null;
        } else {
            manager = definition.manager;
            capabilities = capabilityFlagsFrom(manager.getCapabilities(definition.state));
        }
        stack.push({ definition, capabilities, manager, state: null, handle: null, table: null });
    });
    APPEND_OPCODES.add(74 /* PushCurriedComponent */, (vm, { op1: _meta }) => {
        let stack = vm.stack;
        let component = stack.pop().value();
        let definition;
        if (isCurriedComponentDefinition(component)) {
            definition = component;
        } else {
            throw unreachable();
        }
        stack.push(definition);
    });
    APPEND_OPCODES.add(76 /* PushArgs */, (vm, { op1: _names, op2: flags }) => {
        let stack = vm.stack;
        let names = vm.constants.getStringArray(_names);
        let positionalCount = flags >> 4;
        let synthetic = flags & 0b1000;
        let blockNames = [];
        if (flags & 0b0100) blockNames.push('main');
        if (flags & 0b0010) blockNames.push('else');
        if (flags & 0b0001) blockNames.push('attrs');
        vm.args.setup(stack, names, blockNames, positionalCount, !!synthetic);
        stack.push(vm.args);
    });
    APPEND_OPCODES.add(77 /* PushEmptyArgs */, vm => {
        let stack = vm.stack;

        stack.push(vm.args.empty(stack));
    });
    APPEND_OPCODES.add(80 /* CaptureArgs */, vm => {
        let stack = vm.stack;
        let args = stack.pop();
        let capturedArgs = args.capture();
        stack.push(capturedArgs);
    });
    APPEND_OPCODES.add(79 /* PrepareArgs */, (vm, { op1: _state }) => {
        let stack = vm.stack;
        let instance = vm.fetchValue(_state);
        let args = stack.pop();
        let definition = instance.definition;

        if (isCurriedComponentDefinition(definition)) {

            definition = resolveCurriedComponentDefinition(instance, definition, args);
        }
        var _definition = definition;
        let manager = _definition.manager,
            state = _definition.state;

        let capabilities = instance.capabilities;
        if (hasCapability(capabilities, 4 /* PrepareArgs */) !== true) {
            stack.push(args);
            return;
        }
        let blocks = args.blocks.values;
        let blockNames = args.blocks.names;
        let preparedArgs = manager.prepareArgs(state, args);
        if (preparedArgs) {
            args.clear();
            for (let i = 0; i < blocks.length; i++) {
                stack.push(blocks[i]);
            }
            let positional = preparedArgs.positional,
                named = preparedArgs.named;

            let positionalCount = positional.length;
            for (let i = 0; i < positionalCount; i++) {
                stack.push(positional[i]);
            }
            let names = Object.keys(named);
            for (let i = 0; i < names.length; i++) {
                stack.push(named[names[i]]);
            }
            args.setup(stack, names, blockNames, positionalCount, true);
        }
        stack.push(args);
    });
    function resolveCurriedComponentDefinition(instance, definition, args) {
        let unwrappedDefinition = instance.definition = definition.unwrap(args);
        let manager = unwrappedDefinition.manager,
            state = unwrappedDefinition.state;

        instance.manager = manager;
        instance.capabilities = capabilityFlagsFrom(manager.getCapabilities(state));
        return unwrappedDefinition;
    }
    APPEND_OPCODES.add(81 /* CreateComponent */, (vm, { op1: flags, op2: _state }) => {
        let instance = vm.fetchValue(_state);
        let definition = instance.definition,
            manager = instance.manager;

        let capabilities = instance.capabilities = capabilityFlagsFrom(manager.getCapabilities(definition.state));
        let dynamicScope = null;
        if (hasCapability(capabilities, 64 /* DynamicScope */)) {
            dynamicScope = vm.dynamicScope();
        }
        let hasDefaultBlock = flags & 1;
        let args = null;
        if (hasCapability(capabilities, 8 /* CreateArgs */)) {
            args = vm.stack.peek();
        }
        let self = null;
        if (hasCapability(capabilities, 128 /* CreateCaller */)) {
            self = vm.getSelf();
        }
        let state = manager.create(vm.env, definition.state, args, dynamicScope, self, !!hasDefaultBlock);
        // We want to reuse the `state` POJO here, because we know that the opcodes
        // only transition at exactly one place.
        instance.state = state;
        let tag = manager.getTag(state);
        if (hasCapability(capabilities, 256 /* UpdateHook */) && !isConstTag(tag)) {
            vm.updateWith(new UpdateComponentOpcode(tag, state, manager, dynamicScope));
        }
    });
    APPEND_OPCODES.add(82 /* RegisterComponentDestructor */, (vm, { op1: _state }) => {
        var _vm$fetchValue = vm.fetchValue(_state);

        let manager = _vm$fetchValue.manager,
            state = _vm$fetchValue.state;

        let destructor = manager.getDestructor(state);
        if (destructor) vm.newDestroyable(destructor);
    });
    APPEND_OPCODES.add(91 /* BeginComponentTransaction */, vm => {
        vm.beginCacheGroup();
        vm.elements().pushSimpleBlock();
    });
    APPEND_OPCODES.add(83 /* PutComponentOperations */, vm => {
        vm.loadValue(Register.t0, new ComponentElementOperations());
    });
    APPEND_OPCODES.add(37 /* ComponentAttr */, (vm, { op1: _name, op2: trusting, op3: _namespace }) => {
        let name = vm.constants.getString(_name);
        let reference = vm.stack.pop();
        let namespace = _namespace ? vm.constants.getString(_namespace) : null;
        vm.fetchValue(Register.t0).setAttribute(name, reference, !!trusting, namespace);
    });
    class ComponentElementOperations {
        constructor() {
            this.attributes = dict();
            this.classes = [];
        }
        setAttribute(name, value, trusting, namespace) {
            let deferred = { value, namespace, trusting };
            if (name === 'class') {
                this.classes.push(value);
            }
            this.attributes[name] = deferred;
        }
        flush(vm) {
            for (let name in this.attributes) {
                let attr = this.attributes[name];
                let reference = attr.value,
                    namespace = attr.namespace,
                    trusting = attr.trusting;

                if (name === 'class') {
                    reference = new ClassListReference(this.classes);
                }
                if (name === 'type') {
                    continue;
                }
                let attribute = vm.elements().setDynamicAttribute(name, reference.value(), trusting, namespace);
                if (!isConst(reference)) {
                    vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute));
                }
            }
            if ('type' in this.attributes) {
                let type = this.attributes.type;
                let reference = type.value,
                    namespace = type.namespace,
                    trusting = type.trusting;

                let attribute = vm.elements().setDynamicAttribute('type', reference.value(), trusting, namespace);
                if (!isConst(reference)) {
                    vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute));
                }
            }
        }
    }
    APPEND_OPCODES.add(93 /* DidCreateElement */, (vm, { op1: _state }) => {
        var _vm$fetchValue2 = vm.fetchValue(_state);

        let definition = _vm$fetchValue2.definition,
            state = _vm$fetchValue2.state;
        let manager = definition.manager;

        let operations = vm.fetchValue(Register.t0);
        let action = 'DidCreateElementOpcode#evaluate';
        manager.didCreateElement(state, vm.elements().expectConstructing(action), operations);
    });
    APPEND_OPCODES.add(84 /* GetComponentSelf */, (vm, { op1: _state }) => {
        var _vm$fetchValue3 = vm.fetchValue(_state);

        let definition = _vm$fetchValue3.definition,
            state = _vm$fetchValue3.state;
        let manager = definition.manager;

        vm.stack.push(manager.getSelf(state));
    });
    APPEND_OPCODES.add(85 /* GetComponentTagName */, (vm, { op1: _state }) => {
        var _vm$fetchValue4 = vm.fetchValue(_state);

        let definition = _vm$fetchValue4.definition,
            state = _vm$fetchValue4.state;
        let manager = definition.manager;

        vm.stack.push(manager.getTagName(state));
    });
    // Dynamic Invocation Only
    APPEND_OPCODES.add(86 /* GetComponentLayout */, (vm, { op1: _state }) => {
        let instance = vm.fetchValue(_state);
        let manager = instance.manager,
            definition = instance.definition;
        let resolver = vm.constants.resolver,
            stack = vm.stack;
        let instanceState = instance.state,
            capabilities = instance.capabilities;
        let definitionState = definition.state;

        let invoke;
        if (hasStaticLayout(capabilities, manager)) {
            invoke = manager.getLayout(definitionState, resolver);
        } else if (hasDynamicLayout(capabilities, manager)) {
            invoke = manager.getDynamicLayout(instanceState, resolver);
        } else {
            throw unreachable();
        }
        stack.push(invoke.symbolTable);
        stack.push(invoke.handle);
    });
    function hasStaticLayout(capabilities, _manager) {
        return hasCapability(capabilities, 1 /* DynamicLayout */) === false;
    }
    function hasDynamicLayout(capabilities, _manager) {
        return hasCapability(capabilities, 1 /* DynamicLayout */) === true;
    }
    APPEND_OPCODES.add(68 /* Main */, (vm, { op1: register }) => {
        let definition = vm.stack.pop();
        let invocation = vm.stack.pop();
        let manager = definition.manager;

        let capabilities = capabilityFlagsFrom(manager.getCapabilities(definition.state));
        let state = {
            definition,
            manager,
            capabilities,
            state: null,
            handle: invocation.handle,
            table: invocation.symbolTable,
            lookup: null
        };
        vm.loadValue(register, state);
    });
    APPEND_OPCODES.add(89 /* PopulateLayout */, (vm, { op1: _state }) => {
        let stack = vm.stack;

        let handle = stack.pop();
        let table = stack.pop();
        let state = vm.fetchValue(_state);
        state.handle = handle;
        state.table = table;
    });
    APPEND_OPCODES.add(21 /* VirtualRootScope */, (vm, { op1: _state }) => {
        let symbols = vm.fetchValue(_state).table.symbols;

        vm.pushRootScope(symbols.length + 1, true);
    });
    APPEND_OPCODES.add(87 /* SetupForEval */, (vm, { op1: _state }) => {
        let state = vm.fetchValue(_state);
        if (state.table.hasEval) {
            let lookup = state.lookup = dict();
            vm.scope().bindEvalScope(lookup);
        }
    });
    APPEND_OPCODES.add(2 /* SetNamedVariables */, (vm, { op1: _state }) => {
        let state = vm.fetchValue(_state);
        let scope = vm.scope();
        let args = vm.stack.peek();
        let callerNames = args.named.atNames;
        for (let i = callerNames.length - 1; i >= 0; i--) {
            let atName = callerNames[i];
            let symbol = state.table.symbols.indexOf(callerNames[i]);
            let value = args.named.get(atName, false);
            if (symbol !== -1) scope.bindSymbol(symbol + 1, value);
            if (state.lookup) state.lookup[atName] = value;
        }
    });
    function bindBlock(symbolName, blockName, state, blocks, vm) {
        let symbol = state.table.symbols.indexOf(symbolName);
        let block = blocks.get(blockName);
        if (symbol !== -1) {
            vm.scope().bindBlock(symbol + 1, block);
        }
        if (state.lookup) state.lookup[symbolName] = block;
    }
    APPEND_OPCODES.add(3 /* SetBlocks */, (vm, { op1: _state }) => {
        let state = vm.fetchValue(_state);

        var _vm$stack$peek = vm.stack.peek();

        let blocks = _vm$stack$peek.blocks;

        bindBlock('&attrs', 'attrs', state, blocks, vm);
        bindBlock('&inverse', 'else', state, blocks, vm);
        bindBlock('&default', 'main', state, blocks, vm);
    });
    // Dynamic Invocation Only
    APPEND_OPCODES.add(90 /* InvokeComponentLayout */, (vm, { op1: _state }) => {
        let state = vm.fetchValue(_state);
        vm.call(state.handle);
    });
    APPEND_OPCODES.add(94 /* DidRenderLayout */, (vm, { op1: _state }) => {
        var _vm$fetchValue5 = vm.fetchValue(_state);

        let manager = _vm$fetchValue5.manager,
            state = _vm$fetchValue5.state;

        let bounds = vm.elements().popBlock();
        let mgr = manager;
        mgr.didRenderLayout(state, bounds);
        vm.env.didCreate(state, manager);
        vm.updateWith(new DidUpdateLayoutOpcode(manager, state, bounds));
    });
    APPEND_OPCODES.add(92 /* CommitComponentTransaction */, vm => {
        vm.commitCacheGroup();
    });
    class UpdateComponentOpcode extends UpdatingOpcode {
        constructor(tag, component, manager, dynamicScope) {
            super();
            this.tag = tag;
            this.component = component;
            this.manager = manager;
            this.dynamicScope = dynamicScope;
            this.type = 'update-component';
        }
        evaluate(_vm) {
            let component = this.component,
                manager = this.manager,
                dynamicScope = this.dynamicScope;

            manager.update(component, dynamicScope);
        }
    }
    class DidUpdateLayoutOpcode extends UpdatingOpcode {
        constructor(manager, component, bounds) {
            super();
            this.manager = manager;
            this.component = component;
            this.bounds = bounds;
            this.type = 'did-update-layout';
            this.tag = CONSTANT_TAG;
        }
        evaluate(vm) {
            let manager = this.manager,
                component = this.component,
                bounds = this.bounds;

            manager.didUpdateLayout(component, bounds);
            vm.env.didUpdate(component, manager);
        }
    }

    /* tslint:disable */
    function debugCallback(context, get) {
        console.info('Use `context`, and `get(<path>)` to debug this template.');
        // for example...
        context === get('this');
        debugger;
    }
    /* tslint:enable */
    let callback = debugCallback;
    class ScopeInspector {
        constructor(scope, symbols, evalInfo) {
            this.scope = scope;
            this.locals = dict();
            for (let i = 0; i < evalInfo.length; i++) {
                let slot = evalInfo[i];
                let name = symbols[slot - 1];
                let ref = scope.getSymbol(slot);
                this.locals[name] = ref;
            }
        }
        get(path) {
            let scope = this.scope,
                locals = this.locals;

            let parts = path.split('.');

            var _path$split = path.split('.');

            let head = _path$split[0],
                tail = _path$split.slice(1);

            let evalScope = scope.getEvalScope();
            let ref;
            if (head === 'this') {
                ref = scope.getSelf();
            } else if (locals[head]) {
                ref = locals[head];
            } else if (head.indexOf('@') === 0 && evalScope[head]) {
                ref = evalScope[head];
            } else {
                ref = this.scope.getSelf();
                tail = parts;
            }
            return tail.reduce((r, part) => r.get(part), ref);
        }
    }
    APPEND_OPCODES.add(97 /* Debugger */, (vm, { op1: _symbols, op2: _evalInfo }) => {
        let symbols = vm.constants.getStringArray(_symbols);
        let evalInfo = vm.constants.getArray(_evalInfo);
        let inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);
        callback(vm.getSelf().value(), path => inspector.get(path).value());
    });

    APPEND_OPCODES.add(95 /* InvokePartial */, (vm, { op1: _meta, op2: _symbols, op3: _evalInfo }) => {
        let constants = vm.constants,
            resolver = vm.constants.resolver,
            stack = vm.stack;

        let name = stack.pop().value();

        let meta = constants.getSerializable(_meta);
        let outerSymbols = constants.getStringArray(_symbols);
        let evalInfo = constants.getArray(_evalInfo);
        let handle = resolver.lookupPartial(name, meta);

        let definition = resolver.resolve(handle);

        var _definition$getPartia = definition.getPartial();

        let symbolTable = _definition$getPartia.symbolTable,
            vmHandle = _definition$getPartia.handle;

        {
            let partialSymbols = symbolTable.symbols;
            let outerScope = vm.scope();
            let partialScope = vm.pushRootScope(partialSymbols.length, false);
            let evalScope = outerScope.getEvalScope();
            partialScope.bindCallerScope(outerScope.getCallerScope());
            partialScope.bindEvalScope(evalScope);
            partialScope.bindSelf(outerScope.getSelf());
            let locals = Object.create(outerScope.getPartialMap());
            for (let i = 0; i < evalInfo.length; i++) {
                let slot = evalInfo[i];
                let name = outerSymbols[slot - 1];
                let ref = outerScope.getSymbol(slot);
                locals[name] = ref;
            }
            if (evalScope) {
                for (let i = 0; i < partialSymbols.length; i++) {
                    let name = partialSymbols[i];
                    let symbol = i + 1;
                    let value = evalScope[name];
                    if (value !== undefined) partialScope.bind(symbol, value);
                }
            }
            partialScope.bindPartialMap(locals);
            vm.pushFrame(); // sp += 2
            vm.call(vmHandle);
        }
    });

    class IterablePresenceReference {
        constructor(artifacts) {
            this.tag = artifacts.tag;
            this.artifacts = artifacts;
        }
        value() {
            return !this.artifacts.isEmpty();
        }
    }
    APPEND_OPCODES.add(66 /* PutIterator */, vm => {
        let stack = vm.stack;
        let listRef = stack.pop();
        let key = stack.pop();
        let iterable = vm.env.iterableFor(listRef, key.value());
        let iterator = new ReferenceIterator(iterable);
        stack.push(iterator);
        stack.push(new IterablePresenceReference(iterator.artifacts));
    });
    APPEND_OPCODES.add(64 /* EnterList */, (vm, { op1: relativeStart }) => {
        vm.enterList(relativeStart);
    });
    APPEND_OPCODES.add(65 /* ExitList */, vm => {
        vm.exitList();
    });
    APPEND_OPCODES.add(67 /* Iterate */, (vm, { op1: breaks }) => {
        let stack = vm.stack;
        let item = stack.peek().next();
        if (item) {
            let tryOpcode = vm.iterate(item.memo, item.value);
            vm.enterItem(item.key, tryOpcode);
        } else {
            vm.goto(breaks);
        }
    });

    class ConcreteBounds {
        constructor(parentNode, first, last) {
            this.parentNode = parentNode;
            this.first = first;
            this.last = last;
        }
        parentElement() {
            return this.parentNode;
        }
        firstNode() {
            return this.first;
        }
        lastNode() {
            return this.last;
        }
    }

    const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    // Patch:    insertAdjacentHTML on SVG Fix
    // Browsers: Safari, IE, Edge, Firefox ~33-34
    // Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is
    //           present but throws an exception on IE and Edge. Old versions of
    //           Firefox create nodes in the incorrect namespace.
    // Fix:      Since IE and Edge silently fail to create SVG nodes using
    //           innerHTML, and because Firefox may create nodes in the incorrect
    //           namespace using innerHTML on SVG elements, an HTML-string wrapping
    //           approach is used. A pre/post SVG tag is added to the string, then
    //           that whole string is added to a div. The created nodes are plucked
    //           out and applied to the target location on DOM.
    function applySVGInnerHTMLFix(document, DOMClass, svgNamespace) {
        if (!document) return DOMClass;
        if (!shouldApplyFix(document, svgNamespace)) {
            return DOMClass;
        }
        let div = document.createElement('div');
        return class DOMChangesWithSVGInnerHTMLFix extends DOMClass {
            insertHTMLBefore(parent, nextSibling, html) {
                if (html === null || html === '') {
                    return super.insertHTMLBefore(parent, nextSibling, html);
                }
                if (parent.namespaceURI !== svgNamespace) {
                    return super.insertHTMLBefore(parent, nextSibling, html);
                }
                return fixSVG(parent, div, html, nextSibling);
            }
        };
    }
    function fixSVG(parent, div, html, reference) {
        // IE, Edge: also do not correctly support using `innerHTML` on SVG
        // namespaced elements. So here a wrapper is used.
        let wrappedHtml = '<svg>' + html + '</svg>';
        div.innerHTML = wrappedHtml;

        var _moveNodesBefore = moveNodesBefore(div.firstChild, parent, reference);

        let first = _moveNodesBefore[0],
            last = _moveNodesBefore[1];

        return new ConcreteBounds(parent, first, last);
    }
    function shouldApplyFix(document, svgNamespace) {
        let svg = document.createElementNS(svgNamespace, 'svg');
        try {
            svg['insertAdjacentHTML']('beforeend', '<circle></circle>');
        } catch (e) {
            // IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG
            // Safari: Will throw, insertAdjacentHTML is not present on SVG
        } finally {
            // FF: Old versions will create a node in the wrong namespace
            if (svg.childNodes.length === 1 && svg.firstChild.namespaceURI === SVG_NAMESPACE) {
                // The test worked as expected, no fix required
                return false;
            }
            return true;
        }
    }

    // Patch:    Adjacent text node merging fix
    // Browsers: IE, Edge, Firefox w/o inspector open
    // Reason:   These browsers will merge adjacent text nodes. For exmaple given
    //           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers
    //           with proper behavior will populate div.childNodes with two items.
    //           These browsers will populate it with one merged node instead.
    // Fix:      Add these nodes to a wrapper element, then iterate the childNodes
    //           of that wrapper and move the nodes to their target location. Note
    //           that potential SVG bugs will have been handled before this fix.
    //           Note that this fix must only apply to the previous text node, as
    //           the base implementation of `insertHTMLBefore` already handles
    //           following text nodes correctly.
    function applyTextNodeMergingFix(document, DOMClass) {
        if (!document) return DOMClass;
        if (!shouldApplyFix$1(document)) {
            return DOMClass;
        }
        return class DOMChangesWithTextNodeMergingFix extends DOMClass {
            constructor(document) {
                super(document);
                this.uselessComment = document.createComment('');
            }
            insertHTMLBefore(parent, nextSibling, html) {
                if (html === null) {
                    return super.insertHTMLBefore(parent, nextSibling, html);
                }
                let didSetUselessComment = false;
                let nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;
                if (nextPrevious && nextPrevious instanceof Text) {
                    didSetUselessComment = true;
                    parent.insertBefore(this.uselessComment, nextSibling);
                }
                let bounds = super.insertHTMLBefore(parent, nextSibling, html);
                if (didSetUselessComment) {
                    parent.removeChild(this.uselessComment);
                }
                return bounds;
            }
        };
    }
    function shouldApplyFix$1(document) {
        let mergingTextDiv = document.createElement('div');
        mergingTextDiv.innerHTML = 'first';
        mergingTextDiv.insertAdjacentHTML('beforeend', 'second');
        if (mergingTextDiv.childNodes.length === 2) {
            // It worked as expected, no fix required
            return false;
        }
        return true;
    }

    const SVG_NAMESPACE$1 = 'http://www.w3.org/2000/svg';
    // http://www.w3.org/TR/html/syntax.html#html-integration-point
    const SVG_INTEGRATION_POINTS = { foreignObject: 1, desc: 1, title: 1 };
    // http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes
    // TODO: Adjust SVG attributes
    // http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
    // TODO: Adjust SVG elements
    // http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
    const BLACKLIST_TABLE = Object.create(null);
    ['b', 'big', 'blockquote', 'body', 'br', 'center', 'code', 'dd', 'div', 'dl', 'dt', 'em', 'embed', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'hr', 'i', 'img', 'li', 'listing', 'main', 'meta', 'nobr', 'ol', 'p', 'pre', 'ruby', 's', 'small', 'span', 'strong', 'strike', 'sub', 'sup', 'table', 'tt', 'u', 'ul', 'var'].forEach(tag => BLACKLIST_TABLE[tag] = 1);
    let doc = typeof document === 'undefined' ? null : document;
    function moveNodesBefore(source, target, nextSibling) {
        let first = source.firstChild;
        let last = null;
        let current = first;
        while (current) {
            last = current;
            current = current.nextSibling;
            target.insertBefore(last, nextSibling);
        }
        return [first, last];
    }
    class DOMOperations {
        constructor(document) {
            this.document = document;
            this.setupUselessElement();
        }
        // split into seperate method so that NodeDOMTreeConstruction
        // can override it.
        setupUselessElement() {
            this.uselessElement = this.document.createElement('div');
        }
        createElement(tag, context) {
            let isElementInSVGNamespace, isHTMLIntegrationPoint;
            if (context) {
                isElementInSVGNamespace = context.namespaceURI === SVG_NAMESPACE$1 || tag === 'svg';
                isHTMLIntegrationPoint = SVG_INTEGRATION_POINTS[context.tagName];
            } else {
                isElementInSVGNamespace = tag === 'svg';
                isHTMLIntegrationPoint = false;
            }
            if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {
                // FIXME: This does not properly handle <font> with color, face, or
                // size attributes, which is also disallowed by the spec. We should fix
                // this.
                if (BLACKLIST_TABLE[tag]) {
                    throw new Error(`Cannot create a ${tag} inside an SVG context`);
                }
                return this.document.createElementNS(SVG_NAMESPACE$1, tag);
            } else {
                return this.document.createElement(tag);
            }
        }
        insertBefore(parent, node, reference) {
            parent.insertBefore(node, reference);
        }
        insertHTMLBefore(_parent, nextSibling, html) {
            return insertHTMLBefore(this.uselessElement, _parent, nextSibling, html);
        }
        createTextNode(text) {
            return this.document.createTextNode(text);
        }
        createComment(data) {
            return this.document.createComment(data);
        }
    }
    var DOM;
    (function (DOM) {
        class TreeConstruction extends DOMOperations {
            createElementNS(namespace, tag) {
                return this.document.createElementNS(namespace, tag);
            }
            setAttribute(element, name, value, namespace = null) {
                if (namespace) {
                    element.setAttributeNS(namespace, name, value);
                } else {
                    element.setAttribute(name, value);
                }
            }
        }
        DOM.TreeConstruction = TreeConstruction;
        let appliedTreeContruction = TreeConstruction;
        appliedTreeContruction = applyTextNodeMergingFix(doc, appliedTreeContruction);
        appliedTreeContruction = applySVGInnerHTMLFix(doc, appliedTreeContruction, SVG_NAMESPACE$1);
        DOM.DOMTreeConstruction = appliedTreeContruction;
    })(DOM || (DOM = {}));
    class DOMChanges extends DOMOperations {
        constructor(document) {
            super(document);
            this.document = document;
            this.namespace = null;
        }
        setAttribute(element, name, value) {
            element.setAttribute(name, value);
        }
        removeAttribute(element, name) {
            element.removeAttribute(name);
        }
        insertAfter(element, node, reference) {
            this.insertBefore(element, node, reference.nextSibling);
        }
    }
    function insertHTMLBefore(useless, _parent, _nextSibling, html) {
        // tslint:disable-line
        // TypeScript vendored an old version of the DOM spec where `insertAdjacentHTML`
        // only exists on `HTMLElement` but not on `Element`. We actually work with the
        // newer version of the DOM API here (and monkey-patch this method in `./compat`
        // when we detect older browsers). This is a hack to work around this limitation.
        let parent = _parent;
        let nextSibling = _nextSibling;
        let prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;
        let last;
        if (html === null || html === '') {
            return new ConcreteBounds(parent, null, null);
        }
        if (nextSibling === null) {
            parent.insertAdjacentHTML('beforeend', html);
            last = parent.lastChild;
        } else if (nextSibling instanceof HTMLElement) {
            nextSibling.insertAdjacentHTML('beforebegin', html);
            last = nextSibling.previousSibling;
        } else {
            // Non-element nodes do not support insertAdjacentHTML, so add an
            // element and call it on that element. Then remove the element.
            //
            // This also protects Edge, IE and Firefox w/o the inspector open
            // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts
            parent.insertBefore(useless, nextSibling);
            useless.insertAdjacentHTML('beforebegin', html);
            last = useless.previousSibling;
            parent.removeChild(useless);
        }
        let first = prev ? prev.nextSibling : parent.firstChild;
        return new ConcreteBounds(parent, first, last);
    }
    let helper = DOMChanges;
    helper = applyTextNodeMergingFix(doc, helper);
    helper = applySVGInnerHTMLFix(doc, helper, SVG_NAMESPACE$1);
    const DOMTreeConstruction = DOM.DOMTreeConstruction;

    /*
     * @method normalizeProperty
     * @param element {HTMLElement}
     * @param slotName {String}
     * @returns {Object} { name, type }
     */

    class CapturedPositionalArguments {
        constructor(tag, references, length = references.length) {
            this.tag = tag;
            this.references = references;
            this.length = length;
        }
        static empty() {
            return new CapturedPositionalArguments(CONSTANT_TAG, EMPTY_ARRAY, 0);
        }
        at(position) {
            return this.references[position];
        }
        value() {
            return this.references.map(this.valueOf);
        }
        get(name) {
            let references = this.references,
                length = this.length;

            if (name === 'length') {
                return PrimitiveReference.create(length);
            } else {
                let idx = parseInt(name, 10);
                if (idx < 0 || idx >= length) {
                    return UNDEFINED_REFERENCE;
                } else {
                    return references[idx];
                }
            }
        }
        valueOf(reference) {
            return reference.value();
        }
    }
    class CapturedNamedArguments {
        constructor(tag, names, references) {
            this.tag = tag;
            this.names = names;
            this.references = references;
            this.length = names.length;
            this._map = null;
        }
        get map() {
            let map$$1 = this._map;
            if (!map$$1) {
                let names = this.names,
                    references = this.references;

                map$$1 = this._map = dict();
                for (let i = 0; i < names.length; i++) {
                    let name = names[i];
                    map$$1[name] = references[i];
                }
            }
            return map$$1;
        }
        has(name) {
            return this.names.indexOf(name) !== -1;
        }
        get(name) {
            let names = this.names,
                references = this.references;

            let idx = names.indexOf(name);
            if (idx === -1) {
                return UNDEFINED_REFERENCE;
            } else {
                return references[idx];
            }
        }
        value() {
            let names = this.names,
                references = this.references;

            let out = dict();
            for (let i = 0; i < names.length; i++) {
                let name = names[i];
                out[name] = references[i].value();
            }
            return out;
        }
    }
    const EMPTY_NAMED = new CapturedNamedArguments(CONSTANT_TAG, EMPTY_ARRAY, EMPTY_ARRAY);
    const EMPTY_POSITIONAL = new CapturedPositionalArguments(CONSTANT_TAG, EMPTY_ARRAY);

    /** @internal */

    /**
     * The base PathReference.
     */
    class ComponentPathReference {
        get(key) {
            return PropertyReference.create(this, key);
        }
    }
    class CachedReference$1 extends ComponentPathReference {
        constructor() {
            super(...arguments);
            this._lastRevision = null;
            this._lastValue = null;
        }
        value() {
            let tag = this.tag,
                _lastRevision = this._lastRevision,
                _lastValue = this._lastValue;

            if (!_lastRevision || !tag.validate(_lastRevision)) {
                _lastValue = this._lastValue = this.compute();
                this._lastRevision = tag.value();
            }
            return _lastValue;
        }
    }
    class RootReference extends ConstReference {
        constructor() {
            super(...arguments);
            this.children = dict();
        }
        get(propertyKey) {
            let ref = this.children[propertyKey];
            if (!ref) {
                ref = this.children[propertyKey] = new RootPropertyReference(this.inner, propertyKey);
            }
            return ref;
        }
    }
    class PropertyReference extends CachedReference$1 {
        static create(parentReference, propertyKey) {
            if (isConst(parentReference)) {
                return new RootPropertyReference(parentReference.value(), propertyKey);
            } else {
                return new NestedPropertyReference(parentReference, propertyKey);
            }
        }
        get(key) {
            return new NestedPropertyReference(this, key);
        }
    }
    class RootPropertyReference extends PropertyReference {
        constructor(parentValue, propertyKey) {
            super();
            this._parentValue = parentValue;
            this._propertyKey = propertyKey;
            this.tag = tagForProperty(parentValue, propertyKey);
        }
        compute() {
            return this._parentValue[this._propertyKey];
        }
    }
    class NestedPropertyReference extends PropertyReference {
        constructor(parentReference, propertyKey) {
            super();
            let parentReferenceTag = parentReference.tag;
            let parentObjectTag = UpdatableTag.create(CONSTANT_TAG);
            this._parentReference = parentReference;
            this._parentObjectTag = parentObjectTag;
            this._propertyKey = propertyKey;
            this.tag = combine([parentReferenceTag, parentObjectTag]);
        }
        compute() {
            let _parentReference = this._parentReference,
                _parentObjectTag = this._parentObjectTag,
                _propertyKey = this._propertyKey;

            let parentValue = _parentReference.value();
            _parentObjectTag.inner.update(tagForProperty(parentValue, _propertyKey));
            if (typeof parentValue === "string" && _propertyKey === "length") {
                return parentValue.length;
            }
            if (typeof parentValue === "object" && parentValue) {
                return parentValue[_propertyKey];
            } else {
                return undefined;
            }
        }
    }
    class UpdatableReference extends ComponentPathReference {
        constructor(value) {
            super();
            this.tag = DirtyableTag.create();
            this._value = value;
        }
        value() {
            return this._value;
        }
        update(value) {
            let _value = this._value;

            if (value !== _value) {
                this.tag.inner.dirty();
                this._value = value;
            }
        }
    }
    class TemplateOnlyComponentDebugReference extends ConstReference {
        constructor(name) {
            super(undefined);
            this.name = name;
        }
        get(propertyKey) {
            throw new Error(`You tried to reference {{${propertyKey}}} from the ${this.name} template, which doesn't have an associated component class. Template-only components can only access args passed to them. Did you mean {{@${propertyKey}}}?`);
        }
    }

    class ComponentStateBucket {
        constructor(definition, args, owner, env) {
            let componentFactory = definition.ComponentClass;
            let name = definition.name;
            this.args = args;
            let injections = {
                debugName: name,
                args: this.namedArgsSnapshot()
            };
            env.setOwner(injections, owner);
            if (componentFactory) {
                this.component = componentFactory.create(injections);
            }
        }
        get tag() {
            return this.args.tag;
        }
        namedArgsSnapshot() {
            return Object.freeze(this.args.named.value());
        }
    }
    const EMPTY_SELF = new RootReference(null);
    /**
     * For performance reasons, we want to avoid instantiating component buckets for
     * components that don't have an associated component class that we would need
     * instantiate and invoke lifecycle hooks on.
     *
     * In development mode, however, we need to track some state about the component
     * in order to produce more useful error messages. This
     * TemplateOnlyComponentDebugBucket is only created in development mode to hold
     * that state.
     */
    class TemplateOnlyComponentDebugBucket {
        constructor(definition) {
            this.definition = definition;
        }
    }
    class ComponentManager {
        static create(options) {
            return new ComponentManager(options);
        }
        constructor(options) {
            this.env = options.env;
        }
        prepareArgs(state, args) {
            return null;
        }
        getCapabilities(state) {
            return state.capabilities;
        }
        getLayout({ name, handle, symbolTable }, resolver) {
            if (handle && symbolTable) {
                return {
                    handle,
                    symbolTable
                };
            }
            return resolver.compileTemplate(name, handle);
        }
        create(_env, definition, args, _dynamicScope, _caller, _hasDefaultBlock) {
            // In development mode, if a component is template-only, save off state
            // needed for error messages. This will get stripped in production mode and
            // no bucket will be instantiated.
            if (true && !definition.ComponentClass) {
                return new TemplateOnlyComponentDebugBucket(definition);
            }
            // Only create a state bucket if the component is actually stateful. We can
            // skip this for template-only components, which are pure functions.
            if (definition.ComponentClass) {
                let owner = this.env.getOwner();
                return new ComponentStateBucket(definition, args.capture(), owner, this.env);
            }
        }
        getSelf(bucket) {
            if (true && bucket instanceof TemplateOnlyComponentDebugBucket) {
                return new TemplateOnlyComponentDebugReference(bucket.definition.name);
            }
            if (bucket) {
                return new RootReference(bucket.component);
            }
            return EMPTY_SELF;
        }
        didCreateElement(bucket, element) {}
        didRenderLayout(bucket, bounds) {
            if (true && bucket instanceof TemplateOnlyComponentDebugBucket) {
                return;
            }
            if (!bucket) {
                return;
            }
            bucket.component.bounds = new Bounds(bounds);
        }
        didCreate(bucket) {
            if (true && bucket instanceof TemplateOnlyComponentDebugBucket) {
                return;
            }
            if (!bucket) {
                return;
            }
            bucket.component.didInsertElement();
        }
        getTag(bucket) {
            if (true && bucket instanceof TemplateOnlyComponentDebugBucket) {
                return CONSTANT_TAG;
            }
            if (!bucket) {
                return CONSTANT_TAG;
            }
            return bucket.tag;
        }
        update(bucket, scope) {
            if (true && bucket instanceof TemplateOnlyComponentDebugBucket) {
                return;
            }
            if (!bucket) {
                return;
            }
            bucket.component.args = bucket.namedArgsSnapshot();
        }
        didUpdateLayout() {}
        didUpdate(bucket) {
            if (true && bucket instanceof TemplateOnlyComponentDebugBucket) {
                return;
            }
            if (!bucket) {
                return;
            }
            bucket.component.didUpdate();
        }
        getDestructor(bucket) {
            if (true && bucket instanceof TemplateOnlyComponentDebugBucket) {
                return NOOP_DESTROYABLE;
            }
            if (!bucket) {
                return NOOP_DESTROYABLE;
            }
            return bucket.component;
        }
    }
    const NOOP_DESTROYABLE = { destroy() {} };

    function initializeCustomElements(app, customElementDefinitions) {
        for (let customElementName in customElementDefinitions) {
            let glimmerComponentName = customElementDefinitions[customElementName];
            initializeCustomElement(app, customElementName, glimmerComponentName);
        }
    }
    function initializeCustomElement(app, customElementName, glimmerComponentName) {
        function GlimmerElement() {
            return Reflect.construct(HTMLElement, [], GlimmerElement);
        }
        GlimmerElement.prototype = Object.create(HTMLElement.prototype, {
            constructor: { value: GlimmerElement },
            connectedCallback: {
                value: function connectedCallback() {
                    let placeholder = document.createElement('span');
                    let parent = this.parentNode;
                    parent.insertBefore(placeholder, this);
                    parent.removeChild(this);
                    app.renderComponent(glimmerComponentName, parent, placeholder);
                    whenRendered(app, () => {
                        let customElement = this;
                        let glimmerElement = placeholder.previousElementSibling;
                        placeholder.remove();
                        assignAttributes(customElement, glimmerElement);
                    });
                }
            }
        });
        window.customElements.define(customElementName, GlimmerElement);
    }
    function assignAttributes(fromElement, toElement) {
        let attributes = fromElement.attributes;
        for (let i = 0; i < attributes.length; i++) {
            var _attributes$item = attributes.item(i);

            let name = _attributes$item.name,
                value = _attributes$item.value;

            toElement.setAttribute(name, value);
        }
    }
    function whenRendered(app, callback) {
        if (app['_rendering']) {
            requestAnimationFrame(() => {
                whenRendered(app, callback);
            });
        } else {
            callback();
        }
    }

    class Container {
        constructor(registry, resolver = null) {
            this._registry = registry;
            this._resolver = resolver;
            this._lookups = {};
            this._factoryDefinitionLookups = {};
        }
        factoryFor(specifier) {
            let factoryDefinition = this._factoryDefinitionLookups[specifier];
            if (!factoryDefinition) {
                if (this._resolver) {
                    factoryDefinition = this._resolver.retrieve(specifier);
                }
                if (!factoryDefinition) {
                    factoryDefinition = this._registry.registration(specifier);
                }
                if (factoryDefinition) {
                    this._factoryDefinitionLookups[specifier] = factoryDefinition;
                }
            }
            if (!factoryDefinition) {
                return;
            }
            return this.buildFactory(specifier, factoryDefinition);
        }
        lookup(specifier) {
            let singleton = this._registry.registeredOption(specifier, 'singleton') !== false;
            if (singleton && this._lookups[specifier]) {
                return this._lookups[specifier];
            }
            let factory = this.factoryFor(specifier);
            if (!factory) {
                return;
            }
            if (this._registry.registeredOption(specifier, 'instantiate') === false) {
                return factory.class;
            }
            let object = factory.create();
            if (singleton && object) {
                this._lookups[specifier] = object;
            }
            return object;
        }
        defaultInjections(specifier) {
            return {};
        }
        buildInjections(specifier) {
            let hash = this.defaultInjections(specifier);
            let injections = this._registry.registeredInjections(specifier);
            let injection;
            for (let i = 0; i < injections.length; i++) {
                injection = injections[i];
                hash[injection.property] = this.lookup(injection.source);
            }
            return hash;
        }
        buildFactory(specifier, factoryDefinition) {
            let injections = this.buildInjections(specifier);
            return {
                class: factoryDefinition,
                create(options) {
                    let mergedOptions = Object.assign({}, injections, options);
                    return factoryDefinition.create(mergedOptions);
                }
            };
        }
    }

    class Registry {
        constructor(options) {
            this._registrations = {};
            this._registeredOptions = {};
            this._registeredInjections = {};
            if (options && options.fallback) {
                this._fallback = options.fallback;
            }
        }
        register(specifier, factoryDefinition, options) {
            this._registrations[specifier] = factoryDefinition;
            if (options) {
                this._registeredOptions[specifier] = options;
            }
        }
        registration(specifier) {
            let registration = this._registrations[specifier];
            if (registration === undefined && this._fallback) {
                registration = this._fallback.registration(specifier);
            }
            return registration;
        }
        unregister(specifier) {
            delete this._registrations[specifier];
            delete this._registeredOptions[specifier];
            delete this._registeredInjections[specifier];
        }
        registerOption(specifier, option, value) {
            let options = this._registeredOptions[specifier];
            if (!options) {
                options = {};
                this._registeredOptions[specifier] = options;
            }
            options[option] = value;
        }
        registeredOption(specifier, option) {
            let result;
            let options = this.registeredOptions(specifier);
            if (options) {
                result = options[option];
            }
            if (result === undefined && this._fallback !== undefined) {
                result = this._fallback.registeredOption(specifier, option);
            }
            return result;
        }
        registeredOptions(specifier) {
            let options = this._registeredOptions[specifier];
            if (options === undefined) {
                var _specifier$split = specifier.split(':');

                let type = _specifier$split[0];

                options = this._registeredOptions[type];
            }
            return options;
        }
        unregisterOption(specifier, option) {
            let options = this._registeredOptions[specifier];
            if (options) {
                delete options[option];
            }
        }
        registerInjection(specifier, property, source) {
            let injections = this._registeredInjections[specifier];
            if (injections === undefined) {
                this._registeredInjections[specifier] = injections = [];
            }
            injections.push({
                property,
                source
            });
        }
        registeredInjections(specifier) {
            var _specifier$split2 = specifier.split(':');

            let type = _specifier$split2[0];

            let injections = this._fallback ? this._fallback.registeredInjections(specifier) : [];
            Array.prototype.push.apply(injections, this._registeredInjections[type]);
            Array.prototype.push.apply(injections, this._registeredInjections[specifier]);
            return injections;
        }
    }

    // TODO - use symbol
    const OWNER = '__owner__';
    function getOwner(object) {
        return object[OWNER];
    }
    function setOwner(object, owner) {
        object[OWNER] = owner;
    }

    function expect$2(val, message) {
        if (val === null || val === undefined) throw new Error(message);
        return val;
    }
    function unreachable$2(message = 'unreachable') {
        return new Error(message);
    }

    // import Logger from './logger';
    // let alreadyWarned = false;
    function debugAssert$2(test, msg) {
        // if (!alreadyWarned) {
        //   alreadyWarned = true;
        //   Logger.warn("Don't leave debug assertions on in public builds");
        // }
        if (!test) {
            throw new Error(msg || 'assertion failure');
        }
    }

    const objKeys$2 = Object.keys;

    function assign$2(obj) {
        for (let i = 1; i < arguments.length; i++) {
            let assignment = arguments[i];
            if (assignment === null || typeof assignment !== 'object') continue;
            let keys = objKeys$2(assignment);
            for (let j = 0; j < keys.length; j++) {
                let key = keys[j];
                obj[key] = assignment[key];
            }
        }
        return obj;
    }
    function fillNulls$2(count) {
        let arr = new Array(count);
        for (let i = 0; i < count; i++) {
            arr[i] = null;
        }
        return arr;
    }

    let GUID$2 = 0;
    function initializeGuid$2(object) {
        return object._guid = ++GUID$2;
    }

    function dict$2() {
        return Object.create(null);
    }
    class Stack$3 {
        constructor() {
            this.stack = [];
            this.current = null;
        }
        get size() {
            return this.stack.length;
        }
        push(item) {
            this.current = item;
            this.stack.push(item);
        }
        pop() {
            let item = this.stack.pop();
            let len = this.stack.length;
            this.current = len === 0 ? null : this.stack[len - 1];
            return item === undefined ? null : item;
        }
        isEmpty() {
            return this.stack.length === 0;
        }
    }

    class LinkedList$2 {
        constructor() {
            this.clear();
        }
        head() {
            return this._head;
        }
        tail() {
            return this._tail;
        }
        clear() {
            this._head = this._tail = null;
        }
        toArray() {
            let out = [];
            this.forEachNode(n => out.push(n));
            return out;
        }
        nextNode(node) {
            return node.next;
        }
        forEachNode(callback) {
            let node = this._head;
            while (node !== null) {
                callback(node);
                node = node.next;
            }
        }
        insertBefore(node, reference = null) {
            if (reference === null) return this.append(node);
            if (reference.prev) reference.prev.next = node;else this._head = node;
            node.prev = reference.prev;
            node.next = reference;
            reference.prev = node;
            return node;
        }
        append(node) {
            let tail = this._tail;
            if (tail) {
                tail.next = node;
                node.prev = tail;
                node.next = null;
            } else {
                this._head = node;
            }
            return this._tail = node;
        }
        remove(node) {
            if (node.prev) node.prev.next = node.next;else this._head = node.next;
            if (node.next) node.next.prev = node.prev;else this._tail = node.prev;
            return node;
        }
    }
    class ListSlice$2 {
        constructor(head, tail) {
            this._head = head;
            this._tail = tail;
        }
        forEachNode(callback) {
            let node = this._head;
            while (node !== null) {
                callback(node);
                node = this.nextNode(node);
            }
        }
        head() {
            return this._head;
        }
        tail() {
            return this._tail;
        }
        toArray() {
            let out = [];
            this.forEachNode(n => out.push(n));
            return out;
        }
        nextNode(node) {
            if (node === this._tail) return null;
            return node.next;
        }
    }

    const EMPTY_ARRAY$2 = Object.freeze([]);

    function isTypeSpecifier(specifier) {
        return specifier.indexOf(':') === -1;
    }
    /**
     * A repository of application objects, indexed by type and name.
     *
     * {@link Initializer | Initializers} can add or override objects in the system
     * before the application boots, customizing runtime behavior.
     *
     * @internal
     */
    class ApplicationRegistry {
        constructor(registry, resolver) {
            this._registry = registry;
            this._resolver = resolver;
        }
        register(specifier, factory, options) {
            let normalizedSpecifier = this._toAbsoluteSpecifier(specifier);
            this._registry.register(normalizedSpecifier, factory, options);
        }
        registration(specifier) {
            let normalizedSpecifier = this._toAbsoluteSpecifier(specifier);
            return this._registry.registration(normalizedSpecifier);
        }
        unregister(specifier) {
            let normalizedSpecifier = this._toAbsoluteSpecifier(specifier);
            this._registry.unregister(normalizedSpecifier);
        }
        registerOption(specifier, option, value) {
            let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
            this._registry.registerOption(normalizedSpecifier, option, value);
        }
        registeredOption(specifier, option) {
            let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
            return this._registry.registeredOption(normalizedSpecifier, option);
        }
        registeredOptions(specifier) {
            let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
            return this._registry.registeredOptions(normalizedSpecifier);
        }
        unregisterOption(specifier, option) {
            let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
            this._registry.unregisterOption(normalizedSpecifier, option);
        }
        registerInjection(specifier, property, injection) {
            let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
            let normalizedInjection = this._toAbsoluteSpecifier(injection);
            this._registry.registerInjection(normalizedSpecifier, property, normalizedInjection);
        }
        registeredInjections(specifier) {
            let normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
            return this._registry.registeredInjections(normalizedSpecifier);
        }
        _toAbsoluteSpecifier(specifier, referrer) {
            return this._resolver.identify(specifier, referrer);
        }
        _toAbsoluteOrTypeSpecifier(specifier) {
            if (isTypeSpecifier(specifier)) {
                return specifier;
            } else {
                return this._toAbsoluteSpecifier(specifier);
            }
        }
    }

    class DynamicScope {
        constructor(bucket = null) {
            if (bucket) {
                this.bucket = assign$2({}, bucket);
            } else {
                this.bucket = {};
            }
        }
        get(key) {
            return this.bucket[key];
        }
        set(key, reference) {
            return this.bucket[key] = reference;
        }
        child() {
            return new DynamicScope(this.bucket);
        }
    }

    // these import bindings will be stripped from build

    class AppendOpcodes$1 {
        constructor() {
            this.evaluateOpcode = fillNulls$2(98 /* Size */).slice();
        }
        add(name, evaluate, kind = 'syscall') {
            this.evaluateOpcode[name] = { syscall: kind === 'syscall', evaluate };
        }
        debugBefore(vm, opcode, type) {
            
            let sp;
            let state;

            return { sp: sp, state };
        }
        debugAfter(vm, opcode, type, pre) {
            let expectedChange;
            let sp = pre.sp,
                state = pre.state;

            let metadata = null;
            if (metadata !== null) {
                if (typeof metadata.stackChange === 'number') {
                    expectedChange = metadata.stackChange;
                } else {
                    expectedChange = metadata.stackChange({ opcode, constants: vm.constants, state });
                    if (isNaN(expectedChange)) throw unreachable$2();
                }
            }
            
        }
        evaluate(vm, opcode, type) {
            let operation = this.evaluateOpcode[type];
            if (operation.syscall) {

                operation.evaluate(vm, opcode);
            } else {

                operation.evaluate(vm.inner, opcode);
            }
        }
    }
    const APPEND_OPCODES$1 = new AppendOpcodes$1();
    class AbstractOpcode$1 {
        constructor() {
            initializeGuid$2(this);
        }
    }
    class UpdatingOpcode$1 extends AbstractOpcode$1 {
        constructor() {
            super(...arguments);
            this.next = null;
            this.prev = null;
        }
    }

    /**
     * Registers
     *
     * For the most part, these follows MIPS naming conventions, however the
     * register numbers are different.
     */
    var Register$1;
    (function (Register) {
        // $0 or $pc (program counter): pointer into `program` for the next insturction; -1 means exit
        Register[Register["pc"] = 0] = "pc";
        // $1 or $ra (return address): pointer into `program` for the return
        Register[Register["ra"] = 1] = "ra";
        // $2 or $fp (frame pointer): pointer into the `evalStack` for the base of the stack
        Register[Register["fp"] = 2] = "fp";
        // $3 or $sp (stack pointer): pointer into the `evalStack` for the top of the stack
        Register[Register["sp"] = 3] = "sp";
        // $4-$5 or $s0-$s1 (saved): callee saved general-purpose registers
        Register[Register["s0"] = 4] = "s0";
        Register[Register["s1"] = 5] = "s1";
        // $6-$7 or $t0-$t1 (temporaries): caller saved general-purpose registers
        Register[Register["t0"] = 6] = "t0";
        Register[Register["t1"] = 7] = "t1";
        // $8 or $v0 (return value)
        Register[Register["v0"] = 8] = "v0";
    })(Register$1 || (Register$1 = {}));

    class PrimitiveReference$1 extends ConstReference {
        constructor(value) {
            super(value);
        }
        static create(value) {
            if (value === undefined) {
                return UNDEFINED_REFERENCE$1;
            } else if (value === null) {
                return NULL_REFERENCE$1;
            } else if (value === true) {
                return TRUE_REFERENCE$1;
            } else if (value === false) {
                return FALSE_REFERENCE$1;
            } else if (typeof value === 'number') {
                return new ValueReference$1(value);
            } else {
                return new StringReference$1(value);
            }
        }
        get(_key) {
            return UNDEFINED_REFERENCE$1;
        }
    }
    class StringReference$1 extends PrimitiveReference$1 {
        constructor() {
            super(...arguments);
            this.lengthReference = null;
        }
        get(key) {
            if (key === 'length') {
                let lengthReference = this.lengthReference;

                if (lengthReference === null) {
                    lengthReference = this.lengthReference = new ValueReference$1(this.inner.length);
                }
                return lengthReference;
            } else {
                return super.get(key);
            }
        }
    }
    class ValueReference$1 extends PrimitiveReference$1 {
        constructor(value) {
            super(value);
        }
    }
    const UNDEFINED_REFERENCE$1 = new ValueReference$1(undefined);
    const NULL_REFERENCE$1 = new ValueReference$1(null);
    const TRUE_REFERENCE$1 = new ValueReference$1(true);
    const FALSE_REFERENCE$1 = new ValueReference$1(false);
    class ConditionalReference$2 {
        constructor(inner) {
            this.inner = inner;
            this.tag = inner.tag;
        }
        value() {
            return this.toBool(this.inner.value());
        }
        toBool(value) {
            return !!value;
        }
    }

    class ConcatReference$1 extends CachedReference {
        constructor(parts) {
            super();
            this.parts = parts;
            this.tag = combineTagged(parts);
        }
        compute() {
            let parts = new Array();
            for (let i = 0; i < this.parts.length; i++) {
                let value = this.parts[i].value();
                if (value !== null && value !== undefined) {
                    parts[i] = castToString$1(value);
                }
            }
            if (parts.length > 0) {
                return parts.join('');
            }
            return null;
        }
    }
    function castToString$1(value) {
        if (typeof value.toString !== 'function') {
            return '';
        }
        return String(value);
    }

    APPEND_OPCODES$1.add(1 /* Helper */, (vm, { op1: handle }) => {
        let stack = vm.stack;
        let helper = vm.constants.resolveHandle(handle);
        let args = stack.pop();
        let value = helper(vm, args);
        vm.loadValue(Register$1.v0, value);
    });
    APPEND_OPCODES$1.add(6 /* GetVariable */, (vm, { op1: symbol }) => {
        let expr = vm.referenceForSymbol(symbol);
        vm.stack.push(expr);
    });
    APPEND_OPCODES$1.add(4 /* SetVariable */, (vm, { op1: symbol }) => {
        let expr = vm.stack.pop();
        vm.scope().bindSymbol(symbol, expr);
    });
    APPEND_OPCODES$1.add(5 /* SetBlock */, (vm, { op1: symbol }) => {
        let handle = vm.stack.pop();
        let scope = vm.stack.pop(); // FIXME(mmun): shouldn't need to cast this
        let table = vm.stack.pop();
        let block = table ? [handle, scope, table] : null;
        vm.scope().bindBlock(symbol, block);
    });
    APPEND_OPCODES$1.add(96 /* ResolveMaybeLocal */, (vm, { op1: _name }) => {
        let name = vm.constants.getString(_name);
        let locals = vm.scope().getPartialMap();
        let ref = locals[name];
        if (ref === undefined) {
            ref = vm.getSelf().get(name);
        }
        vm.stack.push(ref);
    });
    APPEND_OPCODES$1.add(20 /* RootScope */, (vm, { op1: symbols, op2: bindCallerScope }) => {
        vm.pushRootScope(symbols, !!bindCallerScope);
    });
    APPEND_OPCODES$1.add(7 /* GetProperty */, (vm, { op1: _key }) => {
        let key = vm.constants.getString(_key);
        let expr = vm.stack.pop();
        vm.stack.push(expr.get(key));
    });
    APPEND_OPCODES$1.add(8 /* GetBlock */, (vm, { op1: _block }) => {
        let stack = vm.stack;

        let block = vm.scope().getBlock(_block);
        if (block) {
            stack.push(block[2]);
            stack.push(block[1]);
            stack.push(block[0]);
        } else {
            stack.push(null);
            stack.push(null);
            stack.push(null);
        }
    });
    APPEND_OPCODES$1.add(9 /* HasBlock */, (vm, { op1: _block }) => {
        let hasBlock = !!vm.scope().getBlock(_block);
        vm.stack.push(hasBlock ? TRUE_REFERENCE$1 : FALSE_REFERENCE$1);
    });
    APPEND_OPCODES$1.add(10 /* HasBlockParams */, vm => {
        // FIXME(mmun): should only need to push the symbol table
        let block = vm.stack.pop();
        let scope = vm.stack.pop();

        let table = vm.stack.pop();

        let hasBlockParams = table && table.parameters.length;
        vm.stack.push(hasBlockParams ? TRUE_REFERENCE$1 : FALSE_REFERENCE$1);
    });
    APPEND_OPCODES$1.add(11 /* Concat */, (vm, { op1: count }) => {
        let out = new Array(count);
        for (let i = count; i > 0; i--) {
            let offset = i - 1;
            out[offset] = vm.stack.pop();
        }
        vm.stack.push(new ConcatReference$1(out));
    });

    const CURRIED_COMPONENT_DEFINITION_BRAND$1 = 'CURRIED COMPONENT DEFINITION [id=6f00feb9-a0ef-4547-99ea-ac328f80acea]';
    function isCurriedComponentDefinition$1(definition) {
        return !!(definition && definition[CURRIED_COMPONENT_DEFINITION_BRAND$1]);
    }
    function isComponentDefinition$1(definition) {
        return definition && definition[CURRIED_COMPONENT_DEFINITION_BRAND$1];
    }
    class CurriedComponentDefinition$1 {
        /** @internal */
        constructor(inner, args) {
            this.inner = inner;
            this.args = args;
            this[CURRIED_COMPONENT_DEFINITION_BRAND$1] = true;
        }
        unwrap(args) {
            args.realloc(this.offset);
            let definition = this;
            while (true) {
                var _definition = definition;
                let curriedArgs = _definition.args,
                    inner = _definition.inner;

                if (curriedArgs) {
                    args.positional.prepend(curriedArgs.positional);
                    args.named.merge(curriedArgs.named);
                }
                if (!isCurriedComponentDefinition$1(inner)) {
                    return inner;
                }
                definition = inner;
            }
        }
        /** @internal */
        get offset() {
            let inner = this.inner,
                args = this.args;

            let length = args ? args.positional.length : 0;
            return isCurriedComponentDefinition$1(inner) ? length + inner.offset : length;
        }
    }

    function normalizeStringValue$1(value) {
        if (isEmpty$2(value)) {
            return '';
        }
        return String(value);
    }
    function shouldCoerce$1(value) {
        return isString$1(value) || isEmpty$2(value) || typeof value === 'boolean' || typeof value === 'number';
    }
    function isEmpty$2(value) {
        return value === null || value === undefined || typeof value.toString !== 'function';
    }
    function isSafeString$1(value) {
        return typeof value === 'object' && value !== null && typeof value.toHTML === 'function';
    }
    function isNode$1(value) {
        return typeof value === 'object' && value !== null && typeof value.nodeType === 'number';
    }
    function isFragment$1(value) {
        return isNode$1(value) && value.nodeType === 11;
    }
    function isString$1(value) {
        return typeof value === 'string';
    }

    class DynamicTextContent$1 extends UpdatingOpcode$1 {
        constructor(node, reference, lastValue) {
            super();
            this.node = node;
            this.reference = reference;
            this.lastValue = lastValue;
            this.type = 'dynamic-text';
            this.tag = reference.tag;
            this.lastRevision = this.tag.value();
        }
        evaluate() {
            let reference = this.reference,
                tag = this.tag;

            if (!tag.validate(this.lastRevision)) {
                this.lastRevision = tag.value();
                this.update(reference.value());
            }
        }
        update(value) {
            let lastValue = this.lastValue;

            if (value === lastValue) return;
            let normalized;
            if (isEmpty$2(value)) {
                normalized = '';
            } else if (isString$1(value)) {
                normalized = value;
            } else {
                normalized = String(value);
            }
            if (normalized !== lastValue) {
                let textNode = this.node;
                textNode.nodeValue = this.lastValue = normalized;
            }
        }
    }

    class IsCurriedComponentDefinitionReference$1 extends ConditionalReference$2 {
        static create(inner) {
            return new IsCurriedComponentDefinitionReference$1(inner);
        }
        toBool(value) {
            return isCurriedComponentDefinition$1(value);
        }
    }
    class ContentTypeReference$1 {
        constructor(inner) {
            this.inner = inner;
            this.tag = inner.tag;
        }
        value() {
            let value = this.inner.value();
            if (shouldCoerce$1(value)) {
                return 1 /* String */;
            } else if (isComponentDefinition$1(value)) {
                return 0 /* Component */;
            } else if (isSafeString$1(value)) {
                return 3 /* SafeString */;
            } else if (isFragment$1(value)) {
                return 4 /* Fragment */;
            } else if (isNode$1(value)) {
                return 5 /* Node */;
            } else {
                    return 1 /* String */;
                }
        }
    }
    APPEND_OPCODES$1.add(28 /* AppendHTML */, vm => {
        let reference = vm.stack.pop();
        let rawValue = reference.value();
        let value = isEmpty$2(rawValue) ? '' : String(rawValue);
        vm.elements().appendDynamicHTML(value);
    });
    APPEND_OPCODES$1.add(29 /* AppendSafeHTML */, vm => {
        let reference = vm.stack.pop();
        let rawValue = reference.value().toHTML();
        let value = isEmpty$2(rawValue) ? '' : rawValue;
        vm.elements().appendDynamicHTML(value);
    });
    APPEND_OPCODES$1.add(32 /* AppendText */, vm => {
        let reference = vm.stack.pop();
        let rawValue = reference.value();
        let value = isEmpty$2(rawValue) ? '' : String(rawValue);
        let node = vm.elements().appendDynamicText(value);
        if (!isConst(reference)) {
            vm.updateWith(new DynamicTextContent$1(node, reference, value));
        }
    });
    APPEND_OPCODES$1.add(30 /* AppendDocumentFragment */, vm => {
        let reference = vm.stack.pop();
        let value = reference.value();
        vm.elements().appendDynamicFragment(value);
    });
    APPEND_OPCODES$1.add(31 /* AppendNode */, vm => {
        let reference = vm.stack.pop();
        let value = reference.value();
        vm.elements().appendDynamicNode(value);
    });

    APPEND_OPCODES$1.add(22 /* ChildScope */, vm => vm.pushChildScope());
    APPEND_OPCODES$1.add(23 /* PopScope */, vm => vm.popScope());
    APPEND_OPCODES$1.add(44 /* PushDynamicScope */, vm => vm.pushDynamicScope());
    APPEND_OPCODES$1.add(45 /* PopDynamicScope */, vm => vm.popDynamicScope());
    APPEND_OPCODES$1.add(12 /* Constant */, (vm, { op1: other }) => {
        vm.stack.push(vm.constants.getOther(other));
    });
    APPEND_OPCODES$1.add(13 /* Primitive */, (vm, { op1: primitive }) => {
        let stack = vm.stack;
        let flag = primitive & 7; // 111
        let value = primitive >> 3;
        switch (flag) {
            case 0 /* NUMBER */:
                stack.push(value);
                break;
            case 1 /* FLOAT */:
                stack.push(vm.constants.getNumber(value));
                break;
            case 2 /* STRING */:
                stack.push(vm.constants.getString(value));
                break;
            case 3 /* BOOLEAN_OR_VOID */:
                stack.pushEncodedImmediate(primitive);
                break;
            case 4 /* NEGATIVE */:
                stack.push(vm.constants.getNumber(value));
                break;
            case 5 /* BIG_NUM */:
                stack.push(vm.constants.getNumber(value));
                break;
        }
    });
    APPEND_OPCODES$1.add(14 /* PrimitiveReference */, vm => {
        let stack = vm.stack;
        stack.push(PrimitiveReference$1.create(stack.pop()));
    });
    APPEND_OPCODES$1.add(15 /* ReifyU32 */, vm => {
        let stack = vm.stack;
        stack.push(stack.peek().value());
    });
    APPEND_OPCODES$1.add(16 /* Dup */, (vm, { op1: register, op2: offset }) => {
        let position = vm.fetchValue(register) - offset;
        vm.stack.dup(position);
    });
    APPEND_OPCODES$1.add(17 /* Pop */, (vm, { op1: count }) => {
        vm.stack.pop(count);
    });
    APPEND_OPCODES$1.add(18 /* Load */, (vm, { op1: register }) => {
        vm.load(register);
    });
    APPEND_OPCODES$1.add(19 /* Fetch */, (vm, { op1: register }) => {
        vm.fetch(register);
    });
    APPEND_OPCODES$1.add(43 /* BindDynamicScope */, (vm, { op1: _names }) => {
        let names = vm.constants.getArray(_names);
        vm.bindDynamicScope(names);
    });
    APPEND_OPCODES$1.add(61 /* Enter */, (vm, { op1: args }) => {
        vm.enter(args);
    });
    APPEND_OPCODES$1.add(62 /* Exit */, vm => {
        vm.exit();
    });
    APPEND_OPCODES$1.add(48 /* PushSymbolTable */, (vm, { op1: _table }) => {
        let stack = vm.stack;
        stack.push(vm.constants.getSerializable(_table));
    });
    APPEND_OPCODES$1.add(47 /* PushBlockScope */, vm => {
        let stack = vm.stack;
        stack.push(vm.scope());
    });
    APPEND_OPCODES$1.add(46 /* CompileBlock */, vm => {
        let stack = vm.stack;
        let block = stack.pop();
        if (block) {
            stack.pushSmi(block.compile());
        } else {
            stack.pushNull();
        }
    });
    APPEND_OPCODES$1.add(51 /* InvokeYield */, vm => {
        let stack = vm.stack;

        let handle = stack.pop();
        let scope = stack.pop(); // FIXME(mmun): shouldn't need to cast this
        let table = stack.pop();

        let args = stack.pop();
        if (table === null) {
            // To balance the pop{Frame,Scope}
            vm.pushFrame();
            vm.pushScope(scope); // Could be null but it doesnt matter as it is immediatelly popped.
            return;
        }
        let invokingScope = scope;
        // If necessary, create a child scope
        {
            let locals = table.parameters;
            let localsCount = locals.length;
            if (localsCount > 0) {
                invokingScope = invokingScope.child();
                for (let i = 0; i < localsCount; i++) {
                    invokingScope.bindSymbol(locals[i], args.at(i));
                }
            }
        }
        vm.pushFrame();
        vm.pushScope(invokingScope);
        vm.call(handle);
    });
    APPEND_OPCODES$1.add(53 /* JumpIf */, (vm, { op1: target }) => {
        let reference = vm.stack.pop();
        if (isConst(reference)) {
            if (reference.value()) {
                vm.goto(target);
            }
        } else {
            let cache = new ReferenceCache(reference);
            if (cache.peek()) {
                vm.goto(target);
            }
            vm.updateWith(new Assert$1(cache));
        }
    });
    APPEND_OPCODES$1.add(54 /* JumpUnless */, (vm, { op1: target }) => {
        let reference = vm.stack.pop();
        if (isConst(reference)) {
            if (!reference.value()) {
                vm.goto(target);
            }
        } else {
            let cache = new ReferenceCache(reference);
            if (!cache.peek()) {
                vm.goto(target);
            }
            vm.updateWith(new Assert$1(cache));
        }
    });
    APPEND_OPCODES$1.add(55 /* JumpEq */, (vm, { op1: target, op2: comparison }) => {
        let other = vm.stack.peek();
        if (other === comparison) {
            vm.goto(target);
        }
    });
    APPEND_OPCODES$1.add(56 /* AssertSame */, vm => {
        let reference = vm.stack.peek();
        if (!isConst(reference)) {
            vm.updateWith(Assert$1.initialize(new ReferenceCache(reference)));
        }
    });
    APPEND_OPCODES$1.add(63 /* ToBoolean */, vm => {
        let env = vm.env,
            stack = vm.stack;

        stack.push(env.toConditionalReference(stack.pop()));
    });
    class Assert$1 extends UpdatingOpcode$1 {
        constructor(cache) {
            super();
            this.type = 'assert';
            this.tag = cache.tag;
            this.cache = cache;
        }
        static initialize(cache) {
            let assert = new Assert$1(cache);
            cache.peek();
            return assert;
        }
        evaluate(vm) {
            let cache = this.cache;

            if (isModified(cache.revalidate())) {
                vm.throw();
            }
        }
    }
    class JumpIfNotModifiedOpcode$1 extends UpdatingOpcode$1 {
        constructor(tag, target) {
            super();
            this.target = target;
            this.type = 'jump-if-not-modified';
            this.tag = tag;
            this.lastRevision = tag.value();
        }
        evaluate(vm) {
            let tag = this.tag,
                target = this.target,
                lastRevision = this.lastRevision;

            if (!vm.alwaysRevalidate && tag.validate(lastRevision)) {
                vm.goto(target);
            }
        }
        didModify() {
            this.lastRevision = this.tag.value();
        }
    }
    class DidModifyOpcode$1 extends UpdatingOpcode$1 {
        constructor(target) {
            super();
            this.target = target;
            this.type = 'did-modify';
            this.tag = CONSTANT_TAG;
        }
        evaluate() {
            this.target.didModify();
        }
    }
    class LabelOpcode$1 {
        constructor(label) {
            this.tag = CONSTANT_TAG;
            this.type = 'label';
            this.label = null;
            this.prev = null;
            this.next = null;
            initializeGuid$2(this);
            this.label = label;
        }
        evaluate() {}
        inspect() {
            return `${this.label} [${this._guid}]`;
        }
    }

    APPEND_OPCODES$1.add(26 /* Text */, (vm, { op1: text }) => {
        vm.elements().appendText(vm.constants.getString(text));
    });
    APPEND_OPCODES$1.add(27 /* Comment */, (vm, { op1: text }) => {
        vm.elements().appendComment(vm.constants.getString(text));
    });
    APPEND_OPCODES$1.add(33 /* OpenElement */, (vm, { op1: tag }) => {
        vm.elements().openElement(vm.constants.getString(tag));
    });
    APPEND_OPCODES$1.add(34 /* OpenDynamicElement */, vm => {
        let tagName = vm.stack.pop().value();
        vm.elements().openElement(tagName);
    });
    APPEND_OPCODES$1.add(41 /* PushRemoteElement */, vm => {
        let elementRef = vm.stack.pop();
        let nextSiblingRef = vm.stack.pop();
        let guidRef = vm.stack.pop();
        let element;
        let nextSibling;
        let guid = guidRef.value();
        if (isConst(elementRef)) {
            element = elementRef.value();
        } else {
            let cache = new ReferenceCache(elementRef);
            element = cache.peek();
            vm.updateWith(new Assert$1(cache));
        }
        if (isConst(nextSiblingRef)) {
            nextSibling = nextSiblingRef.value();
        } else {
            let cache = new ReferenceCache(nextSiblingRef);
            nextSibling = cache.peek();
            vm.updateWith(new Assert$1(cache));
        }
        vm.elements().pushRemoteElement(element, guid, nextSibling);
    });
    APPEND_OPCODES$1.add(42 /* PopRemoteElement */, vm => {
        vm.elements().popRemoteElement();
    });
    APPEND_OPCODES$1.add(38 /* FlushElement */, vm => {
        let operations = vm.fetchValue(Register$1.t0);
        if (operations) {
            operations.flush(vm);
            vm.loadValue(Register$1.t0, null);
        }
        vm.elements().flushElement();
    });
    APPEND_OPCODES$1.add(39 /* CloseElement */, vm => {
        vm.elements().closeElement();
    });
    APPEND_OPCODES$1.add(40 /* Modifier */, (vm, { op1: handle }) => {
        let manager = vm.constants.resolveHandle(handle);
        let stack = vm.stack;
        let args = stack.pop();

        var _vm$elements = vm.elements();

        let element = _vm$elements.constructing,
            updateOperations = _vm$elements.updateOperations;

        let dynamicScope = vm.dynamicScope();
        let modifier = manager.create(element, args, dynamicScope, updateOperations);
        vm.env.scheduleInstallModifier(modifier, manager);
        let destructor = manager.getDestructor(modifier);
        if (destructor) {
            vm.newDestroyable(destructor);
        }
        let tag = manager.getTag(modifier);
        if (!isConstTag(tag)) {
            vm.updateWith(new UpdateModifierOpcode$1(tag, manager, modifier));
        }
    });
    class UpdateModifierOpcode$1 extends UpdatingOpcode$1 {
        constructor(tag, manager, modifier) {
            super();
            this.tag = tag;
            this.manager = manager;
            this.modifier = modifier;
            this.type = 'update-modifier';
            this.lastUpdated = tag.value();
        }
        evaluate(vm) {
            let manager = this.manager,
                modifier = this.modifier,
                tag = this.tag,
                lastUpdated = this.lastUpdated;

            if (!tag.validate(lastUpdated)) {
                vm.env.scheduleUpdateModifier(modifier, manager);
                this.lastUpdated = tag.value();
            }
        }
    }
    APPEND_OPCODES$1.add(35 /* StaticAttr */, (vm, { op1: _name, op2: _value, op3: _namespace }) => {
        let name = vm.constants.getString(_name);
        let value = vm.constants.getString(_value);
        let namespace = _namespace ? vm.constants.getString(_namespace) : null;
        vm.elements().setStaticAttribute(name, value, namespace);
    });
    APPEND_OPCODES$1.add(36 /* DynamicAttr */, (vm, { op1: _name, op2: trusting, op3: _namespace }) => {
        let name = vm.constants.getString(_name);
        let reference = vm.stack.pop();
        let value = reference.value();
        let namespace = _namespace ? vm.constants.getString(_namespace) : null;
        let attribute = vm.elements().setDynamicAttribute(name, value, !!trusting, namespace);
        if (!isConst(reference)) {
            vm.updateWith(new UpdateDynamicAttributeOpcode$1(reference, attribute));
        }
    });
    class UpdateDynamicAttributeOpcode$1 extends UpdatingOpcode$1 {
        constructor(reference, attribute) {
            super();
            this.reference = reference;
            this.attribute = attribute;
            this.type = 'patch-element';
            this.tag = reference.tag;
            this.lastRevision = this.tag.value();
        }
        evaluate(vm) {
            let attribute = this.attribute,
                reference = this.reference,
                tag = this.tag;

            if (!tag.validate(this.lastRevision)) {
                this.lastRevision = tag.value();
                attribute.update(reference.value(), vm.env);
            }
        }
    }

    function resolveComponent$1(resolver, name, meta) {
        let definition = resolver.lookupComponentDefinition(name, meta);

        return definition;
    }

    class CurryComponentReference$1 {
        constructor(inner, resolver, meta, args) {
            this.inner = inner;
            this.resolver = resolver;
            this.meta = meta;
            this.args = args;
            this.tag = inner.tag;
            this.lastValue = null;
            this.lastDefinition = null;
        }
        value() {
            let inner = this.inner,
                lastValue = this.lastValue;

            let value = inner.value();
            if (value === lastValue) {
                return this.lastDefinition;
            }
            let definition = null;
            if (isCurriedComponentDefinition$1(value)) {
                definition = value;
            } else if (typeof value === 'string' && value) {
                let resolver = this.resolver,
                    meta = this.meta;

                definition = resolveComponent$1(resolver, value, meta);
            }
            definition = this.curry(definition);
            this.lastValue = value;
            this.lastDefinition = definition;
            return definition;
        }
        get() {
            return UNDEFINED_REFERENCE$1;
        }
        curry(definition) {
            let args = this.args;

            if (!args && isCurriedComponentDefinition$1(definition)) {
                return definition;
            } else if (!definition) {
                return null;
            } else {
                return new CurriedComponentDefinition$1(definition, args);
            }
        }
    }

    class ClassListReference$1 {
        constructor(list) {
            this.list = list;
            this.tag = combineTagged(list);
            this.list = list;
        }
        value() {
            let ret = [];
            let list = this.list;

            for (let i = 0; i < list.length; i++) {
                let value = normalizeStringValue$1(list[i].value());
                if (value) ret.push(value);
            }
            return ret.length === 0 ? null : ret.join(' ');
        }
    }

    /**
     * Converts a ComponentCapabilities object into a 32-bit integer representation.
     */
    function capabilityFlagsFrom$1(capabilities) {
        return 0 | (capabilities.dynamicLayout ? 1 /* DynamicLayout */ : 0) | (capabilities.dynamicTag ? 2 /* DynamicTag */ : 0) | (capabilities.prepareArgs ? 4 /* PrepareArgs */ : 0) | (capabilities.createArgs ? 8 /* CreateArgs */ : 0) | (capabilities.attributeHook ? 16 /* AttributeHook */ : 0) | (capabilities.elementHook ? 32 /* ElementHook */ : 0) | (capabilities.dynamicScope ? 64 /* DynamicScope */ : 0) | (capabilities.createCaller ? 128 /* CreateCaller */ : 0) | (capabilities.updateHook ? 256 /* UpdateHook */ : 0) | (capabilities.createInstance ? 512 /* CreateInstance */ : 0);
    }
    function hasCapability$1(capabilities, capability) {
        return !!(capabilities & capability);
    }

    APPEND_OPCODES$1.add(69 /* IsComponent */, vm => {
        let stack = vm.stack;
        let ref = stack.pop();
        stack.push(IsCurriedComponentDefinitionReference$1.create(ref));
    });
    APPEND_OPCODES$1.add(70 /* ContentType */, vm => {
        let stack = vm.stack;
        let ref = stack.peek();
        stack.push(new ContentTypeReference$1(ref));
    });
    APPEND_OPCODES$1.add(71 /* CurryComponent */, (vm, { op1: _meta }) => {
        let stack = vm.stack;
        let definition = stack.pop();
        let capturedArgs = stack.pop();
        let meta = vm.constants.getSerializable(_meta);
        let resolver = vm.constants.resolver;
        vm.loadValue(Register$1.v0, new CurryComponentReference$1(definition, resolver, meta, capturedArgs));
        // expectStackChange(vm.stack, -args.length - 1, 'CurryComponent');
    });
    APPEND_OPCODES$1.add(72 /* PushComponentDefinition */, (vm, { op1: handle }) => {
        let definition = vm.constants.resolveHandle(handle);

        let manager = definition.manager;

        let capabilities = capabilityFlagsFrom$1(manager.getCapabilities(definition.state));
        let instance = {
            definition,
            manager,
            capabilities,
            state: null,
            handle: null,
            table: null,
            lookup: null
        };
        vm.stack.push(instance);
    });
    APPEND_OPCODES$1.add(75 /* ResolveDynamicComponent */, (vm, { op1: _meta }) => {
        let stack = vm.stack;
        let component = stack.pop().value();
        let meta = vm.constants.getSerializable(_meta);
        vm.loadValue(Register$1.t1, null); // Clear the temp register
        let definition;
        if (typeof component === 'string') {
            let resolver = vm.constants.resolver;

            let resolvedDefinition = resolveComponent$1(resolver, component, meta);
            definition = resolvedDefinition;
        } else if (isCurriedComponentDefinition$1(component)) {
            definition = component;
        } else {
            throw unreachable$2();
        }
        stack.push(definition);
    });
    APPEND_OPCODES$1.add(73 /* PushDynamicComponentInstance */, vm => {
        let stack = vm.stack;

        let definition = stack.pop();
        let capabilities, manager;
        if (isCurriedComponentDefinition$1(definition)) {
            manager = capabilities = null;
        } else {
            manager = definition.manager;
            capabilities = capabilityFlagsFrom$1(manager.getCapabilities(definition.state));
        }
        stack.push({ definition, capabilities, manager, state: null, handle: null, table: null });
    });
    APPEND_OPCODES$1.add(74 /* PushCurriedComponent */, (vm, { op1: _meta }) => {
        let stack = vm.stack;
        let component = stack.pop().value();
        let definition;
        if (isCurriedComponentDefinition$1(component)) {
            definition = component;
        } else {
            throw unreachable$2();
        }
        stack.push(definition);
    });
    APPEND_OPCODES$1.add(76 /* PushArgs */, (vm, { op1: _names, op2: flags }) => {
        let stack = vm.stack;
        let names = vm.constants.getStringArray(_names);
        let positionalCount = flags >> 4;
        let synthetic = flags & 0b1000;
        let blockNames = [];
        if (flags & 0b0100) blockNames.push('main');
        if (flags & 0b0010) blockNames.push('else');
        if (flags & 0b0001) blockNames.push('attrs');
        vm.args.setup(stack, names, blockNames, positionalCount, !!synthetic);
        stack.push(vm.args);
    });
    APPEND_OPCODES$1.add(77 /* PushEmptyArgs */, vm => {
        let stack = vm.stack;

        stack.push(vm.args.empty(stack));
    });
    APPEND_OPCODES$1.add(80 /* CaptureArgs */, vm => {
        let stack = vm.stack;
        let args = stack.pop();
        let capturedArgs = args.capture();
        stack.push(capturedArgs);
    });
    APPEND_OPCODES$1.add(79 /* PrepareArgs */, (vm, { op1: _state }) => {
        let stack = vm.stack;
        let instance = vm.fetchValue(_state);
        let args = stack.pop();
        let definition = instance.definition;

        if (isCurriedComponentDefinition$1(definition)) {

            definition = resolveCurriedComponentDefinition$1(instance, definition, args);
        }
        var _definition = definition;
        let manager = _definition.manager,
            state = _definition.state;

        let capabilities = instance.capabilities;
        if (hasCapability$1(capabilities, 4 /* PrepareArgs */) !== true) {
            stack.push(args);
            return;
        }
        let blocks = args.blocks.values;
        let blockNames = args.blocks.names;
        let preparedArgs = manager.prepareArgs(state, args);
        if (preparedArgs) {
            args.clear();
            for (let i = 0; i < blocks.length; i++) {
                stack.push(blocks[i]);
            }
            let positional = preparedArgs.positional,
                named = preparedArgs.named;

            let positionalCount = positional.length;
            for (let i = 0; i < positionalCount; i++) {
                stack.push(positional[i]);
            }
            let names = Object.keys(named);
            for (let i = 0; i < names.length; i++) {
                stack.push(named[names[i]]);
            }
            args.setup(stack, names, blockNames, positionalCount, true);
        }
        stack.push(args);
    });
    function resolveCurriedComponentDefinition$1(instance, definition, args) {
        let unwrappedDefinition = instance.definition = definition.unwrap(args);
        let manager = unwrappedDefinition.manager,
            state = unwrappedDefinition.state;

        instance.manager = manager;
        instance.capabilities = capabilityFlagsFrom$1(manager.getCapabilities(state));
        return unwrappedDefinition;
    }
    APPEND_OPCODES$1.add(81 /* CreateComponent */, (vm, { op1: flags, op2: _state }) => {
        let instance = vm.fetchValue(_state);
        let definition = instance.definition,
            manager = instance.manager;

        let capabilities = instance.capabilities = capabilityFlagsFrom$1(manager.getCapabilities(definition.state));
        let dynamicScope = null;
        if (hasCapability$1(capabilities, 64 /* DynamicScope */)) {
            dynamicScope = vm.dynamicScope();
        }
        let hasDefaultBlock = flags & 1;
        let args = null;
        if (hasCapability$1(capabilities, 8 /* CreateArgs */)) {
            args = vm.stack.peek();
        }
        let self = null;
        if (hasCapability$1(capabilities, 128 /* CreateCaller */)) {
            self = vm.getSelf();
        }
        let state = manager.create(vm.env, definition.state, args, dynamicScope, self, !!hasDefaultBlock);
        // We want to reuse the `state` POJO here, because we know that the opcodes
        // only transition at exactly one place.
        instance.state = state;
        let tag = manager.getTag(state);
        if (hasCapability$1(capabilities, 256 /* UpdateHook */) && !isConstTag(tag)) {
            vm.updateWith(new UpdateComponentOpcode$1(tag, state, manager, dynamicScope));
        }
    });
    APPEND_OPCODES$1.add(82 /* RegisterComponentDestructor */, (vm, { op1: _state }) => {
        var _vm$fetchValue = vm.fetchValue(_state);

        let manager = _vm$fetchValue.manager,
            state = _vm$fetchValue.state;

        let destructor = manager.getDestructor(state);
        if (destructor) vm.newDestroyable(destructor);
    });
    APPEND_OPCODES$1.add(91 /* BeginComponentTransaction */, vm => {
        vm.beginCacheGroup();
        vm.elements().pushSimpleBlock();
    });
    APPEND_OPCODES$1.add(83 /* PutComponentOperations */, vm => {
        vm.loadValue(Register$1.t0, new ComponentElementOperations$1());
    });
    APPEND_OPCODES$1.add(37 /* ComponentAttr */, (vm, { op1: _name, op2: trusting, op3: _namespace }) => {
        let name = vm.constants.getString(_name);
        let reference = vm.stack.pop();
        let namespace = _namespace ? vm.constants.getString(_namespace) : null;
        vm.fetchValue(Register$1.t0).setAttribute(name, reference, !!trusting, namespace);
    });
    class ComponentElementOperations$1 {
        constructor() {
            this.attributes = dict$2();
            this.classes = [];
        }
        setAttribute(name, value, trusting, namespace) {
            let deferred = { value, namespace, trusting };
            if (name === 'class') {
                this.classes.push(value);
            }
            this.attributes[name] = deferred;
        }
        flush(vm) {
            for (let name in this.attributes) {
                let attr = this.attributes[name];
                let reference = attr.value,
                    namespace = attr.namespace,
                    trusting = attr.trusting;

                if (name === 'class') {
                    reference = new ClassListReference$1(this.classes);
                }
                if (name === 'type') {
                    continue;
                }
                let attribute = vm.elements().setDynamicAttribute(name, reference.value(), trusting, namespace);
                if (!isConst(reference)) {
                    vm.updateWith(new UpdateDynamicAttributeOpcode$1(reference, attribute));
                }
            }
            if ('type' in this.attributes) {
                let type = this.attributes.type;
                let reference = type.value,
                    namespace = type.namespace,
                    trusting = type.trusting;

                let attribute = vm.elements().setDynamicAttribute('type', reference.value(), trusting, namespace);
                if (!isConst(reference)) {
                    vm.updateWith(new UpdateDynamicAttributeOpcode$1(reference, attribute));
                }
            }
        }
    }
    APPEND_OPCODES$1.add(93 /* DidCreateElement */, (vm, { op1: _state }) => {
        var _vm$fetchValue2 = vm.fetchValue(_state);

        let definition = _vm$fetchValue2.definition,
            state = _vm$fetchValue2.state;
        let manager = definition.manager;

        let operations = vm.fetchValue(Register$1.t0);
        let action = 'DidCreateElementOpcode#evaluate';
        manager.didCreateElement(state, vm.elements().expectConstructing(action), operations);
    });
    APPEND_OPCODES$1.add(84 /* GetComponentSelf */, (vm, { op1: _state }) => {
        var _vm$fetchValue3 = vm.fetchValue(_state);

        let definition = _vm$fetchValue3.definition,
            state = _vm$fetchValue3.state;
        let manager = definition.manager;

        vm.stack.push(manager.getSelf(state));
    });
    APPEND_OPCODES$1.add(85 /* GetComponentTagName */, (vm, { op1: _state }) => {
        var _vm$fetchValue4 = vm.fetchValue(_state);

        let definition = _vm$fetchValue4.definition,
            state = _vm$fetchValue4.state;
        let manager = definition.manager;

        vm.stack.push(manager.getTagName(state));
    });
    // Dynamic Invocation Only
    APPEND_OPCODES$1.add(86 /* GetComponentLayout */, (vm, { op1: _state }) => {
        let instance = vm.fetchValue(_state);
        let manager = instance.manager,
            definition = instance.definition;
        let resolver = vm.constants.resolver,
            stack = vm.stack;
        let instanceState = instance.state,
            capabilities = instance.capabilities;
        let definitionState = definition.state;

        let invoke;
        if (hasStaticLayout$2(capabilities, manager)) {
            invoke = manager.getLayout(definitionState, resolver);
        } else if (hasDynamicLayout$2(capabilities, manager)) {
            invoke = manager.getDynamicLayout(instanceState, resolver);
        } else {
            throw unreachable$2();
        }
        stack.push(invoke.symbolTable);
        stack.push(invoke.handle);
    });
    function hasStaticLayout$2(capabilities, _manager) {
        return hasCapability$1(capabilities, 1 /* DynamicLayout */) === false;
    }
    function hasDynamicLayout$2(capabilities, _manager) {
        return hasCapability$1(capabilities, 1 /* DynamicLayout */) === true;
    }
    APPEND_OPCODES$1.add(68 /* Main */, (vm, { op1: register }) => {
        let definition = vm.stack.pop();
        let invocation = vm.stack.pop();
        let manager = definition.manager;

        let capabilities = capabilityFlagsFrom$1(manager.getCapabilities(definition.state));
        let state = {
            definition,
            manager,
            capabilities,
            state: null,
            handle: invocation.handle,
            table: invocation.symbolTable,
            lookup: null
        };
        vm.loadValue(register, state);
    });
    APPEND_OPCODES$1.add(89 /* PopulateLayout */, (vm, { op1: _state }) => {
        let stack = vm.stack;

        let handle = stack.pop();
        let table = stack.pop();
        let state = vm.fetchValue(_state);
        state.handle = handle;
        state.table = table;
    });
    APPEND_OPCODES$1.add(21 /* VirtualRootScope */, (vm, { op1: _state }) => {
        let symbols = vm.fetchValue(_state).table.symbols;

        vm.pushRootScope(symbols.length + 1, true);
    });
    APPEND_OPCODES$1.add(87 /* SetupForEval */, (vm, { op1: _state }) => {
        let state = vm.fetchValue(_state);
        if (state.table.hasEval) {
            let lookup = state.lookup = dict$2();
            vm.scope().bindEvalScope(lookup);
        }
    });
    APPEND_OPCODES$1.add(2 /* SetNamedVariables */, (vm, { op1: _state }) => {
        let state = vm.fetchValue(_state);
        let scope = vm.scope();
        let args = vm.stack.peek();
        let callerNames = args.named.atNames;
        for (let i = callerNames.length - 1; i >= 0; i--) {
            let atName = callerNames[i];
            let symbol = state.table.symbols.indexOf(callerNames[i]);
            let value = args.named.get(atName, false);
            if (symbol !== -1) scope.bindSymbol(symbol + 1, value);
            if (state.lookup) state.lookup[atName] = value;
        }
    });
    function bindBlock$1(symbolName, blockName, state, blocks, vm) {
        let symbol = state.table.symbols.indexOf(symbolName);
        let block = blocks.get(blockName);
        if (symbol !== -1) {
            vm.scope().bindBlock(symbol + 1, block);
        }
        if (state.lookup) state.lookup[symbolName] = block;
    }
    APPEND_OPCODES$1.add(3 /* SetBlocks */, (vm, { op1: _state }) => {
        let state = vm.fetchValue(_state);

        var _vm$stack$peek = vm.stack.peek();

        let blocks = _vm$stack$peek.blocks;

        bindBlock$1('&attrs', 'attrs', state, blocks, vm);
        bindBlock$1('&inverse', 'else', state, blocks, vm);
        bindBlock$1('&default', 'main', state, blocks, vm);
    });
    // Dynamic Invocation Only
    APPEND_OPCODES$1.add(90 /* InvokeComponentLayout */, (vm, { op1: _state }) => {
        let state = vm.fetchValue(_state);
        vm.call(state.handle);
    });
    APPEND_OPCODES$1.add(94 /* DidRenderLayout */, (vm, { op1: _state }) => {
        var _vm$fetchValue5 = vm.fetchValue(_state);

        let manager = _vm$fetchValue5.manager,
            state = _vm$fetchValue5.state;

        let bounds = vm.elements().popBlock();
        let mgr = manager;
        mgr.didRenderLayout(state, bounds);
        vm.env.didCreate(state, manager);
        vm.updateWith(new DidUpdateLayoutOpcode$1(manager, state, bounds));
    });
    APPEND_OPCODES$1.add(92 /* CommitComponentTransaction */, vm => {
        vm.commitCacheGroup();
    });
    class UpdateComponentOpcode$1 extends UpdatingOpcode$1 {
        constructor(tag, component, manager, dynamicScope) {
            super();
            this.tag = tag;
            this.component = component;
            this.manager = manager;
            this.dynamicScope = dynamicScope;
            this.type = 'update-component';
        }
        evaluate(_vm) {
            let component = this.component,
                manager = this.manager,
                dynamicScope = this.dynamicScope;

            manager.update(component, dynamicScope);
        }
    }
    class DidUpdateLayoutOpcode$1 extends UpdatingOpcode$1 {
        constructor(manager, component, bounds) {
            super();
            this.manager = manager;
            this.component = component;
            this.bounds = bounds;
            this.type = 'did-update-layout';
            this.tag = CONSTANT_TAG;
        }
        evaluate(vm) {
            let manager = this.manager,
                component = this.component,
                bounds = this.bounds;

            manager.didUpdateLayout(component, bounds);
            vm.env.didUpdate(component, manager);
        }
    }

    /* tslint:disable */
    function debugCallback$1(context, get) {
        console.info('Use `context`, and `get(<path>)` to debug this template.');
        // for example...
        context === get('this');
        debugger;
    }
    /* tslint:enable */
    let callback$1 = debugCallback$1;
    class ScopeInspector$1 {
        constructor(scope, symbols, evalInfo) {
            this.scope = scope;
            this.locals = dict$2();
            for (let i = 0; i < evalInfo.length; i++) {
                let slot = evalInfo[i];
                let name = symbols[slot - 1];
                let ref = scope.getSymbol(slot);
                this.locals[name] = ref;
            }
        }
        get(path) {
            let scope = this.scope,
                locals = this.locals;

            let parts = path.split('.');

            var _path$split = path.split('.');

            let head = _path$split[0],
                tail = _path$split.slice(1);

            let evalScope = scope.getEvalScope();
            let ref;
            if (head === 'this') {
                ref = scope.getSelf();
            } else if (locals[head]) {
                ref = locals[head];
            } else if (head.indexOf('@') === 0 && evalScope[head]) {
                ref = evalScope[head];
            } else {
                ref = this.scope.getSelf();
                tail = parts;
            }
            return tail.reduce((r, part) => r.get(part), ref);
        }
    }
    APPEND_OPCODES$1.add(97 /* Debugger */, (vm, { op1: _symbols, op2: _evalInfo }) => {
        let symbols = vm.constants.getStringArray(_symbols);
        let evalInfo = vm.constants.getArray(_evalInfo);
        let inspector = new ScopeInspector$1(vm.scope(), symbols, evalInfo);
        callback$1(vm.getSelf().value(), path => inspector.get(path).value());
    });

    APPEND_OPCODES$1.add(95 /* InvokePartial */, (vm, { op1: _meta, op2: _symbols, op3: _evalInfo }) => {
        let constants = vm.constants,
            resolver = vm.constants.resolver,
            stack = vm.stack;

        let name = stack.pop().value();

        let meta = constants.getSerializable(_meta);
        let outerSymbols = constants.getStringArray(_symbols);
        let evalInfo = constants.getArray(_evalInfo);
        let handle = resolver.lookupPartial(name, meta);

        let definition = resolver.resolve(handle);

        var _definition$getPartia = definition.getPartial();

        let symbolTable = _definition$getPartia.symbolTable,
            vmHandle = _definition$getPartia.handle;

        {
            let partialSymbols = symbolTable.symbols;
            let outerScope = vm.scope();
            let partialScope = vm.pushRootScope(partialSymbols.length, false);
            let evalScope = outerScope.getEvalScope();
            partialScope.bindCallerScope(outerScope.getCallerScope());
            partialScope.bindEvalScope(evalScope);
            partialScope.bindSelf(outerScope.getSelf());
            let locals = Object.create(outerScope.getPartialMap());
            for (let i = 0; i < evalInfo.length; i++) {
                let slot = evalInfo[i];
                let name = outerSymbols[slot - 1];
                let ref = outerScope.getSymbol(slot);
                locals[name] = ref;
            }
            if (evalScope) {
                for (let i = 0; i < partialSymbols.length; i++) {
                    let name = partialSymbols[i];
                    let symbol = i + 1;
                    let value = evalScope[name];
                    if (value !== undefined) partialScope.bind(symbol, value);
                }
            }
            partialScope.bindPartialMap(locals);
            vm.pushFrame(); // sp += 2
            vm.call(vmHandle);
        }
    });

    class IterablePresenceReference$1 {
        constructor(artifacts) {
            this.tag = artifacts.tag;
            this.artifacts = artifacts;
        }
        value() {
            return !this.artifacts.isEmpty();
        }
    }
    APPEND_OPCODES$1.add(66 /* PutIterator */, vm => {
        let stack = vm.stack;
        let listRef = stack.pop();
        let key = stack.pop();
        let iterable = vm.env.iterableFor(listRef, key.value());
        let iterator = new ReferenceIterator(iterable);
        stack.push(iterator);
        stack.push(new IterablePresenceReference$1(iterator.artifacts));
    });
    APPEND_OPCODES$1.add(64 /* EnterList */, (vm, { op1: relativeStart }) => {
        vm.enterList(relativeStart);
    });
    APPEND_OPCODES$1.add(65 /* ExitList */, vm => {
        vm.exitList();
    });
    APPEND_OPCODES$1.add(67 /* Iterate */, (vm, { op1: breaks }) => {
        let stack = vm.stack;
        let item = stack.peek().next();
        if (item) {
            let tryOpcode = vm.iterate(item.memo, item.value);
            vm.enterItem(item.key, tryOpcode);
        } else {
            vm.goto(breaks);
        }
    });

    class Cursor$1 {
        constructor(element, nextSibling) {
            this.element = element;
            this.nextSibling = nextSibling;
        }
    }
    class ConcreteBounds$1 {
        constructor(parentNode, first, last) {
            this.parentNode = parentNode;
            this.first = first;
            this.last = last;
        }
        parentElement() {
            return this.parentNode;
        }
        firstNode() {
            return this.first;
        }
        lastNode() {
            return this.last;
        }
    }
    class SingleNodeBounds$1 {
        constructor(parentNode, node) {
            this.parentNode = parentNode;
            this.node = node;
        }
        parentElement() {
            return this.parentNode;
        }
        firstNode() {
            return this.node;
        }
        lastNode() {
            return this.node;
        }
    }
    function bounds$1(parent, first, last) {
        return new ConcreteBounds$1(parent, first, last);
    }
    function single$1(parent, node) {
        return new SingleNodeBounds$1(parent, node);
    }
    function move$1(bounds, reference) {
        let parent = bounds.parentElement();
        let first = bounds.firstNode();
        let last = bounds.lastNode();
        let node = first;
        while (node) {
            let next = node.nextSibling;
            parent.insertBefore(node, reference);
            if (node === last) return next;
            node = next;
        }
        return null;
    }
    function clear$1(bounds) {
        let parent = bounds.parentElement();
        let first = bounds.firstNode();
        let last = bounds.lastNode();
        let node = first;
        while (node) {
            let next = node.nextSibling;
            parent.removeChild(node);
            if (node === last) return next;
            node = next;
        }
        return null;
    }

    const SVG_NAMESPACE$2 = 'http://www.w3.org/2000/svg';
    // Patch:    insertAdjacentHTML on SVG Fix
    // Browsers: Safari, IE, Edge, Firefox ~33-34
    // Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is
    //           present but throws an exception on IE and Edge. Old versions of
    //           Firefox create nodes in the incorrect namespace.
    // Fix:      Since IE and Edge silently fail to create SVG nodes using
    //           innerHTML, and because Firefox may create nodes in the incorrect
    //           namespace using innerHTML on SVG elements, an HTML-string wrapping
    //           approach is used. A pre/post SVG tag is added to the string, then
    //           that whole string is added to a div. The created nodes are plucked
    //           out and applied to the target location on DOM.
    function applySVGInnerHTMLFix$1(document, DOMClass, svgNamespace) {
        if (!document) return DOMClass;
        if (!shouldApplyFix$2(document, svgNamespace)) {
            return DOMClass;
        }
        let div = document.createElement('div');
        return class DOMChangesWithSVGInnerHTMLFix extends DOMClass {
            insertHTMLBefore(parent, nextSibling, html) {
                if (html === null || html === '') {
                    return super.insertHTMLBefore(parent, nextSibling, html);
                }
                if (parent.namespaceURI !== svgNamespace) {
                    return super.insertHTMLBefore(parent, nextSibling, html);
                }
                return fixSVG$1(parent, div, html, nextSibling);
            }
        };
    }
    function fixSVG$1(parent, div, html, reference) {
        // IE, Edge: also do not correctly support using `innerHTML` on SVG
        // namespaced elements. So here a wrapper is used.
        let wrappedHtml = '<svg>' + html + '</svg>';
        div.innerHTML = wrappedHtml;

        var _moveNodesBefore = moveNodesBefore$1(div.firstChild, parent, reference);

        let first = _moveNodesBefore[0],
            last = _moveNodesBefore[1];

        return new ConcreteBounds$1(parent, first, last);
    }
    function shouldApplyFix$2(document, svgNamespace) {
        let svg = document.createElementNS(svgNamespace, 'svg');
        try {
            svg['insertAdjacentHTML']('beforeend', '<circle></circle>');
        } catch (e) {
            // IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG
            // Safari: Will throw, insertAdjacentHTML is not present on SVG
        } finally {
            // FF: Old versions will create a node in the wrong namespace
            if (svg.childNodes.length === 1 && svg.firstChild.namespaceURI === SVG_NAMESPACE$2) {
                // The test worked as expected, no fix required
                return false;
            }
            return true;
        }
    }

    // Patch:    Adjacent text node merging fix
    // Browsers: IE, Edge, Firefox w/o inspector open
    // Reason:   These browsers will merge adjacent text nodes. For exmaple given
    //           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers
    //           with proper behavior will populate div.childNodes with two items.
    //           These browsers will populate it with one merged node instead.
    // Fix:      Add these nodes to a wrapper element, then iterate the childNodes
    //           of that wrapper and move the nodes to their target location. Note
    //           that potential SVG bugs will have been handled before this fix.
    //           Note that this fix must only apply to the previous text node, as
    //           the base implementation of `insertHTMLBefore` already handles
    //           following text nodes correctly.
    function applyTextNodeMergingFix$1(document, DOMClass) {
        if (!document) return DOMClass;
        if (!shouldApplyFix$3(document)) {
            return DOMClass;
        }
        return class DOMChangesWithTextNodeMergingFix extends DOMClass {
            constructor(document) {
                super(document);
                this.uselessComment = document.createComment('');
            }
            insertHTMLBefore(parent, nextSibling, html) {
                if (html === null) {
                    return super.insertHTMLBefore(parent, nextSibling, html);
                }
                let didSetUselessComment = false;
                let nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;
                if (nextPrevious && nextPrevious instanceof Text) {
                    didSetUselessComment = true;
                    parent.insertBefore(this.uselessComment, nextSibling);
                }
                let bounds = super.insertHTMLBefore(parent, nextSibling, html);
                if (didSetUselessComment) {
                    parent.removeChild(this.uselessComment);
                }
                return bounds;
            }
        };
    }
    function shouldApplyFix$3(document) {
        let mergingTextDiv = document.createElement('div');
        mergingTextDiv.innerHTML = 'first';
        mergingTextDiv.insertAdjacentHTML('beforeend', 'second');
        if (mergingTextDiv.childNodes.length === 2) {
            // It worked as expected, no fix required
            return false;
        }
        return true;
    }

    const SVG_NAMESPACE$3 = 'http://www.w3.org/2000/svg';
    // http://www.w3.org/TR/html/syntax.html#html-integration-point
    const SVG_INTEGRATION_POINTS$1 = { foreignObject: 1, desc: 1, title: 1 };
    // http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes
    // TODO: Adjust SVG attributes
    // http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
    // TODO: Adjust SVG elements
    // http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
    const BLACKLIST_TABLE$1 = Object.create(null);
    ['b', 'big', 'blockquote', 'body', 'br', 'center', 'code', 'dd', 'div', 'dl', 'dt', 'em', 'embed', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'hr', 'i', 'img', 'li', 'listing', 'main', 'meta', 'nobr', 'ol', 'p', 'pre', 'ruby', 's', 'small', 'span', 'strong', 'strike', 'sub', 'sup', 'table', 'tt', 'u', 'ul', 'var'].forEach(tag => BLACKLIST_TABLE$1[tag] = 1);
    let doc$1 = typeof document === 'undefined' ? null : document;
    function moveNodesBefore$1(source, target, nextSibling) {
        let first = source.firstChild;
        let last = null;
        let current = first;
        while (current) {
            last = current;
            current = current.nextSibling;
            target.insertBefore(last, nextSibling);
        }
        return [first, last];
    }
    class DOMOperations$1 {
        constructor(document) {
            this.document = document;
            this.setupUselessElement();
        }
        // split into seperate method so that NodeDOMTreeConstruction
        // can override it.
        setupUselessElement() {
            this.uselessElement = this.document.createElement('div');
        }
        createElement(tag, context) {
            let isElementInSVGNamespace, isHTMLIntegrationPoint;
            if (context) {
                isElementInSVGNamespace = context.namespaceURI === SVG_NAMESPACE$3 || tag === 'svg';
                isHTMLIntegrationPoint = SVG_INTEGRATION_POINTS$1[context.tagName];
            } else {
                isElementInSVGNamespace = tag === 'svg';
                isHTMLIntegrationPoint = false;
            }
            if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {
                // FIXME: This does not properly handle <font> with color, face, or
                // size attributes, which is also disallowed by the spec. We should fix
                // this.
                if (BLACKLIST_TABLE$1[tag]) {
                    throw new Error(`Cannot create a ${tag} inside an SVG context`);
                }
                return this.document.createElementNS(SVG_NAMESPACE$3, tag);
            } else {
                return this.document.createElement(tag);
            }
        }
        insertBefore(parent, node, reference) {
            parent.insertBefore(node, reference);
        }
        insertHTMLBefore(_parent, nextSibling, html) {
            return insertHTMLBefore$1(this.uselessElement, _parent, nextSibling, html);
        }
        createTextNode(text) {
            return this.document.createTextNode(text);
        }
        createComment(data) {
            return this.document.createComment(data);
        }
    }
    var DOM$1;
    (function (DOM) {
        class TreeConstruction extends DOMOperations$1 {
            createElementNS(namespace, tag) {
                return this.document.createElementNS(namespace, tag);
            }
            setAttribute(element, name, value, namespace = null) {
                if (namespace) {
                    element.setAttributeNS(namespace, name, value);
                } else {
                    element.setAttribute(name, value);
                }
            }
        }
        DOM.TreeConstruction = TreeConstruction;
        let appliedTreeContruction = TreeConstruction;
        appliedTreeContruction = applyTextNodeMergingFix$1(doc$1, appliedTreeContruction);
        appliedTreeContruction = applySVGInnerHTMLFix$1(doc$1, appliedTreeContruction, SVG_NAMESPACE$3);
        DOM.DOMTreeConstruction = appliedTreeContruction;
    })(DOM$1 || (DOM$1 = {}));
    class DOMChanges$1 extends DOMOperations$1 {
        constructor(document) {
            super(document);
            this.document = document;
            this.namespace = null;
        }
        setAttribute(element, name, value) {
            element.setAttribute(name, value);
        }
        removeAttribute(element, name) {
            element.removeAttribute(name);
        }
        insertAfter(element, node, reference) {
            this.insertBefore(element, node, reference.nextSibling);
        }
    }
    function insertHTMLBefore$1(useless, _parent, _nextSibling, html) {
        // tslint:disable-line
        // TypeScript vendored an old version of the DOM spec where `insertAdjacentHTML`
        // only exists on `HTMLElement` but not on `Element`. We actually work with the
        // newer version of the DOM API here (and monkey-patch this method in `./compat`
        // when we detect older browsers). This is a hack to work around this limitation.
        let parent = _parent;
        let nextSibling = _nextSibling;
        let prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;
        let last;
        if (html === null || html === '') {
            return new ConcreteBounds$1(parent, null, null);
        }
        if (nextSibling === null) {
            parent.insertAdjacentHTML('beforeend', html);
            last = parent.lastChild;
        } else if (nextSibling instanceof HTMLElement) {
            nextSibling.insertAdjacentHTML('beforebegin', html);
            last = nextSibling.previousSibling;
        } else {
            // Non-element nodes do not support insertAdjacentHTML, so add an
            // element and call it on that element. Then remove the element.
            //
            // This also protects Edge, IE and Firefox w/o the inspector open
            // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts
            parent.insertBefore(useless, nextSibling);
            useless.insertAdjacentHTML('beforebegin', html);
            last = useless.previousSibling;
            parent.removeChild(useless);
        }
        let first = prev ? prev.nextSibling : parent.firstChild;
        return new ConcreteBounds$1(parent, first, last);
    }
    let helper$2 = DOMChanges$1;
    helper$2 = applyTextNodeMergingFix$1(doc$1, helper$2);
    helper$2 = applySVGInnerHTMLFix$1(doc$1, helper$2, SVG_NAMESPACE$3);
    var DOMChanges$2 = helper$2;
    const DOMTreeConstruction$1 = DOM$1.DOMTreeConstruction;

    const badProtocols$1 = ['javascript:', 'vbscript:'];
    const badTags$1 = ['A', 'BODY', 'LINK', 'IMG', 'IFRAME', 'BASE', 'FORM'];
    const badTagsForDataURI$1 = ['EMBED'];
    const badAttributes$1 = ['href', 'src', 'background', 'action'];
    const badAttributesForDataURI$1 = ['src'];
    function has$1(array, item) {
        return array.indexOf(item) !== -1;
    }
    function checkURI$1(tagName, attribute) {
        return (tagName === null || has$1(badTags$1, tagName)) && has$1(badAttributes$1, attribute);
    }
    function checkDataURI$1(tagName, attribute) {
        if (tagName === null) return false;
        return has$1(badTagsForDataURI$1, tagName) && has$1(badAttributesForDataURI$1, attribute);
    }
    function requiresSanitization$1(tagName, attribute) {
        return checkURI$1(tagName, attribute) || checkDataURI$1(tagName, attribute);
    }
    function sanitizeAttributeValue$1(env, element, attribute, value) {
        let tagName = null;
        if (value === null || value === undefined) {
            return value;
        }
        if (isSafeString$1(value)) {
            return value.toHTML();
        }
        if (!element) {
            tagName = null;
        } else {
            tagName = element.tagName.toUpperCase();
        }
        let str = normalizeStringValue$1(value);
        if (checkURI$1(tagName, attribute)) {
            let protocol = env.protocolForURL(str);
            if (has$1(badProtocols$1, protocol)) {
                return `unsafe:${str}`;
            }
        }
        if (checkDataURI$1(tagName, attribute)) {
            return `unsafe:${str}`;
        }
        return str;
    }

    /*
     * @method normalizeProperty
     * @param element {HTMLElement}
     * @param slotName {String}
     * @returns {Object} { name, type }
     */
    function normalizeProperty$1(element, slotName) {
        let type, normalized;
        if (slotName in element) {
            normalized = slotName;
            type = 'prop';
        } else {
            let lower = slotName.toLowerCase();
            if (lower in element) {
                type = 'prop';
                normalized = lower;
            } else {
                type = 'attr';
                normalized = slotName;
            }
        }
        if (type === 'prop' && (normalized.toLowerCase() === 'style' || preferAttr$1(element.tagName, normalized))) {
            type = 'attr';
        }
        return { normalized, type };
    }
    // properties that MUST be set as attributes, due to:
    // * browser bug
    // * strange spec outlier
    const ATTR_OVERRIDES$1 = {
        INPUT: {
            form: true,
            // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false
            // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false
            // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true
            autocorrect: true,
            // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true
            // Safari 9.1.3: 'list' in document.createElement('input') === false
            list: true
        },
        // element.form is actually a legitimate readOnly property, that is to be
        // mutated, but must be mutated by setAttribute...
        SELECT: { form: true },
        OPTION: { form: true },
        TEXTAREA: { form: true },
        LABEL: { form: true },
        FIELDSET: { form: true },
        LEGEND: { form: true },
        OBJECT: { form: true },
        BUTTON: { form: true }
    };
    function preferAttr$1(tagName, propName) {
        let tag = ATTR_OVERRIDES$1[tagName.toUpperCase()];
        return tag && tag[propName.toLowerCase()] || false;
    }

    function dynamicAttribute$1(element, attr, namespace) {
        let tagName = element.tagName,
            namespaceURI = element.namespaceURI;

        let attribute = { element, name: attr, namespace };
        if (namespaceURI === SVG_NAMESPACE$3) {
            return buildDynamicAttribute$1(tagName, attr, attribute);
        }

        var _normalizeProperty = normalizeProperty$1(element, attr);

        let type = _normalizeProperty.type,
            normalized = _normalizeProperty.normalized;

        if (type === 'attr') {
            return buildDynamicAttribute$1(tagName, normalized, attribute);
        } else {
            return buildDynamicProperty$1(tagName, normalized, attribute);
        }
    }
    function buildDynamicAttribute$1(tagName, name, attribute) {
        if (requiresSanitization$1(tagName, name)) {
            return new SafeDynamicAttribute$1(attribute);
        } else {
            return new SimpleDynamicAttribute$1(attribute);
        }
    }
    function buildDynamicProperty$1(tagName, name, attribute) {
        if (requiresSanitization$1(tagName, name)) {
            return new SafeDynamicProperty$1(name, attribute);
        }
        if (isUserInputValue$1(tagName, name)) {
            return new InputValueDynamicAttribute$1(name, attribute);
        }
        if (isOptionSelected$1(tagName, name)) {
            return new OptionSelectedDynamicAttribute$1(name, attribute);
        }
        return new DefaultDynamicProperty$1(name, attribute);
    }
    class DynamicAttribute$1 {
        constructor(attribute) {
            this.attribute = attribute;
        }
    }
    class SimpleDynamicAttribute$1 extends DynamicAttribute$1 {
        set(dom, value, _env) {
            let normalizedValue = normalizeValue$1(value);
            if (normalizedValue !== null) {
                var _attribute = this.attribute;
                let name = _attribute.name,
                    namespace = _attribute.namespace;

                dom.__setAttribute(name, normalizedValue, namespace);
            }
        }
        update(value, _env) {
            let normalizedValue = normalizeValue$1(value);
            var _attribute2 = this.attribute;
            let element = _attribute2.element,
                name = _attribute2.name;

            if (normalizedValue === null) {
                element.removeAttribute(name);
            } else {
                element.setAttribute(name, normalizedValue);
            }
        }
    }
    class DefaultDynamicProperty$1 extends DynamicAttribute$1 {
        constructor(normalizedName, attribute) {
            super(attribute);
            this.normalizedName = normalizedName;
        }
        set(dom, value, _env) {
            if (value !== null && value !== undefined) {
                this.value = value;
                dom.__setProperty(this.normalizedName, value);
            }
        }
        update(value, _env) {
            let element = this.attribute.element;

            if (this.value !== value) {
                element[this.normalizedName] = this.value = value;
                if (value === null || value === undefined) {
                    this.removeAttribute();
                }
            }
        }
        removeAttribute() {
            // TODO this sucks but to preserve properties first and to meet current
            // semantics we must do this.
            var _attribute3 = this.attribute;
            let element = _attribute3.element,
                namespace = _attribute3.namespace;

            if (namespace) {
                element.removeAttributeNS(namespace, this.normalizedName);
            } else {
                element.removeAttribute(this.normalizedName);
            }
        }
    }
    class SafeDynamicProperty$1 extends DefaultDynamicProperty$1 {
        set(dom, value, env) {
            var _attribute4 = this.attribute;
            let element = _attribute4.element,
                name = _attribute4.name;

            let sanitized = sanitizeAttributeValue$1(env, element, name, value);
            super.set(dom, sanitized, env);
        }
        update(value, env) {
            var _attribute5 = this.attribute;
            let element = _attribute5.element,
                name = _attribute5.name;

            let sanitized = sanitizeAttributeValue$1(env, element, name, value);
            super.update(sanitized, env);
        }
    }
    class SafeDynamicAttribute$1 extends SimpleDynamicAttribute$1 {
        set(dom, value, env) {
            var _attribute6 = this.attribute;
            let element = _attribute6.element,
                name = _attribute6.name;

            let sanitized = sanitizeAttributeValue$1(env, element, name, value);
            super.set(dom, sanitized, env);
        }
        update(value, env) {
            var _attribute7 = this.attribute;
            let element = _attribute7.element,
                name = _attribute7.name;

            let sanitized = sanitizeAttributeValue$1(env, element, name, value);
            super.update(sanitized, env);
        }
    }
    class InputValueDynamicAttribute$1 extends DefaultDynamicProperty$1 {
        set(dom, value) {
            dom.__setProperty('value', normalizeStringValue$1(value));
        }
        update(value) {
            let input = this.attribute.element;
            let currentValue = input.value;
            let normalizedValue = normalizeStringValue$1(value);
            if (currentValue !== normalizedValue) {
                input.value = normalizedValue;
            }
        }
    }
    class OptionSelectedDynamicAttribute$1 extends DefaultDynamicProperty$1 {
        set(dom, value) {
            if (value !== null && value !== undefined && value !== false) {
                dom.__setProperty('selected', true);
            }
        }
        update(value) {
            let option = this.attribute.element;
            if (value) {
                option.selected = true;
            } else {
                option.selected = false;
            }
        }
    }
    function isOptionSelected$1(tagName, attribute) {
        return tagName === 'OPTION' && attribute === 'selected';
    }
    function isUserInputValue$1(tagName, attribute) {
        return (tagName === 'INPUT' || tagName === 'TEXTAREA') && attribute === 'value';
    }
    function normalizeValue$1(value) {
        if (value === false || value === undefined || value === null || typeof value.toString === 'undefined') {
            return null;
        }
        if (value === true) {
            return '';
        }
        // onclick function etc in SSR
        if (typeof value === 'function') {
            return null;
        }
        return String(value);
    }

    class Scope$1 {
        constructor(
        // the 0th slot is `self`
        slots, callerScope,
        // named arguments and blocks passed to a layout that uses eval
        evalScope,
        // locals in scope when the partial was invoked
        partialMap) {
            this.slots = slots;
            this.callerScope = callerScope;
            this.evalScope = evalScope;
            this.partialMap = partialMap;
        }
        static root(self, size = 0) {
            let refs = new Array(size + 1);
            for (let i = 0; i <= size; i++) {
                refs[i] = UNDEFINED_REFERENCE$1;
            }
            return new Scope$1(refs, null, null, null).init({ self });
        }
        static sized(size = 0) {
            let refs = new Array(size + 1);
            for (let i = 0; i <= size; i++) {
                refs[i] = UNDEFINED_REFERENCE$1;
            }
            return new Scope$1(refs, null, null, null);
        }
        init({ self }) {
            this.slots[0] = self;
            return this;
        }
        getSelf() {
            return this.get(0);
        }
        getSymbol(symbol) {
            return this.get(symbol);
        }
        getBlock(symbol) {
            let block = this.get(symbol);
            return block === UNDEFINED_REFERENCE$1 ? null : block;
        }
        getEvalScope() {
            return this.evalScope;
        }
        getPartialMap() {
            return this.partialMap;
        }
        bind(symbol, value) {
            this.set(symbol, value);
        }
        bindSelf(self) {
            this.set(0, self);
        }
        bindSymbol(symbol, value) {
            this.set(symbol, value);
        }
        bindBlock(symbol, value) {
            this.set(symbol, value);
        }
        bindEvalScope(map) {
            this.evalScope = map;
        }
        bindPartialMap(map) {
            this.partialMap = map;
        }
        bindCallerScope(scope) {
            this.callerScope = scope;
        }
        getCallerScope() {
            return this.callerScope;
        }
        child() {
            return new Scope$1(this.slots.slice(), this.callerScope, this.evalScope, this.partialMap);
        }
        get(index) {
            if (index >= this.slots.length) {
                throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);
            }
            return this.slots[index];
        }
        set(index, value) {
            if (index >= this.slots.length) {
                throw new RangeError(`BUG: cannot get $${index} from scope; length=${this.slots.length}`);
            }
            this.slots[index] = value;
        }
    }
    class Transaction$1 {
        constructor() {
            this.scheduledInstallManagers = [];
            this.scheduledInstallModifiers = [];
            this.scheduledUpdateModifierManagers = [];
            this.scheduledUpdateModifiers = [];
            this.createdComponents = [];
            this.createdManagers = [];
            this.updatedComponents = [];
            this.updatedManagers = [];
            this.destructors = [];
        }
        didCreate(component, manager) {
            this.createdComponents.push(component);
            this.createdManagers.push(manager);
        }
        didUpdate(component, manager) {
            this.updatedComponents.push(component);
            this.updatedManagers.push(manager);
        }
        scheduleInstallModifier(modifier, manager) {
            this.scheduledInstallManagers.push(manager);
            this.scheduledInstallModifiers.push(modifier);
        }
        scheduleUpdateModifier(modifier, manager) {
            this.scheduledUpdateModifierManagers.push(manager);
            this.scheduledUpdateModifiers.push(modifier);
        }
        didDestroy(d) {
            this.destructors.push(d);
        }
        commit() {
            let createdComponents = this.createdComponents,
                createdManagers = this.createdManagers;

            for (let i = 0; i < createdComponents.length; i++) {
                let component = createdComponents[i];
                let manager = createdManagers[i];
                manager.didCreate(component);
            }
            let updatedComponents = this.updatedComponents,
                updatedManagers = this.updatedManagers;

            for (let i = 0; i < updatedComponents.length; i++) {
                let component = updatedComponents[i];
                let manager = updatedManagers[i];
                manager.didUpdate(component);
            }
            let destructors = this.destructors;

            for (let i = 0; i < destructors.length; i++) {
                destructors[i].destroy();
            }
            let scheduledInstallManagers = this.scheduledInstallManagers,
                scheduledInstallModifiers = this.scheduledInstallModifiers;

            for (let i = 0; i < scheduledInstallManagers.length; i++) {
                let manager = scheduledInstallManagers[i];
                let modifier = scheduledInstallModifiers[i];
                manager.install(modifier);
            }
            let scheduledUpdateModifierManagers = this.scheduledUpdateModifierManagers,
                scheduledUpdateModifiers = this.scheduledUpdateModifiers;

            for (let i = 0; i < scheduledUpdateModifierManagers.length; i++) {
                let manager = scheduledUpdateModifierManagers[i];
                let modifier = scheduledUpdateModifiers[i];
                manager.update(modifier);
            }
        }
    }
    class Environment$1 {
        constructor({ appendOperations, updateOperations }) {
            this._transaction = null;
            this.appendOperations = appendOperations;
            this.updateOperations = updateOperations;
        }
        toConditionalReference(reference) {
            return new ConditionalReference$2(reference);
        }
        getAppendOperations() {
            return this.appendOperations;
        }
        getDOM() {
            return this.updateOperations;
        }
        begin() {

            this._transaction = new Transaction$1();
        }
        get transaction() {
            return this._transaction;
        }
        didCreate(component, manager) {
            this.transaction.didCreate(component, manager);
        }
        didUpdate(component, manager) {
            this.transaction.didUpdate(component, manager);
        }
        scheduleInstallModifier(modifier, manager) {
            this.transaction.scheduleInstallModifier(modifier, manager);
        }
        scheduleUpdateModifier(modifier, manager) {
            this.transaction.scheduleUpdateModifier(modifier, manager);
        }
        didDestroy(d) {
            this.transaction.didDestroy(d);
        }
        commit() {
            let transaction = this.transaction;
            this._transaction = null;
            transaction.commit();
        }
        attributeFor(element, attr, _isTrusting, namespace = null) {
            return dynamicAttribute$1(element, attr, namespace);
        }
    }

    class LowLevelVM$1 {
        constructor(stack, heap, program, externs, pc = -1, ra = -1) {
            this.stack = stack;
            this.heap = heap;
            this.program = program;
            this.externs = externs;
            this.pc = pc;
            this.ra = ra;
            this.currentOpSize = 0;
        }
        // Start a new frame and save $ra and $fp on the stack
        pushFrame() {
            this.stack.pushSmi(this.ra);
            this.stack.pushSmi(this.stack.fp);
            this.stack.fp = this.stack.sp - 1;
        }
        // Restore $ra, $sp and $fp
        popFrame() {
            this.stack.sp = this.stack.fp - 1;
            this.ra = this.stack.getSmi(0);
            this.stack.fp = this.stack.getSmi(1);
        }
        pushSmallFrame() {
            this.stack.pushSmi(this.ra);
        }
        popSmallFrame() {
            this.ra = this.stack.popSmi();
        }
        // Jump to an address in `program`
        goto(offset) {
            let addr = this.pc + offset - this.currentOpSize;
            this.pc = addr;
        }
        // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)
        call(handle) {
            this.ra = this.pc;
            this.pc = this.heap.getaddr(handle);
        }
        // Put a specific `program` address in $ra
        returnTo(offset) {
            let addr = this.pc + offset - this.currentOpSize;
            this.ra = addr;
        }
        // Return to the `program` address stored in $ra
        return() {
            this.pc = this.ra;
        }
        nextStatement() {
            let pc = this.pc,
                program = this.program;

            if (pc === -1) {
                return null;
            }
            // We have to save off the current operations size so that
            // when we do a jump we can calculate the correct offset
            // to where we are going. We can't simply ask for the size
            // in a jump because we have have already incremented the
            // program counter to the next instruction prior to executing.

            var _program$opcode = this.program.opcode(pc);

            let size = _program$opcode.size;

            let operationSize = this.currentOpSize = size;
            this.pc += operationSize;
            return program.opcode(pc);
        }
        evaluateOuter(opcode, vm) {
            {
                this.evaluateInner(opcode, vm);
            }
        }
        evaluateInner(opcode, vm) {
            if (opcode.isMachine) {
                this.evaluateMachine(opcode);
            } else {
                this.evaluateSyscall(opcode, vm);
            }
        }
        evaluateMachine(opcode) {
            switch (opcode.type) {
                case 57 /* PushFrame */:
                    return this.pushFrame();
                case 58 /* PopFrame */:
                    return this.popFrame();
                case 59 /* PushSmallFrame */:
                    return this.pushSmallFrame();
                case 60 /* PopSmallFrame */:
                    return this.popSmallFrame();
                case 50 /* InvokeStatic */:
                    return this.call(opcode.op1);
                case 49 /* InvokeVirtual */:
                    return this.call(this.stack.popSmi());
                case 52 /* Jump */:
                    return this.goto(opcode.op1);
                case 24 /* Return */:
                    return this.return();
                case 25 /* ReturnTo */:
                    return this.returnTo(opcode.op1);
            }
        }
        evaluateSyscall(opcode, vm) {
            APPEND_OPCODES$1.evaluate(vm, opcode, opcode.type);
        }
    }

    class First$1 {
        constructor(node) {
            this.node = node;
        }
        firstNode() {
            return this.node;
        }
    }
    class Last$1 {
        constructor(node) {
            this.node = node;
        }
        lastNode() {
            return this.node;
        }
    }
    class NewElementBuilder$1 {
        constructor(env, parentNode, nextSibling) {
            this.constructing = null;
            this.operations = null;
            this.cursorStack = new Stack$3();
            this.blockStack = new Stack$3();
            this.pushElement(parentNode, nextSibling);
            this.env = env;
            this.dom = env.getAppendOperations();
            this.updateOperations = env.getDOM();
        }
        static forInitialRender(env, cursor) {
            let builder = new this(env, cursor.element, cursor.nextSibling);
            builder.pushSimpleBlock();
            return builder;
        }
        static resume(env, tracker, nextSibling) {
            let parentNode = tracker.parentElement();
            let stack = new this(env, parentNode, nextSibling);
            stack.pushSimpleBlock();
            stack.pushBlockTracker(tracker);
            return stack;
        }
        get element() {
            return this.cursorStack.current.element;
        }
        get nextSibling() {
            return this.cursorStack.current.nextSibling;
        }
        expectConstructing(method) {
            return this.constructing;
        }
        block() {
            return this.blockStack.current;
        }
        popElement() {
            this.cursorStack.pop();
            this.cursorStack.current;
        }
        pushSimpleBlock() {
            return this.pushBlockTracker(new SimpleBlockTracker$1(this.element));
        }
        pushUpdatableBlock() {
            return this.pushBlockTracker(new UpdatableBlockTracker$1(this.element));
        }
        pushBlockList(list) {
            return this.pushBlockTracker(new BlockListTracker$1(this.element, list));
        }
        pushBlockTracker(tracker, isRemote = false) {
            let current = this.blockStack.current;
            if (current !== null) {
                current.newDestroyable(tracker);
                if (!isRemote) {
                    current.didAppendBounds(tracker);
                }
            }
            this.__openBlock();
            this.blockStack.push(tracker);
            return tracker;
        }
        popBlock() {
            this.block().finalize(this);
            this.__closeBlock();
            return this.blockStack.pop();
        }
        __openBlock() {}
        __closeBlock() {}
        // todo return seems unused
        openElement(tag) {
            let element = this.__openElement(tag);
            this.constructing = element;
            return element;
        }
        __openElement(tag) {
            return this.dom.createElement(tag, this.element);
        }
        flushElement() {
            let parent = this.element;
            let element = this.constructing;
            this.__flushElement(parent, element);
            this.constructing = null;
            this.operations = null;
            this.pushElement(element, null);
            this.didOpenElement(element);
        }
        __flushElement(parent, constructing) {
            this.dom.insertBefore(parent, constructing, this.nextSibling);
        }
        closeElement() {
            this.willCloseElement();
            this.popElement();
        }
        pushRemoteElement(element, guid, nextSibling = null) {
            this.__pushRemoteElement(element, guid, nextSibling);
        }
        __pushRemoteElement(element, _guid, nextSibling) {
            this.pushElement(element, nextSibling);
            let tracker = new RemoteBlockTracker$1(element);
            this.pushBlockTracker(tracker, true);
        }
        popRemoteElement() {
            this.popBlock();
            this.popElement();
        }
        pushElement(element, nextSibling) {
            this.cursorStack.push(new Cursor$1(element, nextSibling));
        }
        didAddDestroyable(d) {
            this.block().newDestroyable(d);
        }
        didAppendBounds(bounds) {
            this.block().didAppendBounds(bounds);
            return bounds;
        }
        didAppendNode(node) {
            this.block().didAppendNode(node);
            return node;
        }
        didOpenElement(element) {
            this.block().openElement(element);
            return element;
        }
        willCloseElement() {
            this.block().closeElement();
        }
        appendText(string) {
            return this.didAppendNode(this.__appendText(string));
        }
        __appendText(text) {
            let dom = this.dom,
                element = this.element,
                nextSibling = this.nextSibling;

            let node = dom.createTextNode(text);
            dom.insertBefore(element, node, nextSibling);
            return node;
        }
        __appendNode(node) {
            this.dom.insertBefore(this.element, node, this.nextSibling);
            return node;
        }
        __appendFragment(fragment) {
            let first = fragment.firstChild;
            if (first) {
                let ret = bounds$1(this.element, first, fragment.lastChild);
                this.dom.insertBefore(this.element, fragment, this.nextSibling);
                return ret;
            } else {
                return single$1(this.element, this.__appendComment(''));
            }
        }
        __appendHTML(html) {
            return this.dom.insertHTMLBefore(this.element, this.nextSibling, html);
        }
        appendDynamicHTML(value) {
            let bounds = this.trustedContent(value);
            this.didAppendBounds(bounds);
        }
        appendDynamicText(value) {
            let node = this.untrustedContent(value);
            this.didAppendNode(node);
            return node;
        }
        appendDynamicFragment(value) {
            let bounds = this.__appendFragment(value);
            this.didAppendBounds(bounds);
        }
        appendDynamicNode(value) {
            let node = this.__appendNode(value);
            let bounds = single$1(this.element, node);
            this.didAppendBounds(bounds);
        }
        trustedContent(value) {
            return this.__appendHTML(value);
        }
        untrustedContent(value) {
            return this.__appendText(value);
        }
        appendComment(string) {
            return this.didAppendNode(this.__appendComment(string));
        }
        __appendComment(string) {
            let dom = this.dom,
                element = this.element,
                nextSibling = this.nextSibling;

            let node = dom.createComment(string);
            dom.insertBefore(element, node, nextSibling);
            return node;
        }
        __setAttribute(name, value, namespace) {
            this.dom.setAttribute(this.constructing, name, value, namespace);
        }
        __setProperty(name, value) {
            this.constructing[name] = value;
        }
        setStaticAttribute(name, value, namespace) {
            this.__setAttribute(name, value, namespace);
        }
        setDynamicAttribute(name, value, trusting, namespace) {
            let element = this.constructing;
            let attribute = this.env.attributeFor(element, name, trusting, namespace);
            attribute.set(this, value, this.env);
            return attribute;
        }
    }
    class SimpleBlockTracker$1 {
        constructor(parent) {
            this.parent = parent;
            this.first = null;
            this.last = null;
            this.destroyables = null;
            this.nesting = 0;
        }
        destroy() {
            let destroyables = this.destroyables;

            if (destroyables && destroyables.length) {
                for (let i = 0; i < destroyables.length; i++) {
                    destroyables[i].destroy();
                }
            }
        }
        parentElement() {
            return this.parent;
        }
        firstNode() {
            return this.first && this.first.firstNode();
        }
        lastNode() {
            return this.last && this.last.lastNode();
        }
        openElement(element) {
            this.didAppendNode(element);
            this.nesting++;
        }
        closeElement() {
            this.nesting--;
        }
        didAppendNode(node) {
            if (this.nesting !== 0) return;
            if (!this.first) {
                this.first = new First$1(node);
            }
            this.last = new Last$1(node);
        }
        didAppendBounds(bounds) {
            if (this.nesting !== 0) return;
            if (!this.first) {
                this.first = bounds;
            }
            this.last = bounds;
        }
        newDestroyable(d) {
            this.destroyables = this.destroyables || [];
            this.destroyables.push(d);
        }
        finalize(stack) {
            if (!this.first) {
                stack.appendComment('');
            }
        }
    }
    class RemoteBlockTracker$1 extends SimpleBlockTracker$1 {
        destroy() {
            super.destroy();
            clear$1(this);
        }
    }
    class UpdatableBlockTracker$1 extends SimpleBlockTracker$1 {
        reset(env) {
            let destroyables = this.destroyables;

            if (destroyables && destroyables.length) {
                for (let i = 0; i < destroyables.length; i++) {
                    env.didDestroy(destroyables[i]);
                }
            }
            let nextSibling = clear$1(this);
            this.first = null;
            this.last = null;
            this.destroyables = null;
            this.nesting = 0;
            return nextSibling;
        }
    }
    class BlockListTracker$1 {
        constructor(parent, boundList) {
            this.parent = parent;
            this.boundList = boundList;
            this.parent = parent;
            this.boundList = boundList;
        }
        destroy() {
            this.boundList.forEachNode(node => node.destroy());
        }
        parentElement() {
            return this.parent;
        }
        firstNode() {
            let head = this.boundList.head();
            return head && head.firstNode();
        }
        lastNode() {
            let tail = this.boundList.tail();
            return tail && tail.lastNode();
        }
        openElement(_element) {
        }
        closeElement() {
        }
        didAppendNode(_node) {
        }
        didAppendBounds(_bounds) {}
        newDestroyable(_d) {}
        finalize(_stack) {}
    }
    function clientBuilder$1(env, cursor) {
        return NewElementBuilder$1.forInitialRender(env, cursor);
    }

    class Stack$4 {
        constructor(vec = []) {
            this.vec = vec;
        }
        clone() {
            return new Stack$4(this.vec.slice());
        }
        sliceFrom(start) {
            return new Stack$4(this.vec.slice(start));
        }
        slice(start, end) {
            return new Stack$4(this.vec.slice(start, end));
        }
        copy(from, to) {
            this.vec[to] = this.vec[from];
        }
        // TODO: how to model u64 argument?
        writeRaw(pos, value) {
            // TODO: Grow?
            this.vec[pos] = value;
        }
        writeSmi(pos, value) {
            this.vec[pos] = encodeSmi$2(value);
        }
        // TODO: partially decoded enum?
        getRaw(pos) {
            return this.vec[pos];
        }
        getSmi(pos) {
            return decodeSmi$2(this.vec[pos]);
        }
        reset() {
            this.vec.length = 0;
        }
        len() {
            return this.vec.length;
        }
    }
    function decodeSmi$2(smi) {
        switch (smi & 0b111) {
            case 0 /* NUMBER */:
                return smi >> 3;
            case 4 /* NEGATIVE */:
                return -(smi >> 3);
            default:
                throw new Error('unreachable');
        }
    }
    function encodeSmi$2(primitive) {
        if (primitive < 0) {
            return Math.abs(primitive) << 3 | 4 /* NEGATIVE */;
        } else {
            return primitive << 3 | 0 /* NUMBER */;
        }
    }

    const HI$1 = 0x80000000;
    const MASK$1 = 0x7fffffff;
    class InnerStack$1 {
        constructor(inner = new Stack$4(), js = []) {
            this.inner = inner;
            this.js = js;
        }
        slice(start, end) {
            let inner;
            if (typeof start === 'number' && typeof end === 'number') {
                inner = this.inner.slice(start, end);
            } else if (typeof start === 'number' && end === undefined) {
                inner = this.inner.sliceFrom(start);
            } else {
                inner = this.inner.clone();
            }
            return new InnerStack$1(inner, this.js.slice(start, end));
        }
        sliceInner(start, end) {
            let out = [];
            for (let i = start; i < end; i++) {
                out.push(this.get(i));
            }
            return out;
        }
        copy(from, to) {
            this.inner.copy(from, to);
        }
        write(pos, value) {
            if (isImmediate$1(value)) {
                this.inner.writeRaw(pos, encodeImmediate$1(value));
            } else {
                let idx = this.js.length;
                this.js.push(value);
                this.inner.writeRaw(pos, idx | HI$1);
            }
        }
        writeSmi(pos, value) {
            this.inner.writeSmi(pos, value);
        }
        writeImmediate(pos, value) {
            this.inner.writeRaw(pos, value);
        }
        get(pos) {
            let value = this.inner.getRaw(pos);
            if (value & HI$1) {
                return this.js[value & MASK$1];
            } else {
                return decodeImmediate$1(value);
            }
        }
        getSmi(pos) {
            return this.inner.getSmi(pos);
        }
        reset() {
            this.inner.reset();
            this.js.length = 0;
        }
        get length() {
            return this.inner.len();
        }
    }
    class EvaluationStack$1 {
        constructor(stack, fp, sp) {
            this.stack = stack;
            this.fp = fp;
            this.sp = sp;
        }
        static empty() {
            return new this(new InnerStack$1(), 0, -1);
        }
        static restore(snapshot) {
            let stack = new InnerStack$1();
            for (let i = 0; i < snapshot.length; i++) {
                stack.write(i, snapshot[i]);
            }
            return new this(stack, 0, snapshot.length - 1);
        }
        push(value) {
            this.stack.write(++this.sp, value);
        }
        pushSmi(value) {
            this.stack.writeSmi(++this.sp, value);
        }
        pushImmediate(value) {
            this.stack.writeImmediate(++this.sp, encodeImmediate$1(value));
        }
        pushEncodedImmediate(value) {
            this.stack.writeImmediate(++this.sp, value);
        }
        pushNull() {
            this.stack.writeImmediate(++this.sp, 19 /* Null */);
        }
        dup(position = this.sp) {
            this.stack.copy(position, ++this.sp);
        }
        copy(from, to) {
            this.stack.copy(from, to);
        }
        pop(n = 1) {
            let top = this.stack.get(this.sp);
            this.sp -= n;
            return top;
        }
        popSmi() {
            return this.stack.getSmi(this.sp--);
        }
        peek(offset = 0) {
            return this.stack.get(this.sp - offset);
        }
        peekSmi(offset = 0) {
            return this.stack.getSmi(this.sp - offset);
        }
        get(offset, base = this.fp) {
            return this.stack.get(base + offset);
        }
        getSmi(offset, base = this.fp) {
            return this.stack.getSmi(base + offset);
        }
        set(value, offset, base = this.fp) {
            this.stack.write(base + offset, value);
        }
        slice(start, end) {
            return this.stack.slice(start, end);
        }
        sliceArray(start, end) {
            return this.stack.sliceInner(start, end);
        }
        capture(items) {
            let end = this.sp + 1;
            let start = end - items;
            return this.stack.sliceInner(start, end);
        }
        reset() {
            this.stack.reset();
        }
        toArray() {
            return this.stack.sliceInner(this.fp, this.sp + 1);
        }
    }
    function isImmediate$1(value) {
        let type = typeof value;
        if (value === null || value === undefined) return true;
        switch (type) {
            case 'boolean':
            case 'undefined':
                return true;
            case 'number':
                // not an integer
                if (value % 1 !== 0) return false;
                let abs = Math.abs(value);
                // too big
                if (abs > HI$1) return false;
                return true;
            default:
                return false;
        }
    }
    function encodeSmi$3(primitive) {
        if (primitive < 0) {
            return Math.abs(primitive) << 3 | 4 /* NEGATIVE */;
        } else {
            return primitive << 3 | 0 /* NUMBER */;
        }
    }
    function encodeImmediate$1(primitive) {
        switch (typeof primitive) {
            case 'number':
                return encodeSmi$3(primitive);
            case 'boolean':
                return primitive ? 11 /* True */ : 3 /* False */;
            case 'object':
                // assume null
                return 19 /* Null */;
            case 'undefined':
                return 27 /* Undef */;
            default:
                throw unreachable$2();
        }
    }
    function decodeSmi$3(smi) {
        switch (smi & 0b111) {
            case 0 /* NUMBER */:
                return smi >> 3;
            case 4 /* NEGATIVE */:
                return -(smi >> 3);
            default:
                throw unreachable$2();
        }
    }
    function decodeImmediate$1(immediate) {
        switch (immediate) {
            case 3 /* False */:
                return false;
            case 11 /* True */:
                return true;
            case 19 /* Null */:
                return null;
            case 27 /* Undef */:
                return undefined;
            default:
                return decodeSmi$3(immediate);
        }
    }

    class UpdatingVM$1 {
        constructor(env, program, { alwaysRevalidate = false }) {
            this.frameStack = new Stack$3();
            this.env = env;
            this.constants = program.constants;
            this.dom = env.getDOM();
            this.alwaysRevalidate = alwaysRevalidate;
        }
        execute(opcodes, handler) {
            let frameStack = this.frameStack;

            this.try(opcodes, handler);
            while (true) {
                if (frameStack.isEmpty()) break;
                let opcode = this.frame.nextStatement();
                if (opcode === null) {
                    this.frameStack.pop();
                    continue;
                }
                opcode.evaluate(this);
            }
        }
        get frame() {
            return this.frameStack.current;
        }
        goto(op) {
            this.frame.goto(op);
        }
        try(ops, handler) {
            this.frameStack.push(new UpdatingVMFrame$1(ops, handler));
        }
        throw() {
            this.frame.handleException();
            this.frameStack.pop();
        }
    }
    class BlockOpcode$1 extends UpdatingOpcode$1 {
        constructor(start, state, runtime, bounds, children) {
            super();
            this.start = start;
            this.state = state;
            this.runtime = runtime;
            this.type = 'block';
            this.next = null;
            this.prev = null;
            this.children = children;
            this.bounds = bounds;
        }
        parentElement() {
            return this.bounds.parentElement();
        }
        firstNode() {
            return this.bounds.firstNode();
        }
        lastNode() {
            return this.bounds.lastNode();
        }
        evaluate(vm) {
            vm.try(this.children, null);
        }
        destroy() {
            this.bounds.destroy();
        }
        didDestroy() {
            this.runtime.env.didDestroy(this.bounds);
        }
    }
    class TryOpcode$1 extends BlockOpcode$1 {
        constructor(start, state, runtime, bounds, children) {
            super(start, state, runtime, bounds, children);
            this.type = 'try';
            this.tag = this._tag = UpdatableTag.create(CONSTANT_TAG);
        }
        didInitializeChildren() {
            this._tag.inner.update(combineSlice(this.children));
        }
        evaluate(vm) {
            vm.try(this.children, this);
        }
        handleException() {
            let state = this.state,
                bounds = this.bounds,
                children = this.children,
                start = this.start,
                prev = this.prev,
                next = this.next,
                runtime = this.runtime;

            children.clear();
            let elementStack = NewElementBuilder$1.resume(runtime.env, bounds, bounds.reset(runtime.env));
            let vm = VM$1.resume(state, runtime, elementStack);
            let updating = new LinkedList$2();
            vm.execute(start, vm => {
                vm.stack = EvaluationStack$1.restore(state.stack);
                vm.updatingOpcodeStack.push(updating);
                vm.updateWith(this);
                vm.updatingOpcodeStack.push(children);
            });
            this.prev = prev;
            this.next = next;
        }
    }
    class ListRevalidationDelegate$1 {
        constructor(opcode, marker) {
            this.opcode = opcode;
            this.marker = marker;
            this.didInsert = false;
            this.didDelete = false;
            this.map = opcode.map;
            this.updating = opcode['children'];
        }
        insert(key, item, memo, before) {
            let map$$1 = this.map,
                opcode = this.opcode,
                updating = this.updating;

            let nextSibling = null;
            let reference = null;
            if (before) {
                reference = map$$1[before];
                nextSibling = reference['bounds'].firstNode();
            } else {
                nextSibling = this.marker;
            }
            let vm = opcode.vmForInsertion(nextSibling);
            let tryOpcode = null;
            let start = opcode.start;

            vm.execute(start, vm => {
                map$$1[key] = tryOpcode = vm.iterate(memo, item);
                vm.updatingOpcodeStack.push(new LinkedList$2());
                vm.updateWith(tryOpcode);
                vm.updatingOpcodeStack.push(tryOpcode.children);
            });
            updating.insertBefore(tryOpcode, reference);
            this.didInsert = true;
        }
        retain(_key, _item, _memo) {}
        move(key, _item, _memo, before) {
            let map$$1 = this.map,
                updating = this.updating;

            let entry = map$$1[key];
            let reference = map$$1[before] || null;
            if (before) {
                move$1(entry, reference.firstNode());
            } else {
                move$1(entry, this.marker);
            }
            updating.remove(entry);
            updating.insertBefore(entry, reference);
        }
        delete(key) {
            let map$$1 = this.map;

            let opcode = map$$1[key];
            opcode.didDestroy();
            clear$1(opcode);
            this.updating.remove(opcode);
            delete map$$1[key];
            this.didDelete = true;
        }
        done() {
            this.opcode.didInitializeChildren(this.didInsert || this.didDelete);
        }
    }
    class ListBlockOpcode$1 extends BlockOpcode$1 {
        constructor(start, state, runtime, bounds, children, artifacts) {
            super(start, state, runtime, bounds, children);
            this.type = 'list-block';
            this.map = dict$2();
            this.lastIterated = INITIAL;
            this.artifacts = artifacts;
            let _tag = this._tag = UpdatableTag.create(CONSTANT_TAG);
            this.tag = combine([artifacts.tag, _tag]);
        }
        didInitializeChildren(listDidChange = true) {
            this.lastIterated = this.artifacts.tag.value();
            if (listDidChange) {
                this._tag.inner.update(combineSlice(this.children));
            }
        }
        evaluate(vm) {
            let artifacts = this.artifacts,
                lastIterated = this.lastIterated;

            if (!artifacts.tag.validate(lastIterated)) {
                let bounds = this.bounds;
                let dom = vm.dom;

                let marker = dom.createComment('');
                dom.insertAfter(bounds.parentElement(), marker, bounds.lastNode());
                let target = new ListRevalidationDelegate$1(this, marker);
                let synchronizer = new IteratorSynchronizer({ target, artifacts });
                synchronizer.sync();
                this.parentElement().removeChild(marker);
            }
            // Run now-updated updating opcodes
            super.evaluate(vm);
        }
        vmForInsertion(nextSibling) {
            let bounds = this.bounds,
                state = this.state,
                runtime = this.runtime;

            let elementStack = NewElementBuilder$1.forInitialRender(runtime.env, {
                element: bounds.parentElement(),
                nextSibling
            });
            return VM$1.resume(state, runtime, elementStack);
        }
    }
    class UpdatingVMFrame$1 {
        constructor(ops, exceptionHandler) {
            this.ops = ops;
            this.exceptionHandler = exceptionHandler;
            this.current = ops.head();
        }
        goto(op) {
            this.current = op;
        }
        nextStatement() {
            let current = this.current,
                ops = this.ops;

            if (current) this.current = ops.nextNode(current);
            return current;
        }
        handleException() {
            if (this.exceptionHandler) {
                this.exceptionHandler.handleException();
            }
        }
    }

    class RenderResult$1 {
        constructor(env, program, updating, bounds) {
            this.env = env;
            this.program = program;
            this.updating = updating;
            this.bounds = bounds;
        }
        rerender({ alwaysRevalidate = false } = { alwaysRevalidate: false }) {
            let env = this.env,
                program = this.program,
                updating = this.updating;

            let vm = new UpdatingVM$1(env, program, { alwaysRevalidate });
            vm.execute(updating, this);
        }
        parentElement() {
            return this.bounds.parentElement();
        }
        firstNode() {
            return this.bounds.firstNode();
        }
        lastNode() {
            return this.bounds.lastNode();
        }
        handleException() {
            throw 'this should never happen';
        }
        destroy() {
            this.bounds.destroy();
            clear$1(this.bounds);
        }
    }

    class Arguments$1 {
        constructor() {
            this.stack = null;
            this.positional = new PositionalArguments$1();
            this.named = new NamedArguments$1();
            this.blocks = new BlockArguments$1();
        }
        empty(stack) {
            let base = stack.sp + 1;
            this.named.empty(stack, base);
            this.positional.empty(stack, base);
            this.blocks.empty(stack, base);
            return this;
        }
        setup(stack, names, blockNames, positionalCount, synthetic) {
            this.stack = stack;
            /*
                   | ... | blocks      | positional  | named |
                   | ... | b0    b1    | p0 p1 p2 p3 | n0 n1 |
             index | ... | 4/5/6 7/8/9 | 10 11 12 13 | 14 15 |
                           ^             ^             ^  ^
                         bbase         pbase       nbase  sp
            */
            let named = this.named;
            let namedCount = names.length;
            let namedBase = stack.sp - namedCount + 1;
            named.setup(stack, namedBase, namedCount, names, synthetic);
            let positional = this.positional;
            let positionalBase = namedBase - positionalCount;
            positional.setup(stack, positionalBase, positionalCount);
            let blocks = this.blocks;
            let blocksCount = blockNames.length;
            let blocksBase = positionalBase - blocksCount * 3;
            blocks.setup(stack, blocksBase, blocksCount, blockNames);
        }
        get tag() {
            return combineTagged([this.positional, this.named]);
        }
        get base() {
            return this.blocks.base;
        }
        get length() {
            return this.positional.length + this.named.length + this.blocks.length * 3;
        }
        at(pos) {
            return this.positional.at(pos);
        }
        realloc(offset) {
            let stack = this.stack;

            if (offset > 0 && stack !== null) {
                let positional = this.positional,
                    named = this.named;

                let newBase = positional.base + offset;
                let length = positional.length + named.length;
                for (let i = length - 1; i >= 0; i--) {
                    stack.copy(i + positional.base, i + newBase);
                }
                positional.base += offset;
                named.base += offset;
                stack.sp += offset;
            }
        }
        capture() {
            let positional = this.positional.length === 0 ? EMPTY_POSITIONAL$1 : this.positional.capture();
            let named = this.named.length === 0 ? EMPTY_NAMED$1 : this.named.capture();
            return {
                tag: this.tag,
                length: this.length,
                positional,
                named
            };
        }
        clear() {
            let stack = this.stack,
                length = this.length;

            if (length > 0 && stack !== null) stack.pop(length);
        }
    }
    class PositionalArguments$1 {
        constructor() {
            this.base = 0;
            this.length = 0;
            this.stack = null;
            this._tag = null;
            this._references = null;
        }
        empty(stack, base) {
            this.stack = stack;
            this.base = base;
            this.length = 0;
            this._tag = CONSTANT_TAG;
            this._references = EMPTY_ARRAY$2;
        }
        setup(stack, base, length) {
            this.stack = stack;
            this.base = base;
            this.length = length;
            if (length === 0) {
                this._tag = CONSTANT_TAG;
                this._references = EMPTY_ARRAY$2;
            } else {
                this._tag = null;
                this._references = null;
            }
        }
        get tag() {
            let tag = this._tag;
            if (!tag) {
                tag = this._tag = combineTagged(this.references);
            }
            return tag;
        }
        at(position) {
            let base = this.base,
                length = this.length,
                stack = this.stack;

            if (position < 0 || position >= length) {
                return UNDEFINED_REFERENCE$1;
            }
            return stack.get(position, base);
        }
        capture() {
            return new CapturedPositionalArguments$1(this.tag, this.references);
        }
        prepend(other) {
            let additions = other.length;
            if (additions > 0) {
                let base = this.base,
                    length = this.length,
                    stack = this.stack;

                this.base = base = base - additions;
                this.length = length + additions;
                for (let i = 0; i < additions; i++) {
                    stack.set(other.at(i), i, base);
                }
                this._tag = null;
                this._references = null;
            }
        }
        get references() {
            let references = this._references;
            if (!references) {
                let stack = this.stack,
                    base = this.base,
                    length = this.length;

                references = this._references = stack.sliceArray(base, base + length);
            }
            return references;
        }
    }
    class CapturedPositionalArguments$1 {
        constructor(tag, references, length = references.length) {
            this.tag = tag;
            this.references = references;
            this.length = length;
        }
        static empty() {
            return new CapturedPositionalArguments$1(CONSTANT_TAG, EMPTY_ARRAY$2, 0);
        }
        at(position) {
            return this.references[position];
        }
        value() {
            return this.references.map(this.valueOf);
        }
        get(name) {
            let references = this.references,
                length = this.length;

            if (name === 'length') {
                return PrimitiveReference$1.create(length);
            } else {
                let idx = parseInt(name, 10);
                if (idx < 0 || idx >= length) {
                    return UNDEFINED_REFERENCE$1;
                } else {
                    return references[idx];
                }
            }
        }
        valueOf(reference) {
            return reference.value();
        }
    }
    class NamedArguments$1 {
        constructor() {
            this.base = 0;
            this.length = 0;
            this._references = null;
            this._names = EMPTY_ARRAY$2;
            this._atNames = EMPTY_ARRAY$2;
        }
        empty(stack, base) {
            this.stack = stack;
            this.base = base;
            this.length = 0;
            this._references = EMPTY_ARRAY$2;
            this._names = EMPTY_ARRAY$2;
            this._atNames = EMPTY_ARRAY$2;
        }
        setup(stack, base, length, names, synthetic) {
            this.stack = stack;
            this.base = base;
            this.length = length;
            if (length === 0) {
                this._references = EMPTY_ARRAY$2;
                this._names = EMPTY_ARRAY$2;
                this._atNames = EMPTY_ARRAY$2;
            } else {
                this._references = null;
                if (synthetic) {
                    this._names = names;
                    this._atNames = null;
                } else {
                    this._names = null;
                    this._atNames = names;
                }
            }
        }
        get tag() {
            return combineTagged(this.references);
        }
        get names() {
            let names = this._names;
            if (!names) {
                names = this._names = this._atNames.map(this.toSyntheticName);
            }
            return names;
        }
        get atNames() {
            let atNames = this._atNames;
            if (!atNames) {
                atNames = this._atNames = this._names.map(this.toAtName);
            }
            return atNames;
        }
        has(name) {
            return this.names.indexOf(name) !== -1;
        }
        get(name, synthetic = true) {
            let base = this.base,
                stack = this.stack;

            let names = synthetic ? this.names : this.atNames;
            let idx = names.indexOf(name);
            if (idx === -1) {
                return UNDEFINED_REFERENCE$1;
            }
            return stack.get(idx, base);
        }
        capture() {
            return new CapturedNamedArguments$1(this.tag, this.names, this.references);
        }
        merge(other) {
            let extras = other.length;

            if (extras > 0) {
                let names = this.names,
                    length = this.length,
                    stack = this.stack;
                let extraNames = other.names;

                if (Object.isFrozen(names) && names.length === 0) {
                    names = [];
                }
                for (let i = 0; i < extras; i++) {
                    let name = extraNames[i];
                    let idx = names.indexOf(name);
                    if (idx === -1) {
                        length = names.push(name);
                        stack.push(other.references[i]);
                    }
                }
                this.length = length;
                this._references = null;
                this._names = names;
                this._atNames = null;
            }
        }
        get references() {
            let references = this._references;
            if (!references) {
                let base = this.base,
                    length = this.length,
                    stack = this.stack;

                references = this._references = stack.sliceArray(base, base + length);
            }
            return references;
        }
        toSyntheticName(name) {
            return name.slice(1);
        }
        toAtName(name) {
            return `@${name}`;
        }
    }
    class CapturedNamedArguments$1 {
        constructor(tag, names, references) {
            this.tag = tag;
            this.names = names;
            this.references = references;
            this.length = names.length;
            this._map = null;
        }
        get map() {
            let map$$1 = this._map;
            if (!map$$1) {
                let names = this.names,
                    references = this.references;

                map$$1 = this._map = dict$2();
                for (let i = 0; i < names.length; i++) {
                    let name = names[i];
                    map$$1[name] = references[i];
                }
            }
            return map$$1;
        }
        has(name) {
            return this.names.indexOf(name) !== -1;
        }
        get(name) {
            let names = this.names,
                references = this.references;

            let idx = names.indexOf(name);
            if (idx === -1) {
                return UNDEFINED_REFERENCE$1;
            } else {
                return references[idx];
            }
        }
        value() {
            let names = this.names,
                references = this.references;

            let out = dict$2();
            for (let i = 0; i < names.length; i++) {
                let name = names[i];
                out[name] = references[i].value();
            }
            return out;
        }
    }
    class BlockArguments$1 {
        constructor() {
            this.internalValues = null;
            this.internalTag = null;
            this.names = EMPTY_ARRAY$2;
            this.length = 0;
            this.base = 0;
        }
        empty(stack, base) {
            this.stack = stack;
            this.names = EMPTY_ARRAY$2;
            this.base = base;
            this.length = 0;
            this.internalTag = CONSTANT_TAG;
            this.internalValues = EMPTY_ARRAY$2;
        }
        setup(stack, base, length, names) {
            this.stack = stack;
            this.names = names;
            this.base = base;
            this.length = length;
            if (length === 0) {
                this.internalTag = CONSTANT_TAG;
                this.internalValues = EMPTY_ARRAY$2;
            } else {
                this.internalTag = null;
                this.internalValues = null;
            }
        }
        get values() {
            let values = this.internalValues;
            if (!values) {
                let base = this.base,
                    length = this.length,
                    stack = this.stack;

                values = this.internalValues = stack.sliceArray(base, base + length * 3);
            }
            return values;
        }
        has(name) {
            return this.names.indexOf(name) !== -1;
        }
        get(name) {
            let base = this.base,
                stack = this.stack,
                names = this.names;

            let idx = names.indexOf(name);
            if (names.indexOf(name) === -1) {
                return null;
            }
            let table = stack.get(idx * 3, base);
            let scope = stack.get(idx * 3 + 1, base); // FIXME(mmun): shouldn't need to cast this
            let handle = stack.get(idx * 3 + 2, base);
            return handle === null ? null : [handle, scope, table];
        }
        capture() {
            return new CapturedBlockArguments$1(this.names, this.values);
        }
    }
    class CapturedBlockArguments$1 {
        constructor(names, values) {
            this.names = names;
            this.values = values;
            this.length = names.length;
        }
        has(name) {
            return this.names.indexOf(name) !== -1;
        }
        get(name) {
            let idx = this.names.indexOf(name);
            if (idx === -1) return null;
            return [this.values[idx * 3 + 2], this.values[idx * 3 + 1], this.values[idx * 3]];
        }
    }
    const EMPTY_NAMED$1 = new CapturedNamedArguments$1(CONSTANT_TAG, EMPTY_ARRAY$2, EMPTY_ARRAY$2);
    const EMPTY_POSITIONAL$1 = new CapturedPositionalArguments$1(CONSTANT_TAG, EMPTY_ARRAY$2);

    class VM$1 {
        constructor(runtime, scope, dynamicScope, elementStack) {
            this.runtime = runtime;
            this.elementStack = elementStack;
            this.dynamicScopeStack = new Stack$3();
            this.scopeStack = new Stack$3();
            this.updatingOpcodeStack = new Stack$3();
            this.cacheGroups = new Stack$3();
            this.listBlockStack = new Stack$3();
            this.s0 = null;
            this.s1 = null;
            this.t0 = null;
            this.t1 = null;
            this.v0 = null;
            this.heap = this.program.heap;
            this.constants = this.program.constants;
            this.elementStack = elementStack;
            this.scopeStack.push(scope);
            this.dynamicScopeStack.push(dynamicScope);
            this.args = new Arguments$1();
            this.inner = new LowLevelVM$1(EvaluationStack$1.empty(), this.heap, runtime.program, {
                debugBefore: opcode => {
                    return APPEND_OPCODES$1.debugBefore(this, opcode, opcode.type);
                },
                debugAfter: (opcode, state) => {
                    APPEND_OPCODES$1.debugAfter(this, opcode, opcode.type, state);
                }
            });
        }
        get stack() {
            return this.inner.stack;
        }
        set stack(value) {
            this.inner.stack = value;
        }
        /* Registers */
        set currentOpSize(value) {
            this.inner.currentOpSize = value;
        }
        get currentOpSize() {
            return this.inner.currentOpSize;
        }
        get pc() {
            return this.inner.pc;
        }
        set pc(value) {

            this.inner.pc = value;
        }
        get ra() {
            return this.inner.ra;
        }
        set ra(value) {
            this.inner.ra = value;
        }
        get fp() {
            return this.stack.fp;
        }
        set fp(fp) {
            this.stack.fp = fp;
        }
        get sp() {
            return this.stack.sp;
        }
        set sp(sp) {
            this.stack.sp = sp;
        }
        // Fetch a value from a register onto the stack
        fetch(register) {
            this.stack.push(this[Register$1[register]]);
        }
        // Load a value from the stack into a register
        load(register) {
            this[Register$1[register]] = this.stack.pop();
        }
        // Fetch a value from a register
        fetchValue(register) {
            return this[Register$1[register]];
        }
        // Load a value into a register
        loadValue(register, value) {
            this[Register$1[register]] = value;
        }
        /**
         * Migrated to Inner
         */
        // Start a new frame and save $ra and $fp on the stack
        pushFrame() {
            this.inner.pushFrame();
        }
        // Restore $ra, $sp and $fp
        popFrame() {
            this.inner.popFrame();
        }
        // Jump to an address in `program`
        goto(offset) {
            this.inner.goto(offset);
        }
        // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)
        call(handle) {
            this.inner.call(handle);
        }
        // Put a specific `program` address in $ra
        returnTo(offset) {
            this.inner.returnTo(offset);
        }
        // Return to the `program` address stored in $ra
        return() {
            this.inner.return();
        }
        /**
         * End of migrated.
         */
        static initial(program, env, self, dynamicScope, elementStack, handle) {
            let scopeSize = program.heap.scopesizeof(handle);
            let scope = Scope$1.root(self, scopeSize);
            let vm = new VM$1({ program, env }, scope, dynamicScope, elementStack);
            vm.pc = vm.heap.getaddr(handle);
            vm.updatingOpcodeStack.push(new LinkedList$2());
            return vm;
        }
        static empty(program, env, elementStack) {
            let dynamicScope = {
                get() {
                    return UNDEFINED_REFERENCE$1;
                },
                set() {
                    return UNDEFINED_REFERENCE$1;
                },
                child() {
                    return dynamicScope;
                }
            };
            let vm = new VM$1({ program, env }, Scope$1.root(UNDEFINED_REFERENCE$1, 0), dynamicScope, elementStack);
            vm.updatingOpcodeStack.push(new LinkedList$2());
            return vm;
        }
        static resume({ scope, dynamicScope }, runtime, stack) {
            return new VM$1(runtime, scope, dynamicScope, stack);
        }
        get program() {
            return this.runtime.program;
        }
        get env() {
            return this.runtime.env;
        }
        capture(args) {
            return {
                dynamicScope: this.dynamicScope(),
                scope: this.scope(),
                stack: this.stack.capture(args)
            };
        }
        beginCacheGroup() {
            this.cacheGroups.push(this.updating().tail());
        }
        commitCacheGroup() {
            //        JumpIfNotModified(END)
            //        (head)
            //        (....)
            //        (tail)
            //        DidModify
            // END:   Noop
            let END = new LabelOpcode$1('END');
            let opcodes = this.updating();
            let marker = this.cacheGroups.pop();
            let head = marker ? opcodes.nextNode(marker) : opcodes.head();
            let tail = opcodes.tail();
            let tag = combineSlice(new ListSlice$2(head, tail));
            let guard = new JumpIfNotModifiedOpcode$1(tag, END);
            opcodes.insertBefore(guard, head);
            opcodes.append(new DidModifyOpcode$1(guard));
            opcodes.append(END);
        }
        enter(args) {
            let updating = new LinkedList$2();
            let state = this.capture(args);
            let tracker = this.elements().pushUpdatableBlock();
            let tryOpcode = new TryOpcode$1(this.heap.gethandle(this.pc), state, this.runtime, tracker, updating);
            this.didEnter(tryOpcode);
        }
        iterate(memo, value) {
            let stack = this.stack;
            stack.push(value);
            stack.push(memo);
            let state = this.capture(2);
            let tracker = this.elements().pushUpdatableBlock();
            // let ip = this.ip;
            // this.ip = end + 4;
            // this.frames.push(ip);
            return new TryOpcode$1(this.heap.gethandle(this.pc), state, this.runtime, tracker, new LinkedList$2());
        }
        enterItem(key, opcode) {
            this.listBlock().map[key] = opcode;
            this.didEnter(opcode);
        }
        enterList(relativeStart) {
            let updating = new LinkedList$2();
            let state = this.capture(0);
            let tracker = this.elements().pushBlockList(updating);
            let artifacts = this.stack.peek().artifacts;
            let addr = this.pc + relativeStart - this.currentOpSize;
            let start = this.heap.gethandle(addr);
            let opcode = new ListBlockOpcode$1(start, state, this.runtime, tracker, updating, artifacts);
            this.listBlockStack.push(opcode);
            this.didEnter(opcode);
        }
        didEnter(opcode) {
            this.updateWith(opcode);
            this.updatingOpcodeStack.push(opcode.children);
        }
        exit() {
            this.elements().popBlock();
            this.updatingOpcodeStack.pop();
            let parent = this.updating().tail();
            parent.didInitializeChildren();
        }
        exitList() {
            this.exit();
            this.listBlockStack.pop();
        }
        updateWith(opcode) {
            this.updating().append(opcode);
        }
        listBlock() {
            return this.listBlockStack.current;
        }
        updating() {
            return this.updatingOpcodeStack.current;
        }
        elements() {
            return this.elementStack;
        }
        scope() {
            return this.scopeStack.current;
        }
        dynamicScope() {
            return this.dynamicScopeStack.current;
        }
        pushChildScope() {
            this.scopeStack.push(this.scope().child());
        }
        pushDynamicScope() {
            let child = this.dynamicScope().child();
            this.dynamicScopeStack.push(child);
            return child;
        }
        pushRootScope(size, bindCaller) {
            let scope = Scope$1.sized(size);
            if (bindCaller) scope.bindCallerScope(this.scope());
            this.scopeStack.push(scope);
            return scope;
        }
        pushScope(scope) {
            this.scopeStack.push(scope);
        }
        popScope() {
            this.scopeStack.pop();
        }
        popDynamicScope() {
            this.dynamicScopeStack.pop();
        }
        newDestroyable(d) {
            this.elements().didAddDestroyable(d);
        }
        /// SCOPE HELPERS
        getSelf() {
            return this.scope().getSelf();
        }
        referenceForSymbol(symbol) {
            return this.scope().getSymbol(symbol);
        }
        /// EXECUTION
        execute(start, initialize) {
            this.pc = this.heap.getaddr(start);
            if (initialize) initialize(this);
            let result;
            while (true) {
                result = this.next();
                if (result.done) break;
            }
            return result.value;
        }
        next() {
            let env = this.env,
                program = this.program,
                updatingOpcodeStack = this.updatingOpcodeStack,
                elementStack = this.elementStack;

            let opcode = this.inner.nextStatement();
            let result;
            if (opcode !== null) {
                this.inner.evaluateOuter(opcode, this);
                result = { done: false, value: null };
            } else {
                // Unload the stack
                this.stack.reset();
                result = {
                    done: true,
                    value: new RenderResult$1(env, program, updatingOpcodeStack.pop(), elementStack.popBlock())
                };
            }
            return result;
        }
        bindDynamicScope(names) {
            let scope = this.dynamicScope();
            for (let i = names.length - 1; i >= 0; i--) {
                let name = this.constants.getString(names[i]);
                scope.set(name, this.stack.pop());
            }
        }
    }

    class TemplateIteratorImpl$1 {
        constructor(vm) {
            this.vm = vm;
        }
        next() {
            return this.vm.next();
        }
    }
    function render$1(program, env, self, dynamicScope, builder, handle) {
        let vm = VM$1.initial(program, env, self, dynamicScope, builder, handle);
        return new TemplateIteratorImpl$1(vm);
    }

    /** @internal */

    class ArrayIterator {
        constructor(array, keyFor) {
            this.position = 0;
            this.array = array;
            this.keyFor = keyFor;
        }
        isEmpty() {
            return this.array.length === 0;
        }
        next() {
            let position = this.position,
                array = this.array,
                keyFor = this.keyFor;

            if (position >= array.length) return null;
            let value = array[position];
            let key = keyFor(value, position);
            let memo = position;
            this.position++;
            return { key, value, memo };
        }
    }
    class ObjectKeysIterator {
        constructor(keys, values, keyFor) {
            this.position = 0;
            this.keys = keys;
            this.values = values;
            this.keyFor = keyFor;
        }
        isEmpty() {
            return this.keys.length === 0;
        }
        next() {
            let position = this.position,
                keys = this.keys,
                values = this.values,
                keyFor = this.keyFor;

            if (position >= keys.length) return null;
            let value = values[position];
            let memo = keys[position];
            let key = keyFor(value, memo);
            this.position++;
            return { key, value, memo };
        }
    }
    class EmptyIterator {
        isEmpty() {
            return true;
        }
        next() {
            throw new Error(`Cannot call next() on an empty iterator`);
        }
    }
    const EMPTY_ITERATOR = new EmptyIterator();
    /** @internal */
    class Iterable {
        constructor(ref, keyFor) {
            this.tag = ref.tag;
            this.ref = ref;
            this.keyFor = keyFor;
        }
        iterate() {
            let ref = this.ref,
                keyFor = this.keyFor;

            let iterable = ref.value();
            if (Array.isArray(iterable)) {
                return iterable.length > 0 ? new ArrayIterator(iterable, keyFor) : EMPTY_ITERATOR;
            } else if (iterable === undefined || iterable === null) {
                return EMPTY_ITERATOR;
            } else if (iterable.forEach !== undefined) {
                let array = [];
                iterable.forEach(function (item) {
                    array.push(item);
                });
                return array.length > 0 ? new ArrayIterator(array, keyFor) : EMPTY_ITERATOR;
            } else if (typeof iterable === 'object') {
                let keys = Object.keys(iterable);
                return keys.length > 0 ? new ObjectKeysIterator(keys, keys.map(key => iterable[key]), keyFor) : EMPTY_ITERATOR;
            } else {
                throw new Error(`Don't know how to {{#each ${iterable}}}`);
            }
        }
        valueReferenceFor(item) {
            return new UpdatableReference(item.value);
        }
        updateValueReference(reference, item) {
            reference.update(item.value);
        }
        memoReferenceFor(item) {
            return new UpdatableReference(item.memo);
        }
        updateMemoReference(reference, item) {
            reference.update(item.memo);
        }
    }

    /** @internal */
    class Environment$2 extends Environment$1 {
        static create(options = {}) {
            options.document = options.document || self.document;
            options.appendOperations = options.appendOperations || new DOMTreeConstruction$1(options.document);
            return new Environment$2(options);
        }
        constructor(options) {
            super({ appendOperations: options.appendOperations, updateOperations: new DOMChanges$2(options.document || document) });
            setOwner(this, getOwner(options));
            // TODO - required for `protocolForURL` - seek alternative approach
            // e.g. see `installPlatformSpecificProtocolForURL` in Ember
            this.uselessAnchor = options.document.createElement('a');
        }
        protocolForURL(url) {
            // TODO - investigate alternative approaches
            // e.g. see `installPlatformSpecificProtocolForURL` in Ember
            this.uselessAnchor.href = url;
            return this.uselessAnchor.protocol;
        }
        iterableFor(ref, keyPath) {
            let keyFor;
            if (!keyPath) {
                throw new Error('Must specify a key for #each');
            }
            switch (keyPath) {
                case '@index':
                    keyFor = (_, index) => String(index);
                    break;
                case '@primitive':
                    keyFor = item => String(item);
                    break;
                default:
                    keyFor = item => item[keyPath];
                    break;
            }
            return new Iterable(ref, keyFor);
        }
        getOwner() {
            return getOwner(this);
        }
        setOwner(obj, owner) {
            setOwner(obj, owner);
        }
    }

    const DEFAULT_DOCUMENT = typeof document === 'object' ? document : null;
    /**
     * The central control point for starting and running Glimmer components.
     *
     * @public
     */
    class Application {
        constructor(options) {
            this._roots = [];
            this._rootsIndex = 0;
            this._initializers = [];
            this._initialized = false;
            this._rendering = false;
            this._rendered = false;
            this._scheduled = false;
            this._notifiers = [];
            this.rootName = options.rootName;
            this.resolver = options.resolver;
            debugAssert$2(options.loader, 'Must provide a Loader for preparing templates and other metadata required for a Glimmer Application.');
            debugAssert$2(options.renderer, 'Must provide a Renderer to render the templates produced by the Loader.');
            debugAssert$2(options.builder, 'Must provide a Builder that is responsible to building DOM.');
            this.document = options.document || DEFAULT_DOCUMENT;
            this.loader = options.loader;
            this.renderer = options.renderer;
            this.builder = options.builder;
        }
        /**
         * Renders a component by name into the provided element, and optionally
         * adjacent to the provided nextSibling element.
         *
         * ## Examples
         *
         * ```js
         * app.renderComponent('MyComponent', document.body, document.getElementById('my-footer'));
         * ```
         */
        renderComponent(component, parent, nextSibling = null) {
            let roots = this._roots,
                self = this._self;

            roots.push({ id: this._rootsIndex++, component, parent, nextSibling });
            // If we've already rendered, need to invalidate the root reference and
            // schedule a re-render for the new component to appear in DOM.
            if (self) {
                self.update({ roots });
                this.scheduleRerender();
            }
        }
        /**
         * Initializes the application and renders any components that have been
         * registered via [renderComponent].
         *
         * @public
         */
        async boot() {
            this.initialize();
            this.env = this.lookup(`environment:/${this.rootName}/main/main`);
            await this._render();
        }
        /**
         * Schedules all components to revalidate and potentially update the DOM to
         * reflect any changes to underlying component state.
         *
         * Generally speaking, you  should avoid calling `scheduleRerender()`
         * manually. Instead, use tracked properties on components and models, which
         * invoke this method for you automatically when appropriate.
         */
        scheduleRerender() {
            if (this._scheduled || !this._rendered) return;
            this._rendering = true;
            this._scheduled = true;
            setTimeout(async () => {
                this._scheduled = false;
                await this._rerender();
                this._rendering = false;
            }, 0);
        }
        /** @internal */
        initialize() {
            this.initRegistry();
            this.initContainer();
        }
        /** @internal */
        registerInitializer(initializer) {
            this._initializers.push(initializer);
        }
        /**
         * Initializes the registry, which maps names to objects in the system. Addons
         * and subclasses can customize the behavior of a Glimmer application by
         * overriding objects in the registry.
         *
         * @internal
         */
        initRegistry() {
            let registry = this._registry = new Registry();
            // Create ApplicationRegistry as a proxy to the underlying registry
            // that will only be available during `initialize`.
            let appRegistry = new ApplicationRegistry(this._registry, this.resolver);
            registry.register(`environment:/${this.rootName}/main/main`, Environment$2);
            registry.registerOption('helper', 'instantiate', false);
            registry.registerOption('template', 'instantiate', false);
            registry.register(`document:/${this.rootName}/main/main`, this.document);
            registry.registerOption('document', 'instantiate', false);
            registry.registerInjection('environment', 'document', `document:/${this.rootName}/main/main`);
            registry.registerInjection('component-manager', 'env', `environment:/${this.rootName}/main/main`);
            let initializers = this._initializers;
            for (let i = 0; i < initializers.length; i++) {
                initializers[i].initialize(appRegistry);
            }
            this._initialized = true;
        }
        /**
         * Initializes the container, which stores instances of objects that come from
         * the registry.
         *
         * @internal
         */
        initContainer() {
            this._container = new Container(this._registry, this.resolver);
            // Inject `this` (the app) as the "owner" of every object instantiated
            // by its container.
            this._container.defaultInjections = specifier => {
                let hash = {};
                setOwner(hash, this);
                return hash;
            };
        }
        /** @internal */
        async _render() {
            let env = this.env;
            // Create the template context for the root `main` template, which just
            // contains the array of component roots. Any property references in that
            // template will be looked up from this object.

            let self = this._self = new UpdatableReference({ roots: this._roots });
            // Create an empty root scope.
            let dynamicScope = new DynamicScope();
            let builder = this.builder.getBuilder(env);
            let templateIterator = await this.loader.getTemplateIterator(this, env, builder, dynamicScope, self);
            try {
                // Begin a new transaction. The transaction stores things like component
                // lifecycle events so they can be flushed once rendering has completed.
                env.begin();
                await this.renderer.render(templateIterator);
                // Finally, commit the transaction and flush component lifecycle hooks.
                env.commit();
                this._didRender();
            } catch (err) {
                this._didError(err);
            }
        }
        /**
         * Ensures the DOM is up-to-date by performing a revalidation on the root
         * template's render result. This method should not be called directly;
         * instead, any mutations in the program that could cause side-effects should
         * call `scheduleRerender()`, which ensures that DOM updates only happen once
         * at the end of the browser's event loop.
         *
         * @internal
         */
        async _rerender() {
            let env = this.env;

            try {
                env.begin();
                await this.renderer.rerender();
                env.commit();
                this._didRender();
            } catch (err) {
                this._didError(err);
            }
        }
        _didRender() {
            this._rendered = true;
            let notifiers = this._notifiers;
            this._notifiers = [];
            notifiers.forEach(n => n[0]());
        }
        _didError(err) {
            let notifiers = this._notifiers;
            this._notifiers = [];
            notifiers.forEach(n => n[1](err));
        }
        /**
         * Owner interface implementation
         *
         * @internal
         */
        identify(specifier, referrer) {
            return this.resolver.identify(specifier, referrer);
        }
        /** @internal */
        factoryFor(specifier, referrer) {
            return this._container.factoryFor(this.identify(specifier, referrer));
        }
        /** @internal */
        lookup(specifier, referrer) {
            return this._container.lookup(this.identify(specifier, referrer));
        }
    }

    class TypedRegistry {
        constructor() {
            this.byName = dict$2();
            this.byHandle = dict$2();
        }
        hasName(name) {
            return name in this.byName;
        }
        getHandle(name) {
            return this.byName[name];
        }
        hasHandle(name) {
            return name in this.byHandle;
        }
        getByHandle(handle) {
            return this.byHandle[handle];
        }
        register(handle, name, value) {
            this.byHandle[handle] = value;
            this.byName[name] = handle;
        }
    }

    class HelperReference extends CachedReference$1 {
        constructor(helper, args) {
            super();
            this.helper = helper;
            this.tag = args.tag;
            this.args = args.capture();
        }
        compute() {
            let helper = this.helper,
                args = this.args;

            return helper(args.positional.value(), args.named.value());
        }
    }

    var Opcodes;
    (function (Opcodes) {
        // Statements
        Opcodes[Opcodes["Text"] = 0] = "Text";
        Opcodes[Opcodes["Append"] = 1] = "Append";
        Opcodes[Opcodes["Comment"] = 2] = "Comment";
        Opcodes[Opcodes["Modifier"] = 3] = "Modifier";
        Opcodes[Opcodes["Block"] = 4] = "Block";
        Opcodes[Opcodes["Component"] = 5] = "Component";
        Opcodes[Opcodes["OpenElement"] = 6] = "OpenElement";
        Opcodes[Opcodes["OpenSplattedElement"] = 7] = "OpenSplattedElement";
        Opcodes[Opcodes["FlushElement"] = 8] = "FlushElement";
        Opcodes[Opcodes["CloseElement"] = 9] = "CloseElement";
        Opcodes[Opcodes["StaticAttr"] = 10] = "StaticAttr";
        Opcodes[Opcodes["DynamicAttr"] = 11] = "DynamicAttr";
        Opcodes[Opcodes["AttrSplat"] = 12] = "AttrSplat";
        Opcodes[Opcodes["Yield"] = 13] = "Yield";
        Opcodes[Opcodes["Partial"] = 14] = "Partial";
        Opcodes[Opcodes["DynamicArg"] = 15] = "DynamicArg";
        Opcodes[Opcodes["StaticArg"] = 16] = "StaticArg";
        Opcodes[Opcodes["TrustingAttr"] = 17] = "TrustingAttr";
        Opcodes[Opcodes["Debugger"] = 18] = "Debugger";
        Opcodes[Opcodes["ClientSideStatement"] = 19] = "ClientSideStatement";
        // Expressions
        Opcodes[Opcodes["Unknown"] = 20] = "Unknown";
        Opcodes[Opcodes["Get"] = 21] = "Get";
        Opcodes[Opcodes["MaybeLocal"] = 22] = "MaybeLocal";
        Opcodes[Opcodes["HasBlock"] = 23] = "HasBlock";
        Opcodes[Opcodes["HasBlockParams"] = 24] = "HasBlockParams";
        Opcodes[Opcodes["Undefined"] = 25] = "Undefined";
        Opcodes[Opcodes["Helper"] = 26] = "Helper";
        Opcodes[Opcodes["Concat"] = 27] = "Concat";
        Opcodes[Opcodes["ClientSideExpression"] = 28] = "ClientSideExpression";
    })(Opcodes || (Opcodes = {}));

    function is(variant) {
        return function (value) {
            return Array.isArray(value) && value[0] === variant;
        };
    }
    // Statements
    const isModifier = is(Opcodes.Modifier);
    const isFlushElement = is(Opcodes.FlushElement);
    // Expressions
    const isGet = is(Opcodes.Get);
    const isMaybeLocal = is(Opcodes.MaybeLocal);

    var Ops;
    (function (Ops) {
        Ops[Ops["OpenComponentElement"] = 0] = "OpenComponentElement";
        Ops[Ops["DidCreateElement"] = 1] = "DidCreateElement";
        Ops[Ops["SetComponentAttrs"] = 2] = "SetComponentAttrs";
        Ops[Ops["DidRenderLayout"] = 3] = "DidRenderLayout";
        Ops[Ops["Debugger"] = 4] = "Debugger";
    })(Ops || (Ops = {}));

    var Ops$1 = Opcodes;
    const ATTRS_BLOCK = '&attrs';
    class Compilers {
        constructor(offset = 0) {
            this.offset = offset;
            this.names = dict$2();
            this.funcs = [];
        }
        add(name, func) {
            this.funcs.push(func);
            this.names[name] = this.funcs.length - 1;
        }
        compile(sexp, builder) {
            let name = sexp[this.offset];
            let index = this.names[name];
            let func = this.funcs[index];

            func(sexp, builder);
        }
    }
    let _statementCompiler;
    function statementCompiler() {
        if (_statementCompiler) {
            return _statementCompiler;
        }
        const STATEMENTS = _statementCompiler = new Compilers();
        STATEMENTS.add(Ops$1.Text, (sexp, builder) => {
            builder.text(sexp[1]);
        });
        STATEMENTS.add(Ops$1.Comment, (sexp, builder) => {
            builder.comment(sexp[1]);
        });
        STATEMENTS.add(Ops$1.CloseElement, (_sexp, builder) => {
            builder.closeElement();
        });
        STATEMENTS.add(Ops$1.FlushElement, (_sexp, builder) => {
            builder.flushElement();
        });
        STATEMENTS.add(Ops$1.Modifier, (sexp, builder) => {
            let referrer = builder.referrer;
            let name = sexp[1],
                params = sexp[2],
                hash = sexp[3];

            let handle = builder.compiler.resolveModifier(name, referrer);
            if (handle !== null) {
                builder.modifier(handle, params, hash);
            } else {
                throw new Error(`Compile Error ${name} is not a modifier: Helpers may not be used in the element form.`);
            }
        });
        STATEMENTS.add(Ops$1.StaticAttr, (sexp, builder) => {
            let name = sexp[1],
                value = sexp[2],
                namespace = sexp[3];

            builder.staticAttr(name, namespace, value);
        });
        STATEMENTS.add(Ops$1.DynamicAttr, (sexp, builder) => {
            dynamicAttr(sexp, false, builder);
        });
        STATEMENTS.add(Ops$1.TrustingAttr, (sexp, builder) => {
            dynamicAttr(sexp, true, builder);
        });
        STATEMENTS.add(Ops$1.OpenElement, (sexp, builder) => {
            builder.openPrimitiveElement(sexp[1]);
        });
        STATEMENTS.add(Ops$1.OpenSplattedElement, (sexp, builder) => {
            builder.setComponentAttrs(true);
            builder.putComponentOperations();
            builder.openPrimitiveElement(sexp[1]);
        });
        STATEMENTS.add(Ops$1.Component, (sexp, builder) => {
            let tag = sexp[1],
                _attrs = sexp[2],
                args = sexp[3],
                block = sexp[4];
            let referrer = builder.referrer;

            var _builder$compiler$res = builder.compiler.resolveLayoutForTag(tag, referrer);

            let handle = _builder$compiler$res.handle,
                capabilities = _builder$compiler$res.capabilities,
                compilable = _builder$compiler$res.compilable;

            if (handle !== null && capabilities !== null) {
                let attrs = [[Ops$1.ClientSideStatement, Ops.SetComponentAttrs, true], ..._attrs, [Ops$1.ClientSideStatement, Ops.SetComponentAttrs, false]];
                let attrsBlock = builder.inlineBlock({ statements: attrs, parameters: EMPTY_ARRAY$2 });
                let child = builder.template(block);
                if (compilable) {
                    builder.pushComponentDefinition(handle);
                    builder.invokeStaticComponent(capabilities, compilable, attrsBlock, null, args, false, child && child);
                } else {
                    builder.pushComponentDefinition(handle);
                    builder.invokeComponent(capabilities, attrsBlock, null, args, false, child && child);
                }
            } else {
                throw new Error(`Compile Error: Cannot find component ${tag}`);
            }
        });
        STATEMENTS.add(Ops$1.Partial, (sexp, builder) => {
            let name = sexp[1],
                evalInfo = sexp[2];
            let referrer = builder.referrer;

            builder.replayableIf({
                args() {
                    builder.expr(name);
                    builder.dup();
                    return 2;
                },
                ifTrue() {
                    builder.invokePartial(referrer, builder.evalSymbols(), evalInfo);
                    builder.popScope();
                    builder.popFrame(); // FIXME: WAT
                }
            });
        });
        STATEMENTS.add(Ops$1.Yield, (sexp, builder) => {
            let to = sexp[1],
                params = sexp[2];

            builder.yield(to, params);
        });
        STATEMENTS.add(Ops$1.AttrSplat, (sexp, builder) => {
            let to = sexp[1];

            builder.yield(to, []);
            builder.setComponentAttrs(false);
        });
        STATEMENTS.add(Ops$1.Debugger, (sexp, builder) => {
            let evalInfo = sexp[1];

            builder.debugger(builder.evalSymbols(), evalInfo);
        });
        STATEMENTS.add(Ops$1.ClientSideStatement, (sexp, builder) => {
            CLIENT_SIDE.compile(sexp, builder);
        });
        STATEMENTS.add(Ops$1.Append, (sexp, builder) => {
            let value = sexp[1],
                trusting = sexp[2];

            let returned = builder.compileInline(sexp) || value;
            if (returned === true) return;
            builder.guardedAppend(value, trusting);
        });
        STATEMENTS.add(Ops$1.Block, (sexp, builder) => {
            let name = sexp[1],
                params = sexp[2],
                hash = sexp[3],
                _template = sexp[4],
                _inverse = sexp[5];

            let template = builder.template(_template);
            let inverse = builder.template(_inverse);
            let templateBlock = template && template;
            let inverseBlock = inverse && inverse;
            builder.compileBlock(name, params, hash, templateBlock, inverseBlock);
        });
        const CLIENT_SIDE = new Compilers(1);
        CLIENT_SIDE.add(Ops.OpenComponentElement, (sexp, builder) => {
            builder.putComponentOperations();
            builder.openPrimitiveElement(sexp[2]);
        });
        CLIENT_SIDE.add(Ops.DidCreateElement, (_sexp, builder) => {
            builder.didCreateElement(Register$1.s0);
        });
        CLIENT_SIDE.add(Ops.SetComponentAttrs, (sexp, builder) => {
            builder.setComponentAttrs(sexp[2]);
        });
        CLIENT_SIDE.add(Ops.Debugger, () => {
            // tslint:disable-next-line:no-debugger
            debugger;
        });
        CLIENT_SIDE.add(Ops.DidRenderLayout, (_sexp, builder) => {
            builder.didRenderLayout(Register$1.s0);
        });
        return STATEMENTS;
    }
    function dynamicAttr(sexp, trusting, builder) {
        let name = sexp[1],
            value = sexp[2],
            namespace = sexp[3];

        builder.expr(value);
        if (namespace) {
            builder.dynamicAttr(name, namespace, trusting);
        } else {
            builder.dynamicAttr(name, null, trusting);
        }
    }
    let _expressionCompiler;
    function expressionCompiler() {
        if (_expressionCompiler) {
            return _expressionCompiler;
        }
        const EXPRESSIONS = _expressionCompiler = new Compilers();
        EXPRESSIONS.add(Ops$1.Unknown, (sexp, builder) => {
            let compiler = builder.compiler,
                referrer = builder.referrer,
                asPartial = builder.containingLayout.asPartial;

            let name = sexp[1];
            let handle = compiler.resolveHelper(name, referrer);
            if (handle !== null) {
                builder.helper(handle, null, null);
            } else if (asPartial) {
                builder.resolveMaybeLocal(name);
            } else {
                builder.getVariable(0);
                builder.getProperty(name);
            }
        });
        EXPRESSIONS.add(Ops$1.Concat, (sexp, builder) => {
            let parts = sexp[1];
            for (let i = 0; i < parts.length; i++) {
                builder.expr(parts[i]);
            }
            builder.concat(parts.length);
        });
        EXPRESSIONS.add(Ops$1.Helper, (sexp, builder) => {
            let compiler = builder.compiler,
                referrer = builder.referrer;
            let name = sexp[1],
                params = sexp[2],
                hash = sexp[3];
            // TODO: triage this in the WF compiler

            if (name === 'component') {

                let definition = params[0],
                    restArgs = params.slice(1);

                builder.curryComponent(definition, restArgs, hash, true);
                return;
            }
            let handle = compiler.resolveHelper(name, referrer);
            if (handle !== null) {
                builder.helper(handle, params, hash);
            } else {
                throw new Error(`Compile Error: ${name} is not a helper`);
            }
        });
        EXPRESSIONS.add(Ops$1.Get, (sexp, builder) => {
            let head = sexp[1],
                path = sexp[2];

            builder.getVariable(head);
            for (let i = 0; i < path.length; i++) {
                builder.getProperty(path[i]);
            }
        });
        EXPRESSIONS.add(Ops$1.MaybeLocal, (sexp, builder) => {
            let path = sexp[1];

            if (builder.containingLayout.asPartial) {
                let head = path[0];
                path = path.slice(1);
                builder.resolveMaybeLocal(head);
            } else {
                builder.getVariable(0);
            }
            for (let i = 0; i < path.length; i++) {
                builder.getProperty(path[i]);
            }
        });
        EXPRESSIONS.add(Ops$1.Undefined, (_sexp, builder) => {
            return builder.pushPrimitiveReference(undefined);
        });
        EXPRESSIONS.add(Ops$1.HasBlock, (sexp, builder) => {
            builder.hasBlock(sexp[1]);
        });
        EXPRESSIONS.add(Ops$1.HasBlockParams, (sexp, builder) => {
            builder.hasBlockParams(sexp[1]);
        });
        return EXPRESSIONS;
    }
    class Macros {
        constructor() {
            var _populateBuiltins = populateBuiltins();

            let blocks = _populateBuiltins.blocks,
                inlines = _populateBuiltins.inlines;

            this.blocks = blocks;
            this.inlines = inlines;
        }
    }
    class Blocks {
        constructor() {
            this.names = dict$2();
            this.funcs = [];
        }
        add(name, func) {
            this.funcs.push(func);
            this.names[name] = this.funcs.length - 1;
        }
        addMissing(func) {
            this.missing = func;
        }
        compile(name, params, hash, template, inverse, builder) {
            let index = this.names[name];
            if (index === undefined) {

                let func = this.missing;
                let handled = func(name, params, hash, template, inverse, builder);
            } else {
                let func = this.funcs[index];
                func(params, hash, template, inverse, builder);
            }
        }
    }
    class Inlines {
        constructor() {
            this.names = dict$2();
            this.funcs = [];
        }
        add(name, func) {
            this.funcs.push(func);
            this.names[name] = this.funcs.length - 1;
        }
        addMissing(func) {
            this.missing = func;
        }
        compile(sexp, builder) {
            let value = sexp[1];
            // TODO: Fix this so that expression macros can return
            // things like components, so that {{component foo}}
            // is the same as {{(component foo)}}
            if (!Array.isArray(value)) return ['expr', value];
            let name;
            let params;
            let hash;
            if (value[0] === Ops$1.Helper) {
                name = value[1];
                params = value[2];
                hash = value[3];
            } else if (value[0] === Ops$1.Unknown) {
                name = value[1];
                params = hash = null;
            } else {
                return ['expr', value];
            }
            let index = this.names[name];
            if (index === undefined && this.missing) {
                let func = this.missing;
                let returned = func(name, params, hash, builder);
                return returned === false ? ['expr', value] : returned;
            } else if (index !== undefined) {
                let func = this.funcs[index];
                let returned = func(name, params, hash, builder);
                return returned === false ? ['expr', value] : returned;
            } else {
                return ['expr', value];
            }
        }
    }
    function populateBuiltins(blocks = new Blocks(), inlines = new Inlines()) {
        blocks.add('if', (params, _hash, template, inverse, builder) => {
            //        PutArgs
            //        Test(Environment)
            //        Enter(BEGIN, END)
            // BEGIN: Noop
            //        JumpUnless(ELSE)
            //        Evaluate(default)
            //        Jump(END)
            // ELSE:  Noop
            //        Evalulate(inverse)
            // END:   Noop
            //        Exit
            if (!params || params.length !== 1) {
                throw new Error(`SYNTAX ERROR: #if requires a single argument`);
            }
            builder.replayableIf({
                args() {
                    builder.expr(params[0]);
                    builder.toBoolean();
                    return 1;
                },
                ifTrue() {
                    builder.invokeStaticBlock(template);
                },
                ifFalse() {
                    if (inverse) {
                        builder.invokeStaticBlock(inverse);
                    }
                }
            });
        });
        blocks.add('unless', (params, _hash, template, inverse, builder) => {
            //        PutArgs
            //        Test(Environment)
            //        Enter(BEGIN, END)
            // BEGIN: Noop
            //        JumpUnless(ELSE)
            //        Evaluate(default)
            //        Jump(END)
            // ELSE:  Noop
            //        Evalulate(inverse)
            // END:   Noop
            //        Exit
            if (!params || params.length !== 1) {
                throw new Error(`SYNTAX ERROR: #unless requires a single argument`);
            }
            builder.replayableIf({
                args() {
                    builder.expr(params[0]);
                    builder.toBoolean();
                    return 1;
                },
                ifTrue() {
                    if (inverse) {
                        builder.invokeStaticBlock(inverse);
                    }
                },
                ifFalse() {
                    builder.invokeStaticBlock(template);
                }
            });
        });
        blocks.add('with', (params, _hash, template, inverse, builder) => {
            //        PutArgs
            //        Test(Environment)
            //        Enter(BEGIN, END)
            // BEGIN: Noop
            //        JumpUnless(ELSE)
            //        Evaluate(default)
            //        Jump(END)
            // ELSE:  Noop
            //        Evalulate(inverse)
            // END:   Noop
            //        Exit
            if (!params || params.length !== 1) {
                throw new Error(`SYNTAX ERROR: #with requires a single argument`);
            }
            builder.replayableIf({
                args() {
                    builder.expr(params[0]);
                    builder.dup();
                    builder.toBoolean();
                    return 2;
                },
                ifTrue() {
                    builder.invokeStaticBlock(template, 1);
                },
                ifFalse() {
                    if (inverse) {
                        builder.invokeStaticBlock(inverse);
                    }
                }
            });
        });
        blocks.add('each', (params, hash, template, inverse, builder) => {
            //         Enter(BEGIN, END)
            // BEGIN:  Noop
            //         PutArgs
            //         PutIterable
            //         JumpUnless(ELSE)
            //         EnterList(BEGIN2, END2)
            // ITER:   Noop
            //         NextIter(BREAK)
            // BEGIN2: Noop
            //         PushChildScope
            //         Evaluate(default)
            //         PopScope
            // END2:   Noop
            //         Exit
            //         Jump(ITER)
            // BREAK:  Noop
            //         ExitList
            //         Jump(END)
            // ELSE:   Noop
            //         Evalulate(inverse)
            // END:    Noop
            //         Exit
            builder.replayable({
                args() {
                    if (hash && hash[0][0] === 'key') {
                        builder.expr(hash[1][0]);
                    } else {
                        builder.pushPrimitiveReference(null);
                    }
                    builder.expr(params[0]);
                    return 2;
                },
                body() {
                    builder.putIterator();
                    builder.jumpUnless('ELSE');
                    builder.pushFrame();
                    builder.dup(Register$1.fp, 1);
                    builder.returnTo('ITER');
                    builder.enterList('BODY');
                    builder.label('ITER');
                    builder.iterate('BREAK');
                    builder.label('BODY');
                    builder.invokeStaticBlock(template, 2);
                    builder.pop(2);
                    builder.jump('FINALLY');
                    builder.label('BREAK');
                    builder.exitList();
                    builder.popFrame();
                    builder.jump('FINALLY');
                    builder.label('ELSE');
                    if (inverse) {
                        builder.invokeStaticBlock(inverse);
                    }
                }
            });
        });
        blocks.add('in-element', (params, hash, template, _inverse, builder) => {
            if (!params || params.length !== 1) {
                throw new Error(`SYNTAX ERROR: #in-element requires a single argument`);
            }
            builder.replayableIf({
                args() {
                    let keys = hash[0],
                        values = hash[1];

                    for (let i = 0; i < keys.length; i++) {
                        let key = keys[i];
                        if (key === 'nextSibling' || key === 'guid') {
                            builder.expr(values[i]);
                        } else {
                            throw new Error(`SYNTAX ERROR: #in-element does not take a \`${keys[0]}\` option`);
                        }
                    }
                    builder.expr(params[0]);
                    builder.dup();
                    return 4;
                },
                ifTrue() {
                    builder.pushRemoteElement();
                    builder.invokeStaticBlock(template);
                    builder.popRemoteElement();
                }
            });
        });
        blocks.add('-with-dynamic-vars', (_params, hash, template, _inverse, builder) => {
            if (hash) {
                let names = hash[0],
                    expressions = hash[1];

                builder.compileParams(expressions);
                builder.pushDynamicScope();
                builder.bindDynamicScope(names);
                builder.invokeStaticBlock(template);
                builder.popDynamicScope();
            } else {
                builder.invokeStaticBlock(template);
            }
        });
        blocks.add('component', (_params, hash, template, inverse, builder) => {

            let tag = _params[0];
            if (typeof tag === 'string') {
                let returned = builder.staticComponentHelper(_params[0], hash, template);
                if (returned) return;
            }

            let definition = _params[0],
                params = _params.slice(1);

            builder.dynamicComponent(definition, params, hash, true, template, inverse);
        });
        inlines.add('component', (_name, _params, hash, builder) => {

            let tag = _params && _params[0];
            if (typeof tag === 'string') {
                let returned = builder.staticComponentHelper(tag, hash, null);
                if (returned) return true;
            }

            let definition = _params[0],
                params = _params.slice(1);

            builder.dynamicComponent(definition, params, hash, true, null, null);
            return true;
        });
        return { blocks, inlines };
    }

    const PLACEHOLDER_HANDLE$1 = -1;
    class CompilableProgram {
        constructor(compiler, layout) {
            this.compiler = compiler;
            this.layout = layout;
            this.compiled = null;
        }
        get symbolTable() {
            return this.layout.block;
        }
        compile() {
            if (this.compiled !== null) return this.compiled;
            this.compiled = PLACEHOLDER_HANDLE$1;
            let statements = this.layout.block.statements;

            return this.compiled = this.compiler.add(statements, this.layout);
        }
    }
    class CompilableBlock {
        constructor(compiler, parsed) {
            this.compiler = compiler;
            this.parsed = parsed;
            this.compiled = null;
        }
        get symbolTable() {
            return this.parsed.block;
        }
        compile() {
            if (this.compiled !== null) return this.compiled;
            // Track that compilation has started but not yet finished by temporarily
            // using a placeholder handle. In eager compilation mode, where compile()
            // may be called recursively, we use this as a signal that the handle cannot
            // be known synchronously and must be linked lazily.
            this.compiled = PLACEHOLDER_HANDLE$1;
            var _parsed = this.parsed;
            let statements = _parsed.block.statements,
                containingLayout = _parsed.containingLayout;

            return this.compiled = this.compiler.add(statements, containingLayout);
        }
    }

    function compile(statements, builder, compiler) {
        let sCompiler = statementCompiler();
        for (let i = 0; i < statements.length; i++) {
            sCompiler.compile(statements[i], builder);
        }
        let handle = builder.commit();
        return handle;
    }

    class StdLib {
        constructor(main, trustingGuardedAppend, cautiousGuardedAppend) {
            this.main = main;
            this.trustingGuardedAppend = trustingGuardedAppend;
            this.cautiousGuardedAppend = cautiousGuardedAppend;
        }
        static compile(compiler) {
            let main = this.std(compiler, b => b.main());
            let trustingGuardedAppend = this.std(compiler, b => b.stdAppend(true));
            let cautiousGuardedAppend = this.std(compiler, b => b.stdAppend(false));
            return new StdLib(main, trustingGuardedAppend, cautiousGuardedAppend);
        }
        static std(compiler, callback) {
            return StdOpcodeBuilder.build(compiler, callback);
        }
        getAppend(trusting) {
            return trusting ? this.trustingGuardedAppend : this.cautiousGuardedAppend;
        }
    }
    class AbstractCompiler {
        constructor(macros, program, resolver) {
            this.macros = macros;
            this.program = program;
            this.resolver = resolver;
            this.initialize();
        }
        initialize() {
            this.stdLib = StdLib.compile(this);
        }
        get constants() {
            return this.program.constants;
        }
        compileInline(sexp, builder) {
            let inlines = this.macros.inlines;

            return inlines.compile(sexp, builder);
        }
        compileBlock(name, params, hash, template, inverse, builder) {
            let blocks = this.macros.blocks;

            blocks.compile(name, params, hash, template, inverse, builder);
        }
        add(statements, containingLayout) {
            return compile(statements, this.builderFor(containingLayout), this);
        }
        commit(scopeSize, buffer) {
            let heap = this.program.heap;
            // TODO: change the whole malloc API and do something more efficient
            let handle = heap.malloc();
            for (let i = 0; i < buffer.length; i++) {
                let value = buffer[i];
                if (typeof value === 'function') {
                    heap.pushPlaceholder(value);
                } else {
                    heap.push(value);
                }
            }
            heap.finishMalloc(handle, scopeSize);
            return handle;
        }
        resolveLayoutForTag(tag, referrer) {
            let resolver = this.resolver;

            let handle = resolver.lookupComponentDefinition(tag, referrer);
            if (handle === null) return { handle: null, capabilities: null, compilable: null };
            return this.resolveLayoutForHandle(handle);
        }
        resolveLayoutForHandle(handle) {
            let resolver = this.resolver;

            let capabilities = resolver.getCapabilities(handle);
            let compilable = null;
            if (!capabilities.dynamicLayout) {
                compilable = resolver.getLayout(handle);
            }
            return {
                handle,
                capabilities,
                compilable
            };
        }
        resolveModifier(name, referrer) {
            return this.resolver.lookupModifier(name, referrer);
        }
        resolveHelper(name, referrer) {
            return this.resolver.lookupHelper(name, referrer);
        }
    }

    class WrappedBuilder {
        constructor(compiler, layout) {
            this.compiler = compiler;
            this.layout = layout;
            this.compiled = null;
            let block = layout.block;

            this.symbolTable = {
                hasEval: block.hasEval,
                symbols: block.symbols.concat([ATTRS_BLOCK])
            };
        }
        compile() {
            if (this.compiled !== null) return this.compiled;
            //========DYNAMIC
            //        PutValue(TagExpr)
            //        Test
            //        JumpUnless(BODY)
            //        OpenDynamicPrimitiveElement
            //        DidCreateElement
            //        ...attr statements...
            //        FlushElement
            // BODY:  Noop
            //        ...body statements...
            //        PutValue(TagExpr)
            //        Test
            //        JumpUnless(END)
            //        CloseElement
            // END:   Noop
            //        DidRenderLayout
            //        Exit
            //
            //========STATIC
            //        OpenPrimitiveElementOpcode
            //        DidCreateElement
            //        ...attr statements...
            //        FlushElement
            //        ...body statements...
            //        CloseElement
            //        DidRenderLayout
            //        Exit
            let compiler = this.compiler,
                layout = this.layout;

            let b = compiler.builderFor(layout);
            b.startLabels();
            b.fetch(Register$1.s1);
            b.getComponentTagName(Register$1.s0);
            b.primitiveReference();
            b.dup();
            b.load(Register$1.s1);
            b.jumpUnless('BODY');
            b.fetch(Register$1.s1);
            b.putComponentOperations();
            b.openDynamicElement();
            b.didCreateElement(Register$1.s0);
            b.flushElement();
            b.label('BODY');
            b.invokeStaticBlock(blockFor(layout, compiler));
            b.fetch(Register$1.s1);
            b.jumpUnless('END');
            b.closeElement();
            b.label('END');
            b.load(Register$1.s1);
            b.stopLabels();
            let handle = b.commit();
            return this.compiled = handle;
        }
    }
    function blockFor(layout, compiler) {
        return new CompilableBlock(compiler, {
            block: {
                statements: layout.block.statements,
                parameters: EMPTY_ARRAY$2
            },
            containingLayout: layout
        });
    }
    class ComponentBuilder {
        constructor(builder) {
            this.builder = builder;
        }
        static(handle, args) {
            let params = args[0],
                hash = args[1],
                _default = args[2],
                inverse = args[3];
            let builder = this.builder;

            if (handle !== null) {
                var _builder$compiler$res = builder.compiler.resolveLayoutForHandle(handle);

                let capabilities = _builder$compiler$res.capabilities,
                    compilable = _builder$compiler$res.compilable;

                if (compilable) {
                    builder.pushComponentDefinition(handle);
                    builder.invokeStaticComponent(capabilities, compilable, null, params, hash, false, _default, inverse);
                } else {
                    builder.pushComponentDefinition(handle);
                    builder.invokeComponent(capabilities, null, params, hash, false, _default, inverse);
                }
            }
        }
    }

    class InstructionEncoder {
        constructor(buffer) {
            this.buffer = buffer;
            this.typePos = 0;
            this.size = 0;
        }
        encode(type, machine) {
            if (type > 255 /* TYPE_SIZE */) {
                    throw new Error(`Opcode type over 8-bits. Got ${type}.`);
                }
            this.buffer.push(type | machine | arguments.length - 2 << 8 /* ARG_SHIFT */);
            this.typePos = this.buffer.length - 1;
            for (let i = 2; i < arguments.length; i++) {
                let op = arguments[i];
                if (typeof op === 'number' && op > 65535 /* MAX_SIZE */) {
                        throw new Error(`Operand over 16-bits. Got ${op}.`);
                    }
                this.buffer.push(op);
            }
            this.size = this.buffer.length;
        }
        patch(position, target) {
            if (this.buffer[position + 1] === -1) {
                this.buffer[position + 1] = target;
            } else {
                throw new Error('Trying to patch operand in populated slot instead of a reserved slot.');
            }
        }
        patchWith(position, target, operand) {
            if (this.buffer[position + 1] === -1) {
                this.buffer[position + 1] = target;
                this.buffer[position + 2] = operand;
            } else {
                throw new Error('Trying to patch operand in populated slot instead of a reserved slot.');
            }
        }
    }

    class Labels {
        constructor() {
            this.labels = dict$2();
            this.targets = [];
        }
        label(name, index) {
            this.labels[name] = index;
        }
        target(at, target) {
            this.targets.push({ at, target });
        }
        patch(encoder) {
            let targets = this.targets,
                labels = this.labels;

            for (let i = 0; i < targets.length; i++) {
                var _targets$i = targets[i];
                let at = _targets$i.at,
                    target = _targets$i.target;

                let address = labels[target] - at;
                encoder.patch(at, address);
            }
        }
    }
    class StdOpcodeBuilder {
        constructor(compiler, size = 0) {
            this.size = size;
            this.encoder = new InstructionEncoder([]);
            this.labelsStack = new Stack$3();
            this.compiler = compiler;
        }
        static build(compiler, callback) {
            let builder = new StdOpcodeBuilder(compiler);
            callback(builder);
            return builder.commit();
        }
        push(name) {
            switch (arguments.length) {
                case 1:
                    return this.encoder.encode(name, 0);
                case 2:
                    return this.encoder.encode(name, 0, arguments[1]);
                case 3:
                    return this.encoder.encode(name, 0, arguments[1], arguments[2]);
                default:
                    return this.encoder.encode(name, 0, arguments[1], arguments[2], arguments[3]);
            }
        }
        pushMachine(name) {
            switch (arguments.length) {
                case 1:
                    return this.encoder.encode(name, 1024 /* MACHINE_MASK */);
                case 2:
                    return this.encoder.encode(name, 1024 /* MACHINE_MASK */, arguments[1]);
                case 3:
                    return this.encoder.encode(name, 1024 /* MACHINE_MASK */, arguments[1], arguments[2]);
                default:
                    return this.encoder.encode(name, 1024 /* MACHINE_MASK */, arguments[1], arguments[2], arguments[3]);
            }
        }
        commit() {
            this.pushMachine(24 /* Return */);
            return this.compiler.commit(this.size, this.encoder.buffer);
        }
        reserve(name) {
            this.encoder.encode(name, 0, -1);
        }
        reserveWithOperand(name, operand) {
            this.encoder.encode(name, 0, -1, operand);
        }
        reserveMachine(name) {
            this.encoder.encode(name, 1024 /* MACHINE_MASK */, -1);
        }
        ///
        main() {
            this.push(68 /* Main */, Register$1.s0);
            this.invokePreparedComponent(false, false, true);
        }
        appendHTML() {
            this.push(28 /* AppendHTML */);
        }
        appendSafeHTML() {
            this.push(29 /* AppendSafeHTML */);
        }
        appendDocumentFragment() {
            this.push(30 /* AppendDocumentFragment */);
        }
        appendNode() {
            this.push(31 /* AppendNode */);
        }
        appendText() {
            this.push(32 /* AppendText */);
        }
        beginComponentTransaction() {
            this.push(91 /* BeginComponentTransaction */);
        }
        commitComponentTransaction() {
            this.push(92 /* CommitComponentTransaction */);
        }
        pushDynamicScope() {
            this.push(44 /* PushDynamicScope */);
        }
        popDynamicScope() {
            this.push(45 /* PopDynamicScope */);
        }
        pushRemoteElement() {
            this.push(41 /* PushRemoteElement */);
        }
        popRemoteElement() {
            this.push(42 /* PopRemoteElement */);
        }
        pushRootScope(symbols, bindCallerScope) {
            this.push(20 /* RootScope */, symbols, bindCallerScope ? 1 : 0);
        }
        pushVirtualRootScope(register) {
            this.push(21 /* VirtualRootScope */, register);
        }
        pushChildScope() {
            this.push(22 /* ChildScope */);
        }
        popScope() {
            this.push(23 /* PopScope */);
        }
        prepareArgs(state) {
            this.push(79 /* PrepareArgs */, state);
        }
        createComponent(state, hasDefault) {
            let flag = hasDefault | 0;
            this.push(81 /* CreateComponent */, flag, state);
        }
        registerComponentDestructor(state) {
            this.push(82 /* RegisterComponentDestructor */, state);
        }
        putComponentOperations() {
            this.push(83 /* PutComponentOperations */);
        }
        getComponentSelf(state) {
            this.push(84 /* GetComponentSelf */, state);
        }
        getComponentTagName(state) {
            this.push(85 /* GetComponentTagName */, state);
        }
        getComponentLayout(state) {
            this.push(86 /* GetComponentLayout */, state);
        }
        setupForEval(state) {
            this.push(87 /* SetupForEval */, state);
        }
        invokeComponentLayout(state) {
            this.push(90 /* InvokeComponentLayout */, state);
        }
        didCreateElement(state) {
            this.push(93 /* DidCreateElement */, state);
        }
        didRenderLayout(state) {
            this.push(94 /* DidRenderLayout */, state);
        }
        pushFrame() {
            this.pushMachine(57 /* PushFrame */);
        }
        popFrame() {
            this.pushMachine(58 /* PopFrame */);
        }
        pushSmallFrame() {
            this.pushMachine(59 /* PushSmallFrame */);
        }
        popSmallFrame() {
            this.pushMachine(60 /* PopSmallFrame */);
        }
        invokeVirtual() {
            this.pushMachine(49 /* InvokeVirtual */);
        }
        invokeYield() {
            this.push(51 /* InvokeYield */);
        }
        toBoolean() {
            this.push(63 /* ToBoolean */);
        }
        invokePreparedComponent(hasBlock, bindableBlocks, bindableAtNames, populateLayout = null) {
            this.beginComponentTransaction();
            this.pushDynamicScope();
            this.createComponent(Register$1.s0, hasBlock);
            // this has to run after createComponent to allow
            // for late-bound layouts, but a caller is free
            // to populate the layout earlier if it wants to
            // and do nothing here.
            if (populateLayout) populateLayout();
            this.registerComponentDestructor(Register$1.s0);
            this.getComponentSelf(Register$1.s0);
            this.pushVirtualRootScope(Register$1.s0);
            this.setVariable(0);
            this.setupForEval(Register$1.s0);
            if (bindableAtNames) this.setNamedVariables(Register$1.s0);
            if (bindableBlocks) this.setBlocks(Register$1.s0);
            this.pop();
            this.invokeComponentLayout(Register$1.s0);
            this.didRenderLayout(Register$1.s0);
            this.popFrame();
            this.popScope();
            this.popDynamicScope();
            this.commitComponentTransaction();
        }
        get pos() {
            return this.encoder.typePos;
        }
        get nextPos() {
            return this.encoder.size;
        }
        ///
        compileInline(sexp) {
            return this.compiler.compileInline(sexp, this);
        }
        compileBlock(name, params, hash, template, inverse) {
            this.compiler.compileBlock(name, params, hash, template, inverse, this);
        }
        label(name) {
            this.labels.label(name, this.nextPos);
        }
        // helpers
        get labels() {
            return this.labelsStack.current;
        }
        startLabels() {
            this.labelsStack.push(new Labels());
        }
        stopLabels() {
            let label = this.labelsStack.pop();
            label.patch(this.encoder);
        }
        // components
        pushCurriedComponent() {
            this.push(74 /* PushCurriedComponent */);
        }
        pushDynamicComponentInstance() {
            this.push(73 /* PushDynamicComponentInstance */);
        }
        // dom
        openDynamicElement() {
            this.push(34 /* OpenDynamicElement */);
        }
        flushElement() {
            this.push(38 /* FlushElement */);
        }
        closeElement() {
            this.push(39 /* CloseElement */);
        }
        // lists
        putIterator() {
            this.push(66 /* PutIterator */);
        }
        enterList(start) {
            this.reserve(64 /* EnterList */);
            this.labels.target(this.pos, start);
        }
        exitList() {
            this.push(65 /* ExitList */);
        }
        iterate(breaks) {
            this.reserve(67 /* Iterate */);
            this.labels.target(this.pos, breaks);
        }
        // expressions
        setNamedVariables(state) {
            this.push(2 /* SetNamedVariables */, state);
        }
        setBlocks(state) {
            this.push(3 /* SetBlocks */, state);
        }
        setVariable(symbol) {
            this.push(4 /* SetVariable */, symbol);
        }
        setBlock(symbol) {
            this.push(5 /* SetBlock */, symbol);
        }
        getVariable(symbol) {
            this.push(6 /* GetVariable */, symbol);
        }
        getBlock(symbol) {
            this.push(8 /* GetBlock */, symbol);
        }
        hasBlock(symbol) {
            this.push(9 /* HasBlock */, symbol);
        }
        concat(size) {
            this.push(11 /* Concat */, size);
        }
        load(register) {
            this.push(18 /* Load */, register);
        }
        fetch(register) {
            this.push(19 /* Fetch */, register);
        }
        dup(register = Register$1.sp, offset = 0) {
            return this.push(16 /* Dup */, register, offset);
        }
        pop(count = 1) {
            return this.push(17 /* Pop */, count);
        }
        // vm
        returnTo(label) {
            this.reserveMachine(25 /* ReturnTo */);
            this.labels.target(this.pos, label);
        }
        primitiveReference() {
            this.push(14 /* PrimitiveReference */);
        }
        reifyU32() {
            this.push(15 /* ReifyU32 */);
        }
        enter(args) {
            this.push(61 /* Enter */, args);
        }
        exit() {
            this.push(62 /* Exit */);
        }
        return() {
            this.pushMachine(24 /* Return */);
        }
        jump(target) {
            this.reserveMachine(52 /* Jump */);
            this.labels.target(this.pos, target);
        }
        jumpIf(target) {
            this.reserve(53 /* JumpIf */);
            this.labels.target(this.pos, target);
        }
        jumpUnless(target) {
            this.reserve(54 /* JumpUnless */);
            this.labels.target(this.pos, target);
        }
        jumpEq(value, target) {
            this.reserveWithOperand(55 /* JumpEq */, value);
            this.labels.target(this.pos, target);
        }
        assertSame() {
            this.push(56 /* AssertSame */);
        }
        pushEmptyArgs() {
            this.push(77 /* PushEmptyArgs */);
        }
        switch(_opcode, callback) {
            // Setup the switch DSL
            let clauses = [];
            let count = 0;
            function when(match, callback) {
                clauses.push({ match, callback, label: `CLAUSE${count++}` });
            }
            // Call the callback
            callback(when);
            // Emit the opcodes for the switch
            this.enter(2);
            this.assertSame();
            this.reifyU32();
            this.startLabels();
            // First, emit the jump opcodes. We don't need a jump for the last
            // opcode, since it bleeds directly into its clause.
            clauses.slice(0, -1).forEach(clause => this.jumpEq(clause.match, clause.label));
            // Enumerate the clauses in reverse order. Earlier matches will
            // require fewer checks.
            for (let i = clauses.length - 1; i >= 0; i--) {
                let clause = clauses[i];
                this.label(clause.label);
                this.pop(2);
                clause.callback();
                // The first match is special: it is placed directly before the END
                // label, so no additional jump is needed at the end of it.
                if (i !== 0) {
                    this.jump('END');
                }
            }
            this.label('END');
            this.stopLabels();
            this.exit();
        }
        stdAppend(trusting) {
            this.switch(this.contentType(), when => {
                when(1 /* String */, () => {
                    if (trusting) {
                        this.assertSame();
                        this.appendHTML();
                    } else {
                        this.appendText();
                    }
                });
                when(0 /* Component */, () => {
                    this.pushCurriedComponent();
                    this.pushDynamicComponentInstance();
                    this.invokeBareComponent();
                });
                when(3 /* SafeString */, () => {
                    this.assertSame();
                    this.appendSafeHTML();
                });
                when(4 /* Fragment */, () => {
                    this.assertSame();
                    this.appendDocumentFragment();
                });
                when(5 /* Node */, () => {
                    this.assertSame();
                    this.appendNode();
                });
            });
        }
        populateLayout(state) {
            this.push(89 /* PopulateLayout */, state);
        }
        invokeBareComponent() {
            this.fetch(Register$1.s0);
            this.dup(Register$1.sp, 1);
            this.load(Register$1.s0);
            this.pushFrame();
            this.pushEmptyArgs();
            this.prepareArgs(Register$1.s0);
            this.invokePreparedComponent(false, false, true, () => {
                this.getComponentLayout(Register$1.s0);
                this.populateLayout(Register$1.s0);
            });
            this.load(Register$1.s0);
        }
        isComponent() {
            this.push(69 /* IsComponent */);
        }
        contentType() {
            this.push(70 /* ContentType */);
        }
        pushBlockScope() {
            this.push(47 /* PushBlockScope */);
        }
    }
    class OpcodeBuilder extends StdOpcodeBuilder {
        constructor(compiler, containingLayout) {
            super(compiler, containingLayout ? containingLayout.block.symbols.length : 0);
            this.containingLayout = containingLayout;
            this.component = new ComponentBuilder(this);
            this.expressionCompiler = expressionCompiler();
            this.isComponentAttrs = false;
            this.constants = compiler.constants;
            this.stdLib = compiler.stdLib;
        }
        /// MECHANICS
        get referrer() {
            return this.containingLayout && this.containingLayout.referrer;
        }
        setComponentAttrs(enabled) {
            this.isComponentAttrs = enabled;
        }
        expr(expression) {
            if (Array.isArray(expression)) {
                this.expressionCompiler.compile(expression, this);
            } else {
                this.pushPrimitiveReference(expression);
            }
        }
        ///
        // args
        pushArgs(names, flags) {
            let serialized = this.constants.stringArray(names);
            this.push(76 /* PushArgs */, serialized, flags);
        }
        pushYieldableBlock(block) {
            this.pushSymbolTable(block && block.symbolTable);
            this.pushBlockScope();
            this.pushBlock(block);
        }
        curryComponent(definition,
        /* TODO: attrs: Option<RawInlineBlock>, */params, hash, synthetic) {
            let referrer = this.containingLayout.referrer;
            this.pushFrame();
            this.compileArgs(params, hash, null, synthetic);
            this.push(80 /* CaptureArgs */);
            this.expr(definition);
            this.push(71 /* CurryComponent */, this.constants.serializable(referrer));
            this.popFrame();
            this.fetch(Register$1.v0);
        }
        pushSymbolTable(table) {
            if (table) {
                let constant = this.constants.serializable(table);
                this.push(48 /* PushSymbolTable */, constant);
            } else {
                this.primitive(null);
            }
        }
        invokeComponent(capabilities, attrs, params, hash, synthetic, block, inverse = null, layout) {
            this.fetch(Register$1.s0);
            this.dup(Register$1.sp, 1);
            this.load(Register$1.s0);
            this.pushFrame();
            let bindableBlocks = !!(block || inverse || attrs);
            let bindableAtNames = capabilities === true || capabilities.prepareArgs || !!(hash && hash[0].length !== 0);
            let blocks = { main: block, else: inverse, attrs };
            this.compileArgs(params, hash, blocks, synthetic);
            this.prepareArgs(Register$1.s0);
            this.invokePreparedComponent(block !== null, bindableBlocks, bindableAtNames, () => {
                if (layout) {
                    this.pushSymbolTable(layout.symbolTable);
                    this.pushLayout(layout);
                    this.resolveLayout();
                } else {
                    this.getComponentLayout(Register$1.s0);
                }
                this.populateLayout(Register$1.s0);
            });
            this.load(Register$1.s0);
        }
        invokeStaticComponent(capabilities, layout, attrs, params, hash, synthetic, block, inverse = null) {
            let symbolTable = layout.symbolTable;

            let bailOut = symbolTable.hasEval || capabilities.prepareArgs;
            if (bailOut) {
                this.invokeComponent(capabilities, attrs, params, hash, synthetic, block, inverse, layout);
                return;
            }
            this.fetch(Register$1.s0);
            this.dup(Register$1.sp, 1);
            this.load(Register$1.s0);
            let symbols = symbolTable.symbols;

            if (capabilities.createArgs) {
                this.pushFrame();
                this.compileArgs(null, hash, null, synthetic);
            }
            this.beginComponentTransaction();
            if (capabilities.dynamicScope) {
                this.pushDynamicScope();
            }
            if (capabilities.createInstance) {
                this.createComponent(Register$1.s0, block !== null);
            }
            if (capabilities.createArgs) {
                this.popFrame();
            }
            this.pushFrame();
            this.registerComponentDestructor(Register$1.s0);
            let bindings = [];
            this.getComponentSelf(Register$1.s0);
            bindings.push({ symbol: 0, isBlock: false });
            for (let i = 0; i < symbols.length; i++) {
                let symbol = symbols[i];
                switch (symbol.charAt(0)) {
                    case '&':
                        let callerBlock = null;
                        if (symbol === '&default') {
                            callerBlock = block;
                        } else if (symbol === '&inverse') {
                            callerBlock = inverse;
                        } else if (symbol === ATTRS_BLOCK) {
                            callerBlock = attrs;
                        } else {
                            throw unreachable$2();
                        }
                        if (callerBlock) {
                            this.pushYieldableBlock(callerBlock);
                            bindings.push({ symbol: i + 1, isBlock: true });
                        } else {
                            this.pushYieldableBlock(null);
                            bindings.push({ symbol: i + 1, isBlock: true });
                        }
                        break;
                    case '@':
                        if (!hash) {
                            break;
                        }
                        let keys = hash[0],
                            values = hash[1];

                        let lookupName = symbol;
                        if (synthetic) {
                            lookupName = symbol.slice(1);
                        }
                        let index = keys.indexOf(lookupName);
                        if (index !== -1) {
                            this.expr(values[index]);
                            bindings.push({ symbol: i + 1, isBlock: false });
                        }
                        break;
                }
            }
            this.pushRootScope(symbols.length + 1, !!(block || inverse || attrs));
            for (let i = bindings.length - 1; i >= 0; i--) {
                var _bindings$i = bindings[i];
                let symbol = _bindings$i.symbol,
                    isBlock = _bindings$i.isBlock;

                if (isBlock) {
                    this.setBlock(symbol);
                } else {
                    this.setVariable(symbol);
                }
            }
            this.invokeStatic(layout);
            if (capabilities.createInstance) {
                this.didRenderLayout(Register$1.s0);
            }
            this.popFrame();
            this.popScope();
            if (capabilities.dynamicScope) {
                this.popDynamicScope();
            }
            this.commitComponentTransaction();
            this.load(Register$1.s0);
        }
        dynamicComponent(definition,
        /* TODO: attrs: Option<RawInlineBlock>, */params, hash, synthetic, block, inverse = null) {
            this.replayable({
                args: () => {
                    this.expr(definition);
                    this.dup();
                    return 2;
                },
                body: () => {
                    this.jumpUnless('ELSE');
                    this.resolveDynamicComponent(this.containingLayout.referrer);
                    this.pushDynamicComponentInstance();
                    this.invokeComponent(true, null, params, hash, synthetic, block, inverse);
                    this.label('ELSE');
                }
            });
        }
        yield(to, params) {
            this.compileArgs(params, null, null, false);
            this.getBlock(to);
            this.resolveBlock();
            this.invokeYield();
            this.popScope();
            this.popFrame();
        }
        guardedAppend(expression, trusting) {
            this.pushFrame();
            this.expr(expression);
            this.pushMachine(50 /* InvokeStatic */, this.stdLib.getAppend(trusting));
            this.popFrame();
        }
        invokeStaticBlock(block, callerCount = 0) {
            let parameters = block.symbolTable.parameters;

            let calleeCount = parameters.length;
            let count = Math.min(callerCount, calleeCount);
            this.pushFrame();
            if (count) {
                this.pushChildScope();
                for (let i = 0; i < count; i++) {
                    this.dup(Register$1.fp, callerCount - i);
                    this.setVariable(parameters[i]);
                }
            }
            this.pushBlock(block);
            this.resolveBlock();
            this.invokeVirtual();
            if (count) {
                this.popScope();
            }
            this.popFrame();
        }
        /// CONVENIENCE
        // internal helpers
        string(_string) {
            return this.constants.string(_string);
        }
        names(_names) {
            let names = [];
            for (let i = 0; i < _names.length; i++) {
                let n = _names[i];
                names[i] = this.constants.string(n);
            }
            return this.constants.array(names);
        }
        symbols(symbols) {
            return this.constants.array(symbols);
        }
        // vm
        primitive(_primitive) {
            let type = 0 /* NUMBER */;
            let primitive;
            switch (typeof _primitive) {
                case 'number':
                    if (_primitive % 1 === 0) {
                        if (_primitive > -1) {
                            primitive = _primitive;
                        } else {
                            primitive = this.constants.number(_primitive);
                            type = 4 /* NEGATIVE */;
                        }
                    } else {
                        primitive = this.constants.number(_primitive);
                        type = 1 /* FLOAT */;
                    }
                    break;
                case 'string':
                    primitive = this.string(_primitive);
                    type = 2 /* STRING */;
                    break;
                case 'boolean':
                    primitive = _primitive | 0;
                    type = 3 /* BOOLEAN_OR_VOID */;
                    break;
                case 'object':
                    // assume null
                    primitive = 2;
                    type = 3 /* BOOLEAN_OR_VOID */;
                    break;
                case 'undefined':
                    primitive = 3;
                    type = 3 /* BOOLEAN_OR_VOID */;
                    break;
                default:
                    throw new Error('Invalid primitive passed to pushPrimitive');
            }
            let immediate = this.sizeImmediate(primitive << 3 | type, primitive);
            this.push(13 /* Primitive */, immediate);
        }
        sizeImmediate(shifted, primitive) {
            if (shifted >= 65535 /* MAX_SIZE */ || shifted < 0) {
                return this.constants.number(primitive) << 3 | 5 /* BIG_NUM */;
            }
            return shifted;
        }
        pushPrimitiveReference(primitive) {
            this.primitive(primitive);
            this.primitiveReference();
        }
        // components
        pushComponentDefinition(handle) {
            this.push(72 /* PushComponentDefinition */, this.constants.handle(handle));
        }
        resolveDynamicComponent(referrer) {
            this.push(75 /* ResolveDynamicComponent */, this.constants.serializable(referrer));
        }
        staticComponentHelper(tag, hash, template) {
            var _compiler$resolveLayo = this.compiler.resolveLayoutForTag(tag, this.referrer);

            let handle = _compiler$resolveLayo.handle,
                capabilities = _compiler$resolveLayo.capabilities,
                compilable = _compiler$resolveLayo.compilable;

            if (handle !== null && capabilities !== null) {
                if (compilable) {
                    if (hash) {
                        for (let i = 0; i < hash.length; i = i + 2) {
                            hash[i][0] = `@${hash[i][0]}`;
                        }
                    }
                    this.pushComponentDefinition(handle);
                    this.invokeStaticComponent(capabilities, compilable, null, null, hash, false, template && template);
                    return true;
                }
            }
            return false;
        }
        // partial
        invokePartial(referrer, symbols, evalInfo) {
            let _meta = this.constants.serializable(referrer);
            let _symbols = this.constants.stringArray(symbols);
            let _evalInfo = this.constants.array(evalInfo);
            this.push(95 /* InvokePartial */, _meta, _symbols, _evalInfo);
        }
        resolveMaybeLocal(name) {
            this.push(96 /* ResolveMaybeLocal */, this.string(name));
        }
        // debugger
        debugger(symbols, evalInfo) {
            this.push(97 /* Debugger */, this.constants.stringArray(symbols), this.constants.array(evalInfo));
        }
        // dom
        text(text) {
            this.push(26 /* Text */, this.constants.string(text));
        }
        openPrimitiveElement(tag) {
            this.push(33 /* OpenElement */, this.constants.string(tag));
        }
        modifier(locator, params, hash) {
            this.pushFrame();
            this.compileArgs(params, hash, null, true);
            this.push(40 /* Modifier */, this.constants.handle(locator));
            this.popFrame();
        }
        comment(_comment) {
            let comment = this.constants.string(_comment);
            this.push(27 /* Comment */, comment);
        }
        dynamicAttr(_name, _namespace, trusting) {
            let name = this.constants.string(_name);
            let namespace = _namespace ? this.constants.string(_namespace) : 0;
            if (this.isComponentAttrs) {
                this.push(37 /* ComponentAttr */, name, trusting === true ? 1 : 0, namespace);
            } else {
                this.push(36 /* DynamicAttr */, name, trusting === true ? 1 : 0, namespace);
            }
        }
        staticAttr(_name, _namespace, _value) {
            let name = this.constants.string(_name);
            let namespace = _namespace ? this.constants.string(_namespace) : 0;
            if (this.isComponentAttrs) {
                this.pushPrimitiveReference(_value);
                this.push(37 /* ComponentAttr */, name, 1, namespace);
            } else {
                let value = this.constants.string(_value);
                this.push(35 /* StaticAttr */, name, value, namespace);
            }
        }
        // expressions
        hasBlockParams(to) {
            this.getBlock(to);
            this.resolveBlock();
            this.push(10 /* HasBlockParams */);
        }
        getProperty(key) {
            this.push(7 /* GetProperty */, this.string(key));
        }
        helper(helper, params, hash) {
            this.pushFrame();
            this.compileArgs(params, hash, null, true);
            this.push(1 /* Helper */, this.constants.handle(helper));
            this.popFrame();
            this.fetch(Register$1.v0);
        }
        bindDynamicScope(_names) {
            this.push(43 /* BindDynamicScope */, this.names(_names));
        }
        // convenience methods
        /**
         * A convenience for pushing some arguments on the stack and
         * running some code if the code needs to be re-executed during
         * updating execution if some of the arguments have changed.
         *
         * # Initial Execution
         *
         * The `args` function should push zero or more arguments onto
         * the stack and return the number of arguments pushed.
         *
         * The `body` function provides the instructions to execute both
         * during initial execution and during updating execution.
         *
         * Internally, this function starts by pushing a new frame, so
         * that the body can return and sets the return point ($ra) to
         * the ENDINITIAL label.
         *
         * It then executes the `args` function, which adds instructions
         * responsible for pushing the arguments for the block to the
         * stack. These arguments will be restored to the stack before
         * updating execution.
         *
         * Next, it adds the Enter opcode, which marks the current position
         * in the DOM, and remembers the current $pc (the next instruction)
         * as the first instruction to execute during updating execution.
         *
         * Next, it runs `body`, which adds the opcodes that should
         * execute both during initial execution and during updating execution.
         * If the `body` wishes to finish early, it should Jump to the
         * `FINALLY` label.
         *
         * Next, it adds the FINALLY label, followed by:
         *
         * - the Exit opcode, which finalizes the marked DOM started by the
         *   Enter opcode.
         * - the Return opcode, which returns to the current return point
         *   ($ra).
         *
         * Finally, it adds the ENDINITIAL label followed by the PopFrame
         * instruction, which restores $fp, $sp and $ra.
         *
         * # Updating Execution
         *
         * Updating execution for this `replayable` occurs if the `body` added an
         * assertion, via one of the `JumpIf`, `JumpUnless` or `AssertSame` opcodes.
         *
         * If, during updating executon, the assertion fails, the initial VM is
         * restored, and the stored arguments are pushed onto the stack. The DOM
         * between the starting and ending markers is cleared, and the VM's cursor
         * is set to the area just cleared.
         *
         * The return point ($ra) is set to -1, the exit instruction.
         *
         * Finally, the $pc is set to to the instruction saved off by the
         * Enter opcode during initial execution, and execution proceeds as
         * usual.
         *
         * The only difference is that when a `Return` instruction is
         * encountered, the program jumps to -1 rather than the END label,
         * and the PopFrame opcode is not needed.
         */
        replayable({ args, body }) {
            // Start a new label frame, to give END and RETURN
            // a unique meaning.
            this.startLabels();
            this.pushFrame();
            // If the body invokes a block, its return will return to
            // END. Otherwise, the return in RETURN will return to END.
            this.returnTo('ENDINITIAL');
            // Push the arguments onto the stack. The args() function
            // tells us how many stack elements to retain for re-execution
            // when updating.
            let count = args();
            // Start a new updating closure, remembering `count` elements
            // from the stack. Everything after this point, and before END,
            // will execute both initially and to update the block.
            //
            // The enter and exit opcodes also track the area of the DOM
            // associated with this block. If an assertion inside the block
            // fails (for example, the test value changes from true to false
            // in an #if), the DOM is cleared and the program is re-executed,
            // restoring `count` elements to the stack and executing the
            // instructions between the enter and exit.
            this.enter(count);
            // Evaluate the body of the block. The body of the block may
            // return, which will jump execution to END during initial
            // execution, and exit the updating routine.
            body();
            // All execution paths in the body should run the FINALLY once
            // they are done. It is executed both during initial execution
            // and during updating execution.
            this.label('FINALLY');
            // Finalize the DOM.
            this.exit();
            // In initial execution, this is a noop: it returns to the
            // immediately following opcode. In updating execution, this
            // exits the updating routine.
            this.return();
            // Cleanup code for the block. Runs on initial execution
            // but not on updating.
            this.label('ENDINITIAL');
            this.popFrame();
            this.stopLabels();
        }
        /**
         * A specialized version of the `replayable` convenience that allows the
         * caller to provide different code based upon whether the item at
         * the top of the stack is true or false.
         *
         * As in `replayable`, the `ifTrue` and `ifFalse` code can invoke `return`.
         *
         * During the initial execution, a `return` will continue execution
         * in the cleanup code, which finalizes the current DOM block and pops
         * the current frame.
         *
         * During the updating execution, a `return` will exit the updating
         * routine, as it can reuse the DOM block and is always only a single
         * frame deep.
         */
        replayableIf({ args, ifTrue, ifFalse }) {
            this.replayable({
                args,
                body: () => {
                    // If the conditional is false, jump to the ELSE label.
                    this.jumpUnless('ELSE');
                    // Otherwise, execute the code associated with the true branch.
                    ifTrue();
                    // We're done, so return. In the initial execution, this runs
                    // the cleanup code. In the updating VM, it exits the updating
                    // routine.
                    this.jump('FINALLY');
                    this.label('ELSE');
                    // If the conditional is false, and code associatied ith the
                    // false branch was provided, execute it. If there was no code
                    // associated with the false branch, jumping to the else statement
                    // has no other behavior.
                    if (ifFalse) {
                        ifFalse();
                    }
                }
            });
        }
        inlineBlock(block) {
            return new CompilableBlock(this.compiler, {
                block,
                containingLayout: this.containingLayout
            });
        }
        evalSymbols() {
            let block = this.containingLayout.block;

            return block.hasEval ? block.symbols : null;
        }
        compileParams(params) {
            if (!params) return 0;
            for (let i = 0; i < params.length; i++) {
                this.expr(params[i]);
            }
            return params.length;
        }
        compileArgs(params, hash, blocks, synthetic) {
            if (blocks) {
                this.pushYieldableBlock(blocks.main);
                this.pushYieldableBlock(blocks.else);
                this.pushYieldableBlock(blocks.attrs);
            }
            let count = this.compileParams(params);
            let flags = count << 4;
            if (synthetic) flags |= 0b1000;
            if (blocks) {
                flags |= 0b111;
            }
            let names = EMPTY_ARRAY$2;
            if (hash) {
                names = hash[0];
                let val = hash[1];
                for (let i = 0; i < val.length; i++) {
                    this.expr(val[i]);
                }
            }
            this.pushArgs(names, flags);
        }
        template(block) {
            if (!block) return null;
            return this.inlineBlock(block);
        }
    }
    class LazyOpcodeBuilder extends OpcodeBuilder {
        pushBlock(block) {
            if (block) {
                this.pushOther(block);
            } else {
                this.primitive(null);
            }
        }
        resolveBlock() {
            this.push(46 /* CompileBlock */);
        }
        pushLayout(layout) {
            if (layout) {
                this.pushOther(layout);
            } else {
                this.primitive(null);
            }
        }
        resolveLayout() {
            this.push(46 /* CompileBlock */);
        }
        invokeStatic(compilable) {
            this.pushOther(compilable);
            this.push(46 /* CompileBlock */);
            this.pushMachine(49 /* InvokeVirtual */);
        }
        pushOther(value) {
            this.push(12 /* Constant */, this.other(value));
        }
        other(value) {
            return this.constants.other(value);
        }
    }

    const UNRESOLVED = {};
    const WELL_KNOWN_EMPTY_ARRAY_POSITION = 0;
    const WELL_KNOW_EMPTY_ARRAY = Object.freeze([]);
    class WriteOnlyConstants {
        constructor() {
            // `0` means NULL
            this.strings = [];
            this.arrays = [WELL_KNOW_EMPTY_ARRAY];
            this.tables = [];
            this.handles = [];
            this.resolved = [];
            this.numbers = [];
        }
        string(value) {
            let index = this.strings.indexOf(value);
            if (index > -1) {
                return index;
            }
            return this.strings.push(value) - 1;
        }
        stringArray(strings) {
            let _strings = new Array(strings.length);
            for (let i = 0; i < strings.length; i++) {
                _strings[i] = this.string(strings[i]);
            }
            return this.array(_strings);
        }
        array(values) {
            if (values.length === 0) {
                return WELL_KNOWN_EMPTY_ARRAY_POSITION;
            }
            let index = this.arrays.indexOf(values);
            if (index > -1) {
                return index;
            }
            return this.arrays.push(values) - 1;
        }
        handle(handle) {
            let index = this.handles.indexOf(handle);
            if (index > -1) {
                return index;
            }
            this.resolved.push(UNRESOLVED);
            return this.handles.push(handle) - 1;
        }
        serializable(value) {
            let str = JSON.stringify(value);
            let index = this.strings.indexOf(str);
            if (index > -1) {
                return index;
            }
            return this.strings.push(str) - 1;
        }
        number(number) {
            let index = this.numbers.indexOf(number);
            if (index > -1) {
                return index;
            }
            return this.numbers.push(number) - 1;
        }
        toPool() {
            return {
                strings: this.strings,
                arrays: this.arrays,
                handles: this.handles,
                numbers: this.numbers
            };
        }
    }
    class Constants extends WriteOnlyConstants {
        constructor(resolver, pool) {
            super();
            this.resolver = resolver;
            if (pool) {
                this.strings = pool.strings;
                this.arrays = pool.arrays;
                this.handles = pool.handles;
                this.resolved = this.handles.map(() => UNRESOLVED);
                this.numbers = pool.numbers;
            }
        }
        getNumber(value) {
            return this.numbers[value];
        }
        getString(value) {
            return this.strings[value];
        }
        getStringArray(value) {
            let names = this.getArray(value);
            let _names = new Array(names.length);
            for (let i = 0; i < names.length; i++) {
                let n = names[i];
                _names[i] = this.getString(n);
            }
            return _names;
        }
        getArray(value) {
            return this.arrays[value];
        }
        resolveHandle(index) {
            let resolved = this.resolved[index];
            if (resolved === UNRESOLVED) {
                let handle = this.handles[index];
                resolved = this.resolved[index] = this.resolver.resolve(handle);
            }
            return resolved;
        }
        getSerializable(s) {
            return JSON.parse(this.strings[s]);
        }
    }
    class LazyConstants extends Constants {
        constructor() {
            super(...arguments);
            this.others = [];
            this.serializables = [];
        }
        serializable(value) {
            let index = this.serializables.indexOf(value);
            if (index > -1) {
                return index;
            }
            return this.serializables.push(value) - 1;
        }
        getSerializable(s) {
            return this.serializables[s];
        }
        getOther(value) {
            return this.others[value - 1];
        }
        other(other) {
            return this.others.push(other);
        }
    }

    class Opcode {
        constructor(heap) {
            this.heap = heap;
            this.offset = 0;
        }
        get size() {
            let rawType = this.heap.getbyaddr(this.offset);
            return ((rawType & 768 /* OPERAND_LEN_MASK */) >> 8 /* ARG_SHIFT */) + 1;
        }
        get isMachine() {
            let rawType = this.heap.getbyaddr(this.offset);
            return rawType & 1024 /* MACHINE_MASK */;
        }
        get type() {
            return this.heap.getbyaddr(this.offset) & 255 /* TYPE_MASK */;
        }
        get op1() {
            return this.heap.getbyaddr(this.offset + 1);
        }
        get op2() {
            return this.heap.getbyaddr(this.offset + 2);
        }
        get op3() {
            return this.heap.getbyaddr(this.offset + 3);
        }
    }

    function encodeTableInfo(size, scopeSize, state) {
        return size | scopeSize << 16 | state << 30;
    }
    function changeState(info, newState) {
        return info | newState << 30;
    }
    const PAGE_SIZE = 0x100000;
    /**
     * The Heap is responsible for dynamically allocating
     * memory in which we read/write the VM's instructions
     * from/to. When we malloc we pass out a VMHandle, which
     * is used as an indirect way of accessing the memory during
     * execution of the VM. Internally we track the different
     * regions of the memory in an int array known as the table.
     *
     * The table 32-bit aligned and has the following layout:
     *
     * | ... | hp (u32) |       info (u32)          |
     * | ... |  Handle  | Size | Scope Size | State |
     * | ... | 32-bits  | 16b  |    14b     |  2b   |
     *
     * With this information we effectively have the ability to
     * control when we want to free memory. That being said you
     * can not free during execution as raw address are only
     * valid during the execution. This means you cannot close
     * over them as you will have a bad memory access exception.
     */
    class Heap {
        constructor(serializedHeap) {
            this.placeholders = [];
            this.offset = 0;
            this.handle = 0;
            this.capacity = PAGE_SIZE;
            if (serializedHeap) {
                let buffer = serializedHeap.buffer,
                    table = serializedHeap.table,
                    handle = serializedHeap.handle;

                this.heap = new Uint16Array(buffer);
                this.table = table;
                this.offset = this.heap.length;
                this.handle = handle;
                this.capacity = 0;
            } else {
                this.heap = new Uint16Array(PAGE_SIZE);
                this.table = [];
            }
        }
        push(item) {
            this.sizeCheck();
            this.heap[this.offset++] = item;
        }
        sizeCheck() {
            if (this.capacity === 0) {
                let heap = slice(this.heap, 0, this.offset);
                this.heap = new Uint16Array(heap.length + PAGE_SIZE);
                this.heap.set(heap, 0);
                this.capacity = PAGE_SIZE;
            }
            this.capacity--;
        }
        getbyaddr(address) {
            return this.heap[address];
        }
        setbyaddr(address, value) {
            this.heap[address] = value;
        }
        malloc() {
            this.table.push(this.offset, 0);
            let handle = this.handle;
            this.handle += 2 /* ENTRY_SIZE */;
            return handle;
        }
        finishMalloc(handle, scopeSize) {
            let start = this.table[handle];
            let finish = this.offset;
            let instructionSize = finish - start;
            let info = encodeTableInfo(instructionSize, scopeSize, 0 /* Allocated */);
            this.table[handle + 1 /* INFO_OFFSET */] = info;
        }
        size() {
            return this.offset;
        }
        // It is illegal to close over this address, as compaction
        // may move it. However, it is legal to use this address
        // multiple times between compactions.
        getaddr(handle) {
            return this.table[handle];
        }
        gethandle(address) {
            this.table.push(address, encodeTableInfo(0, 0, 3 /* Pointer */));
            let handle = this.handle;
            this.handle += 2 /* ENTRY_SIZE */;
            return handle;
        }
        sizeof(handle) {
            return -1;
        }
        scopesizeof(handle) {
            let info = this.table[handle + 1 /* INFO_OFFSET */];
            return (info & 1073676288 /* SCOPE_MASK */) >> 16;
        }
        free(handle) {
            let info = this.table[handle + 1 /* INFO_OFFSET */];
            this.table[handle + 1 /* INFO_OFFSET */] = changeState(info, 1 /* Freed */);
        }
        /**
         * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift
         * reachable memory to the bottom of the heap and freeable
         * memory to the top of the heap. When we have shifted all
         * the reachable memory to the top of the heap, we move the
         * offset to the next free position.
         */
        compact() {
            let compactedSize = 0;
            let table = this.table,
                length = this.table.length,
                heap = this.heap;

            for (let i = 0; i < length; i += 2 /* ENTRY_SIZE */) {
                let offset = table[i];
                let info = table[i + 1 /* INFO_OFFSET */];
                let size = info & 65535 /* SIZE_MASK */;
                let state = info & 3221225472 /* STATE_MASK */ >> 30;
                if (state === 2 /* Purged */) {
                        continue;
                    } else if (state === 1 /* Freed */) {
                        // transition to "already freed" aka "purged"
                        // a good improvement would be to reuse
                        // these slots
                        table[i + 1 /* INFO_OFFSET */] = changeState(info, 2 /* Purged */);
                        compactedSize += size;
                    } else if (state === 0 /* Allocated */) {
                        for (let j = offset; j <= i + size; j++) {
                            heap[j - compactedSize] = heap[j];
                        }
                        table[i] = offset - compactedSize;
                    } else if (state === 3 /* Pointer */) {
                        table[i] = offset - compactedSize;
                    }
            }
            this.offset = this.offset - compactedSize;
        }
        pushPlaceholder(valueFunc) {
            this.sizeCheck();
            let address = this.offset++;
            this.heap[address] = 65535 /* MAX_SIZE */;
            this.placeholders.push([address, valueFunc]);
        }
        patchPlaceholders() {
            let placeholders = this.placeholders;

            for (let i = 0; i < placeholders.length; i++) {
                var _placeholders$i = placeholders[i];
                let address = _placeholders$i[0],
                    getValue = _placeholders$i[1];

                this.setbyaddr(address, getValue());
            }
        }
        capture(offset = this.offset) {
            this.patchPlaceholders();
            // Only called in eager mode
            let buffer = slice(this.heap, 0, offset).buffer;
            return {
                handle: this.handle,
                table: this.table,
                buffer: buffer
            };
        }
    }
    class WriteOnlyProgram {
        constructor(constants = new WriteOnlyConstants(), heap = new Heap()) {
            this.constants = constants;
            this.heap = heap;
            this._opcode = new Opcode(this.heap);
        }
        opcode(offset) {
            this._opcode.offset = offset;
            return this._opcode;
        }
    }
    class Program extends WriteOnlyProgram {}
    function slice(arr, start, end) {
        if (arr.slice !== undefined) {
            return arr.slice(start, end);
        }
        let ret = new Uint16Array(end);
        for (; start < end; start++) {
            ret[start] = arr[start];
        }
        return ret;
    }

    class LazyCompiler extends AbstractCompiler {
        // FIXME: turn to static method
        constructor(lookup, resolver, macros) {
            let constants = new LazyConstants(resolver);
            let program = new Program(constants);
            super(macros, program, lookup);
        }
        builderFor(containingLayout) {
            return new LazyOpcodeBuilder(this, containingLayout);
        }
    }

    let clientId = 0;
    function templateFactory({ id: templateId, meta, block }) {
        let parsedBlock;
        let id = templateId || `client-${clientId++}`;
        let create = (compiler, envMeta) => {
            let newMeta = envMeta ? assign$2({}, envMeta, meta) : meta;
            if (!parsedBlock) {
                parsedBlock = JSON.parse(block);
            }
            return new TemplateImpl(compiler, { id, block: parsedBlock, referrer: newMeta });
        };
        return { id, meta, create };
    }
    class TemplateImpl {
        constructor(compiler, parsedLayout) {
            this.compiler = compiler;
            this.parsedLayout = parsedLayout;
            this.layout = null;
            this.partial = null;
            this.wrappedLayout = null;
            let block = parsedLayout.block;

            this.symbols = block.symbols;
            this.hasEval = block.hasEval;
            this.referrer = parsedLayout.referrer;
            this.id = parsedLayout.id || `client-${clientId++}`;
        }
        asLayout() {
            if (this.layout) return this.layout;
            return this.layout = new CompilableProgram(this.compiler, Object.assign({}, this.parsedLayout, { asPartial: false }));
        }
        asPartial() {
            if (this.partial) return this.partial;
            return this.layout = new CompilableProgram(this.compiler, Object.assign({}, this.parsedLayout, { asPartial: true }));
        }
        asWrappedLayout() {
            if (this.wrappedLayout) return this.wrappedLayout;
            return this.wrappedLayout = new WrappedBuilder(this.compiler, Object.assign({}, this.parsedLayout, { asPartial: false }));
        }
    }

    /** @public */
    class RuntimeResolver {
        constructor(owner) {
            this.owner = owner;
            this.handleLookup = [];
            this.cache = {
                component: new TypedRegistry(),
                template: new TypedRegistry(),
                compiledTemplate: new TypedRegistry(),
                helper: new TypedRegistry(),
                manager: new TypedRegistry(),
                modifier: new TypedRegistry()
            };
        }
        lookup(type, name, referrer) {
            if (this.cache[type].hasName(name)) {
                return this.cache[type].getHandle(name);
            } else {
                return null;
            }
        }
        register(type, name, value) {
            let registry = this.cache[type];
            let handle = this.handleLookup.length;
            this.handleLookup.push(registry);
            this.cache[type].register(handle, name, value);
            return handle;
        }
        lookupModifier(name, meta) {
            let handle = this.lookup('modifier', name);
            if (handle === null) {
                throw new Error(`Modifier for ${name} not found.`);
            }
            return handle;
        }
        compileTemplate(name, layout) {
            if (!this.cache.compiledTemplate.hasName(name)) {
                let serializedTemplate = this.resolve(layout);
                let block = JSON.parse(serializedTemplate.block);
                let compilableTemplate = new CompilableProgram(this.compiler, {
                    block,
                    referrer: serializedTemplate.meta,
                    asPartial: false
                });
                let invocation = {
                    handle: compilableTemplate.compile(),
                    symbolTable: compilableTemplate.symbolTable
                };
                this.register('compiledTemplate', name, invocation);
                return invocation;
            }
            let handle = this.lookup('compiledTemplate', name);
            return this.resolve(handle);
        }
        registerHelper(name, helper) {
            let glimmerHelper = (_vm, args) => new HelperReference(helper, args);
            return this.register('helper', name, glimmerHelper);
        }
        registerInternalHelper(name, helper) {
            this.register('helper', name, helper);
        }
        registerComponent(name, resolvedSpecifier, Component$$1, template) {
            let templateEntry = this.registerTemplate(resolvedSpecifier, template);
            let manager = this.managerFor(templateEntry.meta.managerId);
            let definition = new ComponentDefinition(name, manager, Component$$1, templateEntry.handle);
            return this.register('component', name, definition);
        }
        lookupComponentHandle(name, referrer) {
            if (!this.cache.component.hasName(name)) {
                this.lookupComponentDefinition(name, referrer);
            }
            return this.lookup('component', name, referrer);
        }
        managerFor(managerId = 'main') {
            let manager;
            if (!this.cache.manager.hasName(managerId)) {
                let rootName = this.owner.rootName;

                manager = this.owner.lookup(`component-manager:/${rootName}/component-managers/${managerId}`);
                if (!manager) {
                    throw new Error(`No component manager found for ID ${managerId}.`);
                }
                this.register('manager', managerId, manager);
                return manager;
            } else {
                let handle = this.cache.manager.getHandle(managerId);
                return this.cache.manager.getByHandle(handle);
            }
        }
        registerTemplate(resolvedSpecifier, template) {
            return {
                name: resolvedSpecifier,
                handle: this.register('template', resolvedSpecifier, template),
                meta: template.meta
            };
        }
        lookupComponentDefinition(name, meta) {
            let handle;
            if (!this.cache.component.hasName(name)) {
                let specifier = expect$2(this.identifyComponent(name, meta), `Could not find the component '${name}'`);
                let template = this.owner.lookup('template', specifier);
                let componentSpecifier = this.owner.identify('component', specifier);
                let componentFactory = null;
                if (componentSpecifier !== undefined) {
                    componentFactory = this.owner.factoryFor(componentSpecifier);
                }
                handle = this.registerComponent(name, specifier, componentFactory, template);
            } else {
                handle = this.lookup('component', name, meta);
            }
            return this.resolve(handle);
        }
        lookupHelper(name, meta) {
            if (!this.cache.helper.hasName(name)) {
                let owner = this.owner;
                let relSpecifier = `helper:${name}`;
                let referrer = meta.specifier;
                let specifier = owner.identify(relSpecifier, referrer);
                if (specifier === undefined) {
                    return null;
                }
                let helper = this.owner.lookup(specifier, meta.specifier);
                return this.registerHelper(name, helper);
            }
            return this.lookup('helper', name, meta);
        }
        lookupPartial(name, meta) {
            throw new Error("Partials are not available in Glimmer applications.");
        }
        resolve(handle) {
            let registry = this.handleLookup[handle];
            return registry.getByHandle(handle);
        }
        identifyComponent(name, meta) {
            let owner = this.owner;
            let relSpecifier = `template:${name}`;
            let referrer = meta.specifier;
            let specifier = owner.identify(relSpecifier, referrer);
            if (specifier === undefined && owner.identify(`component:${name}`, referrer)) {
                throw new Error(`The component '${name}' is missing a template. All components must have a template. Make sure there is a template.hbs in the component directory.`);
            }
            return specifier;
        }
    }

    var mainTemplate = { "id": "j7SGa6Pm", "block": "{\"symbols\":[\"root\"],\"statements\":[[4,\"each\",[[22,[\"roots\"]]],[[\"key\"],[\"id\"]],{\"statements\":[[4,\"in-element\",[[21,1,[\"parent\"]]],[[\"guid\",\"nextSibling\"],[\"%cursor:0%\",[21,1,[\"nextSibling\"]]]],{\"statements\":[[1,[26,\"component\",[[21,1,[\"component\"]]],null],false]],\"parameters\":[]},null]],\"parameters\":[1]},null]],\"hasEval\":false}", "meta": { "specifier": "template:/-application/application/src/templates/main" } };

    /** @internal */
    function buildAction(vm, _args) {
        let componentRef = vm.getSelf();
        let args = _args.capture();
        let actionFunc = args.positional.at(0).value();
        if (typeof actionFunc !== 'function') {
            throwNoActionError(actionFunc, args.positional.at(0));
        }
        return new UpdatableReference(function action(...invokedArgs) {
            let curriedArgs = args.positional.value();
            // Consume the action function that was already captured above.
            curriedArgs.shift();
            curriedArgs.push(...invokedArgs);
            // Invoke the function with the component as the context, the curried
            // arguments passed to `{{action}}`, and the arguments the bound function
            // was invoked with.
            actionFunc.apply(componentRef && componentRef.value(), curriedArgs);
        });
    }
    function throwNoActionError(actionFunc, actionFuncReference) {
        let referenceInfo = debugInfoForReference(actionFuncReference);
        throw new Error(`You tried to create an action with the {{action}} helper, but the first argument ${referenceInfo}was ${typeof actionFunc} instead of a function.`);
    }
    /** @internal */
    function debugInfoForReference(reference) {
        let message = '';
        let parent;
        let property;
        if (reference === null || reference === undefined) {
            return message;
        }
        if ('parent' in reference && 'property' in reference) {
            parent = reference['parent'].value();
            property = reference['property'];
        } else if ('_parentValue' in reference && '_propertyKey' in reference) {
            parent = reference['_parentValue'];
            property = reference['_propertyKey'];
        }
        if (property !== undefined) {
            message += `('${property}' on ${debugName(parent)}) `;
        }
        return message;
    }
    function debugName(obj) {
        let objType = typeof obj;
        if (obj === null || obj === undefined) {
            return objType;
        } else if (objType === 'number' || objType === 'boolean') {
            return obj.toString();
        } else {
            if (obj['debugName']) {
                return obj['debugName'];
            }
            try {
                return JSON.stringify(obj);
            } catch (e) {}
            return obj.toString();
        }
    }

    /** @internal */
    function ifHelper(params) {
        return params[0] ? params[1] : params[2];
    }

    class CompileTimeLookup {
        constructor(resolver) {
            this.resolver = resolver;
        }
        getComponentDefinition(handle) {
            let spec = this.resolver.resolve(handle);
            debugAssert$2(!!spec, `Couldn't find a template for ${handle}`);
            return spec;
        }
        getCapabilities(handle) {
            let definition = this.getComponentDefinition(handle);
            let manager = definition.manager,
                state = definition.state;

            return manager.getCapabilities(state);
        }
        getLayout(handle) {
            let definition = this.getComponentDefinition(handle);
            let manager = definition.manager;

            let invocation = manager.getLayout(definition, this.resolver);
            return {
                compile() {
                    return invocation.handle;
                },
                symbolTable: invocation.symbolTable
            };
        }
        lookupHelper(name, referrer) {
            return this.resolver.lookupHelper(name, referrer);
        }
        lookupModifier(name, referrer) {
            return this.resolver.lookupModifier(name, referrer);
        }
        lookupComponentDefinition(name, referrer) {
            return this.resolver.lookupComponentHandle(name, referrer);
        }
        lookupPartial(name, referrer) {
            return this.resolver.lookupPartial(name, referrer);
        }
    }

    /**
     * The RuntimeCompilerLoader is used by Glimmer.js applications that perform the
     * final template compilation step client-side. It configures the compiler to
     * resolve templates, helpers and other objects from the runtime registry, and
     * enables just-in-time compilation of templates as they are encountered.
     *
     * @public
     */
    class RuntimeCompilerLoader {
        constructor(resolver) {
            this.resolver = resolver;
        }
        async getTemplateIterator(app, env, builder, dynamicScope, self) {
            let resolver = new RuntimeResolver(app);
            let lookup = new CompileTimeLookup(resolver);
            let macros = new Macros();
            let compiler = new LazyCompiler(lookup, resolver, macros);
            let program = compiler.program;
            resolver.compiler = compiler;
            resolver.registerTemplate('main', mainTemplate);
            resolver.registerInternalHelper('action', buildAction);
            resolver.registerHelper('if', ifHelper);
            let mainLayout = templateFactory(mainTemplate).create(compiler);
            return Promise.resolve(render$1(program, env, self, dynamicScope, builder, mainLayout.asLayout().compile()));
        }
    }

    /**
     * A {@link Builder} that creates DOM elements when templates render.
     *
     * Use a DOMBuilder for Glimmer.js applications that do not use server-side
     * rendering. If you are using server-side rendering, the
     * {@link RehydratingBuilder} can be used to rehydrate existing DOM instead of
     * replacing it.
     *
     * @public
     */
    class DOMBuilder {
        constructor({ element, nextSibling = null }) {
            this.cursor = { element, nextSibling };
        }
        getBuilder(env) {
            return clientBuilder$1(env, this.cursor);
        }
    }

    /**
     * Performs a synchronous initial render of templates.
     *
     * @remarks
     *
     * The SyncRenderer will render a template as fast as possible, continuing to
     * work until the template has been completely rendered.
     *
     * While this delivers the fastest absolute rendering performance, large
     * templates may cause the main thread to be consumed for long periods of time,
     * leading to user-noticeable performance degradation, or jank.
     *
     * See also: {@link AsyncRenderer}
     *
     * @public
     */
    class SyncRenderer {
        render(iterator) {
            // Iterate the template iterator, executing the compiled template program
            // until there are no more instructions left to execute.
            let result;
            do {
                result = iterator.next();
            } while (!result.done);
            this.result = result.value;
        }
        rerender() {
            if (!this.result) {
                throw new Error('Cannot re-render before initial render has completed');
            }
            this.result.rerender();
        }
    }

    // TODO - use symbol

    function isSpecifierStringAbsolute$1(specifier) {
        let split = specifier.split(':');
        let type = split[0];
        let path = split[1];
        return !!(type && path && path.indexOf('/') === 0 && path.split('/').length > 3);
    }
    function isSpecifierObjectAbsolute$1(specifier) {
        return specifier.rootName !== undefined && specifier.collection !== undefined && specifier.name !== undefined && specifier.type !== undefined;
    }
    function serializeSpecifier$1(specifier) {
        let type = specifier.type;
        let path = serializeSpecifierPath$1(specifier);
        if (path) {
            return type + ':' + path;
        } else {
            return type;
        }
    }
    function serializeSpecifierPath$1(specifier) {
        let path = [];
        if (specifier.rootName) {
            path.push(specifier.rootName);
        }
        if (specifier.collection) {
            path.push(specifier.collection);
        }
        if (specifier.namespace) {
            path.push(specifier.namespace);
        }
        if (specifier.name) {
            path.push(specifier.name);
        }
        if (path.length > 0) {
            let fullPath = path.join('/');
            if (isSpecifierObjectAbsolute$1(specifier)) {
                fullPath = '/' + fullPath;
            }
            return fullPath;
        }
    }
    function deserializeSpecifier$1(specifier) {
        let obj = {};
        if (specifier.indexOf(':') > -1) {
            let split = specifier.split(':');
            let type = split[0];
            let path = split[1];
            obj.type = type;
            let pathSegments;
            if (path.indexOf('/') === 0) {
                pathSegments = path.substr(1).split('/');
                if (path.substr(1).startsWith('@')) {
                    obj.rootName = pathSegments.shift() + '/' + pathSegments.shift();
                } else {
                    obj.rootName = pathSegments.shift();
                }
                obj.collection = pathSegments.shift();
            } else {
                pathSegments = path.split('/');
            }
            if (pathSegments.length > 0) {
                obj.name = pathSegments.pop();
                if (pathSegments.length > 0) {
                    obj.namespace = pathSegments.join('/');
                }
            }
        } else {
            obj.type = specifier;
        }
        return obj;
    }

    function assert(description, test) {
        if (!test) {
            throw new Error('Assertion Failed: ' + description);
        }
    }

    function detectLocalResolutionCollection(specifier) {
        let namespace = specifier.namespace,
            collection = specifier.collection;
        // Look for the local-most private collection contained in the namespace
        // (which will appear closest to the end of the string)

        let startPos = namespace.lastIndexOf('/-');
        if (startPos > -1) {
            startPos += 2;
            let endPos = namespace.indexOf('/', startPos);
            collection = namespace.slice(startPos, endPos > -1 ? endPos : undefined);
        }
        return collection;
    }

    class Resolver {
        constructor(config, registry) {
            this.config = config;
            this.registry = registry;
        }
        identify(specifier, referrer) {
            if (isSpecifierStringAbsolute$1(specifier)) {
                return specifier;
            }
            let s = deserializeSpecifier$1(specifier);
            let result;
            if (referrer) {
                let r = deserializeSpecifier$1(referrer);
                if (isSpecifierObjectAbsolute$1(r)) {
                    assert('Specifier must not include a rootName, collection, or namespace when combined with an absolute referrer', s.rootName === undefined && s.collection === undefined && s.namespace === undefined);
                    s.rootName = r.rootName;
                    s.collection = r.collection;
                    let definitiveCollection = this._definitiveCollection(s.type);
                    if (!s.name) {
                        /*
                         * For specifiers without a name use the referrer's name and
                         * do not fallback to any other resolution rules.
                         */
                        s.namespace = r.namespace;
                        s.name = r.name;
                        return this._serializeAndVerify(s);
                    }
                    s.namespace = r.namespace ? r.namespace + '/' + r.name : r.name;
                    if (detectLocalResolutionCollection(s) === definitiveCollection) {
                        /*
                         * For specifiers with a name, try local resolution. Based on
                         * the referrer.
                         */
                        if (result = this._serializeAndVerify(s)) {
                            return result;
                        }
                    }
                    // Look for a private collection in the referrer's namespace
                    if (definitiveCollection) {
                        s.namespace += '/-' + definitiveCollection;
                        if (result = this._serializeAndVerify(s)) {
                            return result;
                        }
                    }
                    // Because local and private resolution has failed, clear all but `name` and `type`
                    // to proceed with top-level resolution
                    s.rootName = s.collection = s.namespace = undefined;
                } else {
                    assert('Referrer must either be "absolute" or include a `type` to determine the associated type', r.type);
                    // Look in the definitive collection for the associated type
                    s.collection = this._definitiveCollection(r.type);
                    if (!s.namespace) {
                        s.namespace = r.rootName;
                    }
                    assert(`'${r.type}' does not have a definitive collection`, s.collection);
                }
            }
            // If the collection is unspecified, use the definitive collection for the `type`
            if (!s.collection) {
                s.collection = this._definitiveCollection(s.type);
                assert(`'${s.type}' does not have a definitive collection`, s.collection);
            }
            if (!s.rootName) {
                // If the root name is unspecified, try the app's `rootName` first
                s.rootName = this.config.app.rootName || 'app';
                if (result = this._serializeAndVerify(s)) {
                    return result;
                }
                // Then look for an addon with a matching `rootName`
                if (s.namespace) {
                    s.rootName = s.namespace;
                    s.namespace = undefined;
                } else {
                    s.rootName = s.name;
                    s.name = 'main';
                }
            }
            if (result = this._serializeAndVerify(s)) {
                return result;
            }
        }
        retrieve(specifier) {
            return this.registry.get(specifier);
        }
        resolve(specifier, referrer) {
            let id = this.identify(specifier, referrer);
            if (id) {
                return this.retrieve(id);
            }
        }
        _definitiveCollection(type) {
            let typeDef = this.config.types[type];
            assert(`'${type}' is not a recognized type`, typeDef);
            return typeDef.definitiveCollection;
        }
        _serializeAndVerify(specifier) {
            let serialized = serializeSpecifier$1(specifier);
            if (this.registry.has(serialized)) {
                return serialized;
            }
        }
    }

    class BasicRegistry {
        constructor(entries = {}) {
            this._entries = entries;
        }
        has(specifier) {
            return specifier in this._entries;
        }
        get(specifier) {
            return this._entries[specifier];
        }
    }

    var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    class AriaDropdownMenu extends Component {
        constructor() {
            super(...arguments);
            this.expanded = 'false';
        }
        click(ev) {
            ev.preventDefault();
            if (this.expanded === 'false') {
                this.expanded = 'true';
            } else {
                this.expanded = 'false';
            }
        }
        keyDown(ev) {
            if (ev.keyCode === 13) {
                if (this.expanded === 'false') {
                    this.expanded = 'true';
                    setTimeout(function () {
                        ev.target.nextElementSibling.querySelector('*[role="menuitem"]').focus();
                    }, 100);
                } else {
                    this.expanded = 'false';
                }
            } else if (ev.keyCode === 27) {
                if (ev.target.getAttribute('aria-haspopup') !== 'true') {
                    ev.target.parentElement.parentElement.previousElementSibling.focus();
                }
                this.expanded = 'false';
            } else if (ev.keyCode === 39) {
                let nextElement = ev.target.parentElement.nextElementSibling;
                while (nextElement && (nextElement.getAttribute('role') === 'separator' || nextElement.querySelector('*[role="menuitem"]').getAttribute('aria-disabled') === 'true')) {
                    nextElement = nextElement.nextElementSibling;
                }
                if (nextElement) {
                    nextElement.querySelector('*[role="menuitem"]').focus();
                }
            } else if (ev.keyCode === 37) {
                let previousElement = ev.target.parentElement.previousElementSibling;
                while (previousElement && (previousElement.getAttribute('role') === 'separator' || previousElement.querySelector('*[role="menuitem"]').getAttribute('aria-disabled') === 'true')) {
                    previousElement = previousElement.previousElementSibling;
                }
                if (previousElement) {
                    previousElement.querySelector('*[role="menuitem"]').focus();
                }
            }
        }
        mouseOver() {
            this.expanded = 'true';
        }
        mouseOut() {
            this.expanded = 'false';
        }
    }
    __decorate([tracked], AriaDropdownMenu.prototype, "expanded", void 0);

    var __ui_components_AriaDropdownMenu_template__ = { "id": "jlrELQXU", "block": "{\"symbols\":[\"@title\",\"&default\"],\"statements\":[[6,\"li\"],[10,\"role\",\"presentation\"],[10,\"class\",\"dropdown\"],[11,\"onmouseover\",[26,\"action\",[[22,[\"mouseOver\"]]],null],null],[11,\"onmouseout\",[26,\"action\",[[22,[\"mouseOut\"]]],null],null],[8],[0,\"\\n  \"],[6,\"a\"],[10,\"role\",\"menuitem\"],[10,\"aria-haspopup\",\"true\"],[10,\"tabindex\",\"-1\"],[11,\"aria-expanded\",[20,\"expanded\"],null],[11,\"onclick\",[26,\"action\",[[22,[\"click\"]]],null],null],[11,\"onkeydown\",[26,\"action\",[[22,[\"keyDown\"]]],null],null],[8],[1,[21,1,[]],false],[9],[0,\"\\n  \"],[6,\"ul\"],[10,\"role\",\"menu\"],[10,\"class\",\"vertical\"],[11,\"onkeydown\",[26,\"action\",[[22,[\"keyDown\"]]],null],null],[8],[0,\"\\n    \"],[13,2],[0,\"\\n  \"],[9],[0,\"\\n\"],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/tei-editor/components/AriaDropdownMenu" } };

    class AriaMenu extends Component {
        /**
         * Handle the key-down event and implement the navigation through the menu
         */
        keyDown(ev) {
            if (ev.keyCode === 39) {
                let nextElement = ev.target.parentElement.nextElementSibling;
                while (nextElement && (nextElement.getAttribute('role') === 'separator' || nextElement.querySelector('*[role="menuitem"]').getAttribute('aria-disabled') === 'true')) {
                    nextElement = nextElement.nextElementSibling;
                }
                if (nextElement) {
                    nextElement.querySelector('*[role="menuitem"]').focus();
                }
            } else if (ev.keyCode === 37) {
                let previousElement = ev.target.parentElement.previousElementSibling;
                while (previousElement && (previousElement.getAttribute('role') === 'separator' || previousElement.querySelector('*[role="menuitem"]').getAttribute('aria-disabled') === 'true')) {
                    previousElement = previousElement.previousElementSibling;
                }
                if (previousElement) {
                    previousElement.querySelector('*[role="menuitem"]').focus();
                }
            }
        }
    }

    var __ui_components_AriaMenu_template__ = { "id": "IoCg9v0u", "block": "{\"symbols\":[\"@class\",\"@label\",\"&default\"],\"statements\":[[6,\"nav\"],[10,\"role\",\"menubar\"],[11,\"class\",[21,1,[]],null],[11,\"arial-label\",[21,2,[]],null],[8],[0,\"\\n  \"],[6,\"ul\"],[10,\"role\",\"menu\"],[11,\"onkeydown\",[26,\"action\",[[22,[\"keyDown\"]]],null],null],[8],[0,\"\\n    \"],[13,3],[0,\"\\n  \"],[9],[0,\"\\n\"],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/tei-editor/components/AriaMenu" } };

    var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    class AriaMenuAction extends Component {
        get tabindex() {
            if (this.args.tabindex !== undefined) {
                return this.args.tabindex;
            } else {
                return -1;
            }
        }
        noAction(ev) {
            ev.preventDefault();
        }
    }
    __decorate$1([tracked], AriaMenuAction.prototype, "tabindex", null);

    var __ui_components_AriaMenuAction_template__ = { "id": "E5+xlPLz", "block": "{\"symbols\":[\"@action\",\"@label\",\"@current\",\"@hidden\",\"&default\",\"@disabled\"],\"statements\":[[6,\"li\"],[10,\"role\",\"presentation\"],[8],[4,\"if\",[[21,6,[]]],null,{\"statements\":[[6,\"a\"],[10,\"role\",\"menuitem\"],[11,\"onclick\",[26,\"action\",[[22,[\"noAction\"]]],null],null],[11,\"tabindex\",[20,\"tabindex\"],null],[11,\"title\",[21,2,[]],null],[11,\"aria-label\",[21,2,[]],null],[10,\"aria-disabled\",\"true\"],[11,\"aria-current\",[21,3,[]],null],[11,\"aria-hidden\",[21,4,[]],null],[8],[13,5],[9]],\"parameters\":[]},{\"statements\":[[6,\"a\"],[10,\"role\",\"menuitem\"],[11,\"onclick\",[21,1,[]],null],[11,\"tabindex\",[20,\"tabindex\"],null],[11,\"title\",[21,2,[]],null],[11,\"aria-label\",[21,2,[]],null],[10,\"aria-disabled\",\"false\"],[11,\"aria-current\",[21,3,[]],null],[11,\"aria-hidden\",[21,4,[]],null],[8],[13,5],[9]],\"parameters\":[]}],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/tei-editor/components/AriaMenuAction" } };

    /**
     * Recursively clone the object.
     */
    function recursive_clone(obj) {
        if (obj === undefined) {
            return undefined;
        } else if (obj === null) {
            return null;
        } else if (Array.isArray(obj)) {
            return obj.slice();
        } else if (typeof obj === 'object') {
            let clone = {};
            Object.keys(obj).forEach(function (key) {
                clone[key] = recursive_clone(obj[key]);
            });
            return clone;
        } else {
            return obj;
        }
    }
    /**
     * Performs a deep cloning of the first element of the parameters.
     */
    function deepclone(params) {
        return recursive_clone(params[0]);
    }

    function get(params) {
        let obj = params[0];
        let path = params[1].split('.');
        while (obj && path.length > 0) {
            obj = obj[path[0]];
            path = path.slice(1);
        }
        return obj;
    }

    /**
     * Sets the third parameter value identified by the path in the second parameter value in the first parameter value .
     */
    function set(params) {
        let clone = params[0];
        let path = params[1].split('.');
        let current = clone;
        while (path.length > 0) {
            if (path.length > 1) {
                if (!current[path[0]]) {
                    current[path[0]] = {};
                }
                current = current[path[0]];
            } else {
                current[path[0]] = params[2];
            }
            path.splice(0, 1);
        }
        return clone;
    }

    class MetadataEditor extends Component {
        /**
         * Sets the content of a single value field, regardless whether it is an attribute or text. Also handles traversal
         * through array indices.
         */
        setMetadataField(path, ev) {
            ev.preventDefault();
            let clone = deepclone([this.args.metadata]);
            clone = set([clone, path, ev.target.value]);
            this.args.update(clone);
        }
        /**
         * Adds a row to a multi-row field.
         */
        addMultiFieldRow(path, entries, ev) {
            ev.preventDefault();
            let clone = deepclone([this.args.metadata]);
            let field = get([clone, path]);
            let new_row = [];
            entries.forEach(entry => {
                let new_column = {};
                new_column = set([new_column, entry.path, '']);
                new_row.push(new_column);
            });
            field.push(new_row);
            this.args.update(clone);
        }
        /**
         * Removes a row from a multi-row field.
         */
        removeMultiFieldRow(path, idx, ev) {
            ev.preventDefault();
            let clone = deepclone([this.args.metadata]);
            let field = get([clone, path]);
            field.splice(idx, 1);
            this.args.update(clone);
        }
        /**
         * Move a row in a multi-row field one row up.
         */
        moveMultiFieldRowUp(path, idx, ev) {
            ev.preventDefault();
            let clone = deepclone([this.args.metadata]);
            let field = get([clone, path]);
            let mover = field[idx];
            field.splice(idx, 1);
            field.splice(idx - 1, 0, mover);
            this.args.update(clone);
        }
        /**
         * Move a row in a multi-row field one row down.
         */
        moveMultiFieldRowDown(path, idx, ev) {
            ev.preventDefault();
            let clone = deepclone([this.args.metadata]);
            let field = get([clone, path]);
            let mover = field[idx];
            field.splice(idx, 1);
            field.splice(idx + 1, 0, mover);
            this.args.update(clone);
        }
    }

    var __ui_components_MetadataEditor_template__ = { "id": "0OMKJLJ6", "block": "{\"symbols\":[\"section\",\"entry\",\"value\",\"value_idx\",\"part_entry\",\"part_idx\",\"@metadata\",\"@config\"],\"statements\":[[6,\"dl\"],[8],[0,\"\\n\"],[4,\"each\",[[21,8,[]]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"    \"],[6,\"dt\"],[8],[1,[21,1,[\"title\"]],false],[9],[0,\"\\n    \"],[6,\"dd\"],[8],[0,\"\\n      \"],[6,\"ul\"],[8],[0,\"\\n\"],[4,\"each\",[[21,1,[\"entries\"]]],[[\"key\"],[\"@index\"]],{\"statements\":[[4,\"if\",[[26,\"eq\",[[21,2,[\"type\"]],\"single-text\"],null]],null,{\"statements\":[[0,\"            \"],[6,\"li\"],[10,\"class\",\"tei-editor-metadata-single\"],[8],[6,\"label\"],[8],[1,[21,2,[\"label\"]],false],[6,\"input\"],[10,\"type\",\"text\"],[11,\"value\",[26,\"get\",[[21,7,[]],[21,2,[\"path\"]]],null],null],[11,\"onchange\",[26,\"action\",[[22,[\"setMetadataField\"]],[21,2,[\"path\"]]],null],null],[8],[9],[9],[9],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[21,2,[\"type\"]],\"multi-field\"],null]],null,{\"statements\":[[0,\"            \"],[6,\"li\"],[10,\"class\",\"tei-editor-metadata-multiple\"],[8],[0,\"\\n\"],[4,\"each\",[[26,\"get\",[[21,7,[]],[21,2,[\"path\"]]],null]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"              \"],[6,\"div\"],[8],[0,\"\\n\"],[4,\"each\",[[21,2,[\"entries\"]]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"                  \"],[6,\"div\"],[8],[6,\"label\"],[8],[1,[21,5,[\"label\"]],false],[6,\"input\"],[10,\"type\",\"text\"],[11,\"value\",[26,\"get\",[[21,3,[]],[21,5,[\"path\"]]],null],null],[11,\"onchange\",[26,\"action\",[[22,[\"setMetadataField\"]],[26,\"join\",[\".\",[21,2,[\"path\"]],[21,4,[]],[21,5,[\"path\"]]],null]],null],null],[8],[9],[9],[9],[0,\"\\n\"]],\"parameters\":[5,6]},null],[0,\"                \"],[6,\"nav\"],[8],[0,\"\\n                  \"],[5,\"AriaMenu\",[],[[],[]],{\"statements\":[[0,\"\\n                    \"],[5,\"AriaMenuAction\",[],[[\"@tabindex\",\"@label\",\"@action\"],[\"0\",\"Delete this row\",[26,\"action\",[[22,[\"removeMultiFieldRow\"]],[21,2,[\"path\"]],[21,4,[]]],null]]],{\"statements\":[[0,\"Delete\"]],\"parameters\":[]}],[0,\"\\n                    \"],[5,\"AriaMenuAction\",[],[[\"@tabindex\",\"@label\",\"@disabled\",\"@action\"],[\"-1\",\"Move this row up one\",[26,\"array-first\",[[26,\"get\",[[21,7,[]],[21,2,[\"path\"]]],null],[21,4,[]]],null],[26,\"action\",[[22,[\"moveMultiFieldRowUp\"]],[21,2,[\"path\"]],[21,4,[]]],null]]],{\"statements\":[[0,\"Up\"]],\"parameters\":[]}],[0,\"\\n                    \"],[5,\"AriaMenuAction\",[],[[\"@tabindex\",\"@label\",\"@disabled\",\"@action\"],[\"-1\",\"Move this row one down\",[26,\"array-last\",[[26,\"get\",[[21,7,[]],[21,2,[\"path\"]]],null],[21,4,[]]],null],[26,\"action\",[[22,[\"moveMultiFieldRowDown\"]],[21,2,[\"path\"]],[21,4,[]]],null]]],{\"statements\":[[0,\"Down\"]],\"parameters\":[]}],[0,\"\\n                  \"]],\"parameters\":[]}],[0,\"\\n                \"],[9],[0,\"\\n              \"],[9],[0,\"\\n\"]],\"parameters\":[3,4]},null],[0,\"              \"],[5,\"AriaMenu\",[],[[],[]],{\"statements\":[[0,\"\\n                \"],[5,\"AriaMenuAction\",[],[[\"@tabindex\",\"@label\",\"@action\"],[\"0\",\"Add a new row\",[26,\"action\",[[22,[\"addMultiFieldRow\"]],[21,2,[\"path\"]],[21,2,[\"entries\"]]],null]]],{\"statements\":[[0,\"Add\"]],\"parameters\":[]}],[0,\"\\n              \"]],\"parameters\":[]}],[0,\"\\n            \"],[9],[0,\"\\n\"]],\"parameters\":[]},null]],\"parameters\":[2]},null],[0,\"      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n\"]],\"parameters\":[1]},null],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/tei-editor/components/MetadataEditor" } };

    var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    class MultiText extends Component {
        constructor() {
            super(...arguments);
            this.texts = null;
            this.selectedIdx = null;
            this.text = null;
        }
        // Lifecycle events
        didUpdate() {
            if (this.texts !== this.args.texts) {
                this.texts = this.args.texts;
                if (this.texts && this.texts.length > 0) {
                    if (this.selectedIdx !== null) {
                        if (this.selectedIdx >= 0 && this.selectedIdx < this.texts.length) {
                            this.text = this.texts[this.selectedIdx].text;
                        } else {
                            if (this.texts && this.texts.length > 0) {
                                this.selectedIdx = 0;
                                this.text = this.texts[this.selectedIdx].text;
                            } else {
                                this.selectedIdx = null;
                                this.text = null;
                            }
                        }
                    } else {
                        this.selectedIdx = 0;
                        this.text = this.texts[this.selectedIdx].text;
                    }
                } else {
                    this.selectedIdx = null;
                    this.text = null;
                }
            }
        }
        // Action handlers
        /**
         * Event handler for when the user selects a text. Update the displayed text.
         */
        selectText(ev) {
            ev.preventDefault();
            this.selectedIdx = Number.parseInt(ev.target.value);
            this.text = this.texts[this.selectedIdx].text;
        }
        /**
         * Update a text
         */
        updateText(updatedText) {
            this.texts[this.selectedIdx] = {
                id: updatedText.attrs.id,
                text: updatedText
            };
            this.text = updatedText;
            this.args.update(this.texts);
        }
        /**
         * Delete the currently selected text
         */
        deleteText() {
            let texts = deepclone([this.texts]);
            console.log(this.selectedIdx);
            texts.splice(this.selectedIdx, 1);
            this.args.update(texts);
        }
        /**
         * Add a new text
         */
        addText() {
            let texts = deepclone([this.texts]);
            let newIdx = 0;
            let exists = true;
            while (exists) {
                exists = false;
                newIdx = newIdx + 1;
                for (let idx = 0; idx < texts.length; idx++) {
                    if (texts[idx].id === 'new-text-' + newIdx) {
                        exists = true;
                        break;
                    }
                }
            }
            let text = {
                id: 'new-text-' + newIdx,
                text: deepclone([this.args.default])
            };
            if (!text.text.attrs) {
                text.text.attrs = {};
            }
            text.text.attrs.id = 'new-text-' + newIdx;
            texts.push(text);
            this.selectedIdx = texts.length - 1;
            this.text = texts[this.selectedIdx].text;
            this.args.update(texts);
        }
    }
    __decorate$2([tracked], MultiText.prototype, "texts", void 0);
    __decorate$2([tracked], MultiText.prototype, "selectedIdx", void 0);
    __decorate$2([tracked], MultiText.prototype, "text", void 0);

    var __ui_components_MultiText_template__ = { "id": "8ruI8+Tc", "block": "{\"symbols\":[\"text\",\"idx\",\"@schema\",\"@ui\",\"@multiTexts\",\"@texts\"],\"statements\":[[6,\"nav\"],[10,\"class\",\"tei-editor-menubar\"],[8],[0,\"\\n  \"],[5,\"AriaMenu\",[],[[\"@label\"],[\"Individual Annotation\"]],{\"statements\":[[0,\"\\n    \"],[6,\"li\"],[10,\"role\",\"presentation\"],[8],[0,\"\\n      \"],[6,\"select\"],[10,\"role\",\"menuitem\"],[10,\"tabindex\",\"0\"],[10,\"aria-label\",\"Select the text to edit\"],[11,\"onchange\",[26,\"action\",[[22,[\"selectText\"]]],null],null],[8],[0,\"\\n\"],[4,\"each\",[[21,6,[]]],[[\"key\"],[\"@index\"]],{\"statements\":[[4,\"if\",[[26,\"eq\",[[21,2,[]],[22,[\"selectedIdx\"]]],null]],null,{\"statements\":[[0,\"            \"],[6,\"option\"],[11,\"value\",[21,2,[]],null],[10,\"selected\",\"selected\"],[8],[1,[21,1,[\"id\"]],false],[9],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"            \"],[6,\"option\"],[11,\"value\",[21,2,[]],null],[8],[1,[21,1,[\"id\"]],false],[9],[0,\"\\n\"]],\"parameters\":[]}]],\"parameters\":[1,2]},null],[0,\"      \"],[9],[0,\"\\n    \"],[9],[0,\"\\n    \"],[5,\"AriaMenuAction\",[],[[\"@label\",\"@tabindex\",\"@disabled\",\"@action\"],[\"Delete this text\",\"-1\",[26,\"eq\",[[26,\"get\",[[22,[\"texts\"]],\"length\"],null],0],null],[26,\"action\",[[22,[\"deleteText\"]]],null]]],{\"statements\":[[0,\"Delete\"]],\"parameters\":[]}],[0,\"\\n    \"],[5,\"AriaMenuAction\",[],[[\"@label\",\"@tabindex\",\"@action\"],[\"Add a text\",\"-1\",[26,\"action\",[[22,[\"addText\"]]],null]]],{\"statements\":[[0,\"Add\"]],\"parameters\":[]}],[0,\"\\n  \"]],\"parameters\":[]}],[0,\"\\n\"],[9],[0,\"\\n\"],[6,\"div\"],[8],[0,\"\\n\"],[4,\"if\",[[22,[\"text\"]]],null,{\"statements\":[[0,\"    \"],[5,\"ProsemirrorEditor\",[],[[\"@schema\",\"@ui\",\"@text\",\"@multiTexts\",\"@update\"],[[21,3,[]],[21,4,[]],[20,\"text\"],[21,5,[]],[26,\"action\",[[22,[\"updateText\"]]],null]]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},null],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/tei-editor/components/MultiText" } };

    // import Logger from './logger';

    let GUID$3 = 0;
    function initializeGuid$3(object) {
        return object._guid = ++GUID$3;
    }
    function ensureGuid$3(object) {
        return object._guid || initializeGuid$3(object);
    }

    const EMPTY_ARRAY$3 = Object.freeze([]);

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    // ::- Persistent data structure representing an ordered mapping from
    // strings to values, with some convenient update methods.
    function OrderedMap(content) {
      this.content = content;
    }

    OrderedMap.prototype = {
      constructor: OrderedMap,

      find: function find(key) {
        for (var i = 0; i < this.content.length; i += 2) if (this.content[i] === key) return i;
        return -1;
      },

      // :: (string) → ?any
      // Retrieve the value stored under `key`, or return undefined when
      // no such key exists.
      get: function get(key) {
        var found = this.find(key);
        return found == -1 ? undefined : this.content[found + 1];
      },

      // :: (string, any, ?string) → OrderedMap
      // Create a new map by replacing the value of `key` with a new
      // value, or adding a binding to the end of the map. If `newKey` is
      // given, the key of the binding will be replaced with that key.
      update: function update(key, value, newKey) {
        var self = newKey && newKey != key ? this.remove(newKey) : this;
        var found = self.find(key),
            content = self.content.slice();
        if (found == -1) {
          content.push(newKey || key, value);
        } else {
          content[found + 1] = value;
          if (newKey) content[found] = newKey;
        }
        return new OrderedMap(content);
      },

      // :: (string) → OrderedMap
      // Return a map with the given key removed, if it existed.
      remove: function remove(key) {
        var found = this.find(key);
        if (found == -1) return this;
        var content = this.content.slice();
        content.splice(found, 2);
        return new OrderedMap(content);
      },

      // :: (string, any) → OrderedMap
      // Add a new key to the start of the map.
      addToStart: function addToStart(key, value) {
        return new OrderedMap([key, value].concat(this.remove(key).content));
      },

      // :: (string, any) → OrderedMap
      // Add a new key to the end of the map.
      addToEnd: function addToEnd(key, value) {
        var content = this.remove(key).content.slice();
        content.push(key, value);
        return new OrderedMap(content);
      },

      // :: (string, string, any) → OrderedMap
      // Add a key after the given key. If `place` is not found, the new
      // key is added to the end.
      addBefore: function addBefore(place, key, value) {
        var without = this.remove(key),
            content = without.content.slice();
        var found = without.find(place);
        content.splice(found == -1 ? content.length : found, 0, key, value);
        return new OrderedMap(content);
      },

      // :: ((key: string, value: any))
      // Call the given function for each key/value pair in the map, in
      // order.
      forEach: function forEach(f) {
        for (var i = 0; i < this.content.length; i += 2) f(this.content[i], this.content[i + 1]);
      },

      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by prepending the keys in this map that don't
      // appear in `map` before the keys in `map`.
      prepend: function prepend(map) {
        map = OrderedMap.from(map);
        if (!map.size) return this;
        return new OrderedMap(map.content.concat(this.subtract(map).content));
      },

      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by appending the keys in this map that don't
      // appear in `map` after the keys in `map`.
      append: function append(map) {
        map = OrderedMap.from(map);
        if (!map.size) return this;
        return new OrderedMap(this.subtract(map).content.concat(map.content));
      },

      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a map containing all the keys in this map that don't
      // appear in `map`.
      subtract: function subtract(map) {
        var result = this;
        map = OrderedMap.from(map);
        for (var i = 0; i < map.content.length; i += 2) result = result.remove(map.content[i]);
        return result;
      },

      // :: number
      // The amount of keys in this map.
      get size() {
        return this.content.length >> 1;
      }
    };

    // :: (?union<Object, OrderedMap>) → OrderedMap
    // Return a map with the given content. If null, create an empty
    // map. If given an ordered map, return that map itself. If given an
    // object, create a map from the object's properties.
    OrderedMap.from = function (value) {
      if (value instanceof OrderedMap) return value;
      var content = [];
      if (value) for (var prop in value) content.push(prop, value[prop]);
      return new OrderedMap(content);
    };

    var orderedmap = OrderedMap;

    var dist = createCommonjsModule(function (module, exports) {

      Object.defineProperty(exports, '__esModule', { value: true });

      function _interopDefault(ex) {
        return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
      }

      var OrderedMap = _interopDefault(orderedmap);

      function findDiffStart(a, b, pos) {
        for (var i = 0;; i++) {
          if (i == a.childCount || i == b.childCount) {
            return a.childCount == b.childCount ? null : pos;
          }

          var childA = a.child(i),
              childB = b.child(i);
          if (childA == childB) {
            pos += childA.nodeSize;continue;
          }

          if (!childA.sameMarkup(childB)) {
            return pos;
          }

          if (childA.isText && childA.text != childB.text) {
            for (var j = 0; childA.text[j] == childB.text[j]; j++) {
              pos++;
            }
            return pos;
          }
          if (childA.content.size || childB.content.size) {
            var inner = findDiffStart(childA.content, childB.content, pos + 1);
            if (inner != null) {
              return inner;
            }
          }
          pos += childA.nodeSize;
        }
      }

      function findDiffEnd(a, b, posA, posB) {
        for (var iA = a.childCount, iB = b.childCount;;) {
          if (iA == 0 || iB == 0) {
            return iA == iB ? null : { a: posA, b: posB };
          }

          var childA = a.child(--iA),
              childB = b.child(--iB),
              size = childA.nodeSize;
          if (childA == childB) {
            posA -= size;posB -= size;
            continue;
          }

          if (!childA.sameMarkup(childB)) {
            return { a: posA, b: posB };
          }

          if (childA.isText && childA.text != childB.text) {
            var same = 0,
                minSize = Math.min(childA.text.length, childB.text.length);
            while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
              same++;posA--;posB--;
            }
            return { a: posA, b: posB };
          }
          if (childA.content.size || childB.content.size) {
            var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
            if (inner) {
              return inner;
            }
          }
          posA -= size;posB -= size;
        }
      }

      // ::- A fragment represents a node's collection of child nodes.
      //
      // Like nodes, fragments are persistent data structures, and you
      // should not mutate them or their content. Rather, you create new
      // instances whenever needed. The API tries to make this easy.
      var Fragment = function Fragment(content, size) {
        var this$1 = this;

        this.content = content;
        // :: number
        // The size of the fragment, which is the total of the size of its
        // content nodes.
        this.size = size || 0;
        if (size == null) {
          for (var i = 0; i < content.length; i++) {
            this$1.size += content[i].nodeSize;
          }
        }
      };

      var prototypeAccessors$1 = { firstChild: {}, lastChild: {}, childCount: {} };

      // :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)
      // Invoke a callback for all descendant nodes between the given two
      // positions (relative to start of this fragment). Doesn't descend
      // into a node when the callback returns `false`.
      Fragment.prototype.nodesBetween = function nodesBetween(from, to, f, nodeStart, parent) {
        var this$1 = this;
        if (nodeStart === void 0) nodeStart = 0;

        for (var i = 0, pos = 0; pos < to; i++) {
          var child = this$1.content[i],
              end = pos + child.nodeSize;
          if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {
            var start = pos + 1;
            child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
          }
          pos = end;
        }
      };

      // :: ((node: Node, pos: number, parent: Node) → ?bool)
      // Call the given callback for every descendant node. The callback
      // may return `false` to prevent traversal of a given node's children.
      Fragment.prototype.descendants = function descendants(f) {
        this.nodesBetween(0, this.size, f);
      };

      // : (number, number, ?string, ?string) → string
      Fragment.prototype.textBetween = function textBetween(from, to, blockSeparator, leafText) {
        var text = "",
            separated = true;
        this.nodesBetween(from, to, function (node, pos) {
          if (node.isText) {
            text += node.text.slice(Math.max(from, pos) - pos, to - pos);
            separated = !blockSeparator;
          } else if (node.isLeaf && leafText) {
            text += leafText;
            separated = !blockSeparator;
          } else if (!separated && node.isBlock) {
            text += blockSeparator;
            separated = true;
          }
        }, 0);
        return text;
      };

      // :: (Fragment) → Fragment
      // Create a new fragment containing the combined content of this
      // fragment and the other.
      Fragment.prototype.append = function append(other) {
        if (!other.size) {
          return this;
        }
        if (!this.size) {
          return other;
        }
        var last = this.lastChild,
            first = other.firstChild,
            content = this.content.slice(),
            i = 0;
        if (last.isText && last.sameMarkup(first)) {
          content[content.length - 1] = last.withText(last.text + first.text);
          i = 1;
        }
        for (; i < other.content.length; i++) {
          content.push(other.content[i]);
        }
        return new Fragment(content, this.size + other.size);
      };

      // :: (number, ?number) → Fragment
      // Cut out the sub-fragment between the two given positions.
      Fragment.prototype.cut = function cut(from, to) {
        var this$1 = this;

        if (to == null) {
          to = this.size;
        }
        if (from == 0 && to == this.size) {
          return this;
        }
        var result = [],
            size = 0;
        if (to > from) {
          for (var i = 0, pos = 0; pos < to; i++) {
            var child = this$1.content[i],
                end = pos + child.nodeSize;
            if (end > from) {
              if (pos < from || end > to) {
                if (child.isText) {
                  child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
                } else {
                  child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
                }
              }
              result.push(child);
              size += child.nodeSize;
            }
            pos = end;
          }
        }
        return new Fragment(result, size);
      };

      Fragment.prototype.cutByIndex = function cutByIndex(from, to) {
        if (from == to) {
          return Fragment.empty;
        }
        if (from == 0 && to == this.content.length) {
          return this;
        }
        return new Fragment(this.content.slice(from, to));
      };

      // :: (number, Node) → Fragment
      // Create a new fragment in which the node at the given index is
      // replaced by the given node.
      Fragment.prototype.replaceChild = function replaceChild(index, node) {
        var current = this.content[index];
        if (current == node) {
          return this;
        }
        var copy = this.content.slice();
        var size = this.size + node.nodeSize - current.nodeSize;
        copy[index] = node;
        return new Fragment(copy, size);
      };

      // : (Node) → Fragment
      // Create a new fragment by prepending the given node to this
      // fragment.
      Fragment.prototype.addToStart = function addToStart(node) {
        return new Fragment([node].concat(this.content), this.size + node.nodeSize);
      };

      // : (Node) → Fragment
      // Create a new fragment by appending the given node to this
      // fragment.
      Fragment.prototype.addToEnd = function addToEnd(node) {
        return new Fragment(this.content.concat(node), this.size + node.nodeSize);
      };

      // :: (Fragment) → bool
      // Compare this fragment to another one.
      Fragment.prototype.eq = function eq(other) {
        var this$1 = this;

        if (this.content.length != other.content.length) {
          return false;
        }
        for (var i = 0; i < this.content.length; i++) {
          if (!this$1.content[i].eq(other.content[i])) {
            return false;
          }
        }
        return true;
      };

      // :: ?Node
      // The first child of the fragment, or `null` if it is empty.
      prototypeAccessors$1.firstChild.get = function () {
        return this.content.length ? this.content[0] : null;
      };

      // :: ?Node
      // The last child of the fragment, or `null` if it is empty.
      prototypeAccessors$1.lastChild.get = function () {
        return this.content.length ? this.content[this.content.length - 1] : null;
      };

      // :: number
      // The number of child nodes in this fragment.
      prototypeAccessors$1.childCount.get = function () {
        return this.content.length;
      };

      // :: (number) → Node
      // Get the child node at the given index. Raise an error when the
      // index is out of range.
      Fragment.prototype.child = function child(index) {
        var found = this.content[index];
        if (!found) {
          throw new RangeError("Index " + index + " out of range for " + this);
        }
        return found;
      };

      // :: (number) → ?Node
      // Get the child node at the given index, if it exists.
      Fragment.prototype.maybeChild = function maybeChild(index) {
        return this.content[index];
      };

      // :: ((node: Node, offset: number, index: number))
      // Call `f` for every child node, passing the node, its offset
      // into this parent node, and its index.
      Fragment.prototype.forEach = function forEach(f) {
        var this$1 = this;

        for (var i = 0, p = 0; i < this.content.length; i++) {
          var child = this$1.content[i];
          f(child, p, i);
          p += child.nodeSize;
        }
      };

      // :: (Fragment) → ?number
      // Find the first position at which this fragment and another
      // fragment differ, or `null` if they are the same.
      Fragment.prototype.findDiffStart = function findDiffStart$1(other, pos) {
        if (pos === void 0) pos = 0;

        return findDiffStart(this, other, pos);
      };

      // :: (Fragment) → ?{a: number, b: number}
      // Find the first position, searching from the end, at which this
      // fragment and the given fragment differ, or `null` if they are the
      // same. Since this position will not be the same in both nodes, an
      // object with two separate positions is returned.
      Fragment.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {
        if (pos === void 0) pos = this.size;
        if (otherPos === void 0) otherPos = other.size;

        return findDiffEnd(this, other, pos, otherPos);
      };

      // : (number, ?number) → {index: number, offset: number}
      // Find the index and inner offset corresponding to a given relative
      // position in this fragment. The result object will be reused
      // (overwritten) the next time the function is called. (Not public.)
      Fragment.prototype.findIndex = function findIndex(pos, round) {
        var this$1 = this;
        if (round === void 0) round = -1;

        if (pos == 0) {
          return retIndex(0, pos);
        }
        if (pos == this.size) {
          return retIndex(this.content.length, pos);
        }
        if (pos > this.size || pos < 0) {
          throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
        }
        for (var i = 0, curPos = 0;; i++) {
          var cur = this$1.child(i),
              end = curPos + cur.nodeSize;
          if (end >= pos) {
            if (end == pos || round > 0) {
              return retIndex(i + 1, end);
            }
            return retIndex(i, curPos);
          }
          curPos = end;
        }
      };

      // :: () → string
      // Return a debugging string that describes this fragment.
      Fragment.prototype.toString = function toString() {
        return "<" + this.toStringInner() + ">";
      };

      Fragment.prototype.toStringInner = function toStringInner() {
        return this.content.join(", ");
      };

      // :: () → ?Object
      // Create a JSON-serializeable representation of this fragment.
      Fragment.prototype.toJSON = function toJSON() {
        return this.content.length ? this.content.map(function (n) {
          return n.toJSON();
        }) : null;
      };

      // :: (Schema, ?Object) → Fragment
      // Deserialize a fragment from its JSON representation.
      Fragment.fromJSON = function fromJSON(schema, value) {
        if (!value) {
          return Fragment.empty;
        }
        if (!Array.isArray(value)) {
          throw new RangeError("Invalid input for Fragment.fromJSON");
        }
        return new Fragment(value.map(schema.nodeFromJSON));
      };

      // :: ([Node]) → Fragment
      // Build a fragment from an array of nodes. Ensures that adjacent
      // text nodes with the same marks are joined together.
      Fragment.fromArray = function fromArray(array) {
        if (!array.length) {
          return Fragment.empty;
        }
        var joined,
            size = 0;
        for (var i = 0; i < array.length; i++) {
          var node = array[i];
          size += node.nodeSize;
          if (i && node.isText && array[i - 1].sameMarkup(node)) {
            if (!joined) {
              joined = array.slice(0, i);
            }
            joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
          } else if (joined) {
            joined.push(node);
          }
        }
        return new Fragment(joined || array, size);
      };

      // :: (?union<Fragment, Node, [Node]>) → Fragment
      // Create a fragment from something that can be interpreted as a set
      // of nodes. For `null`, it returns the empty fragment. For a
      // fragment, the fragment itself. For a node or array of nodes, a
      // fragment containing those nodes.
      Fragment.from = function from(nodes) {
        if (!nodes) {
          return Fragment.empty;
        }
        if (nodes instanceof Fragment) {
          return nodes;
        }
        if (Array.isArray(nodes)) {
          return this.fromArray(nodes);
        }
        return new Fragment([nodes], nodes.nodeSize);
      };

      Object.defineProperties(Fragment.prototype, prototypeAccessors$1);

      var found = { index: 0, offset: 0 };
      function retIndex(index, offset) {
        found.index = index;
        found.offset = offset;
        return found;
      }

      // :: Fragment
      // An empty fragment. Intended to be reused whenever a node doesn't
      // contain anything (rather than allocating a new empty fragment for
      // each leaf node).
      Fragment.empty = new Fragment([], 0);

      function compareDeep(a, b) {
        if (a === b) {
          return true;
        }
        if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
          return false;
        }
        var array = Array.isArray(a);
        if (Array.isArray(b) != array) {
          return false;
        }
        if (array) {
          if (a.length != b.length) {
            return false;
          }
          for (var i = 0; i < a.length; i++) {
            if (!compareDeep(a[i], b[i])) {
              return false;
            }
          }
        } else {
          for (var p in a) {
            if (!(p in b) || !compareDeep(a[p], b[p])) {
              return false;
            }
          }
          for (var p$1 in b) {
            if (!(p$1 in a)) {
              return false;
            }
          }
        }
        return true;
      }

      // ::- A mark is a piece of information that can be attached to a node,
      // such as it being emphasized, in code font, or a link. It has a type
      // and optionally a set of attributes that provide further information
      // (such as the target of the link). Marks are created through a
      // `Schema`, which controls which types exist and which
      // attributes they have.
      var Mark = function Mark(type, attrs) {
        // :: MarkType
        // The type of this mark.
        this.type = type;
        // :: Object
        // The attributes associated with this mark.
        this.attrs = attrs;
      };

      // :: ([Mark]) → [Mark]
      // Given a set of marks, create a new set which contains this one as
      // well, in the right position. If this mark is already in the set,
      // the set itself is returned. If any marks that are set to be
      // [exclusive](#model.MarkSpec.excludes) with this mark are present,
      // those are replaced by this one.
      Mark.prototype.addToSet = function addToSet(set) {
        var this$1 = this;

        var copy,
            placed = false;
        for (var i = 0; i < set.length; i++) {
          var other = set[i];
          if (this$1.eq(other)) {
            return set;
          }
          if (this$1.type.excludes(other.type)) {
            if (!copy) {
              copy = set.slice(0, i);
            }
          } else if (other.type.excludes(this$1.type)) {
            return set;
          } else {
            if (!placed && other.type.rank > this$1.type.rank) {
              if (!copy) {
                copy = set.slice(0, i);
              }
              copy.push(this$1);
              placed = true;
            }
            if (copy) {
              copy.push(other);
            }
          }
        }
        if (!copy) {
          copy = set.slice();
        }
        if (!placed) {
          copy.push(this);
        }
        return copy;
      };

      // :: ([Mark]) → [Mark]
      // Remove this mark from the given set, returning a new set. If this
      // mark is not in the set, the set itself is returned.
      Mark.prototype.removeFromSet = function removeFromSet(set) {
        var this$1 = this;

        for (var i = 0; i < set.length; i++) {
          if (this$1.eq(set[i])) {
            return set.slice(0, i).concat(set.slice(i + 1));
          }
        }
        return set;
      };

      // :: ([Mark]) → bool
      // Test whether this mark is in the given set of marks.
      Mark.prototype.isInSet = function isInSet(set) {
        var this$1 = this;

        for (var i = 0; i < set.length; i++) {
          if (this$1.eq(set[i])) {
            return true;
          }
        }
        return false;
      };

      // :: (Mark) → bool
      // Test whether this mark has the same type and attributes as
      // another mark.
      Mark.prototype.eq = function eq(other) {
        return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
      };

      // :: () → Object
      // Convert this mark to a JSON-serializeable representation.
      Mark.prototype.toJSON = function toJSON() {
        var this$1 = this;

        var obj = { type: this.type.name };
        for (var _ in this$1.attrs) {
          obj.attrs = this$1.attrs;
          break;
        }
        return obj;
      };

      // :: (Schema, Object) → Mark
      Mark.fromJSON = function fromJSON(schema, json) {
        if (!json) {
          throw new RangeError("Invalid input for Mark.fromJSON");
        }
        var type = schema.marks[json.type];
        if (!type) {
          throw new RangeError("There is no mark type " + json.type + " in this schema");
        }
        return type.create(json.attrs);
      };

      // :: ([Mark], [Mark]) → bool
      // Test whether two sets of marks are identical.
      Mark.sameSet = function sameSet(a, b) {
        if (a == b) {
          return true;
        }
        if (a.length != b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (!a[i].eq(b[i])) {
            return false;
          }
        }
        return true;
      };

      // :: (?union<Mark, [Mark]>) → [Mark]
      // Create a properly sorted mark set from null, a single mark, or an
      // unsorted array of marks.
      Mark.setFrom = function setFrom(marks) {
        if (!marks || marks.length == 0) {
          return Mark.none;
        }
        if (marks instanceof Mark) {
          return [marks];
        }
        var copy = marks.slice();
        copy.sort(function (a, b) {
          return a.type.rank - b.type.rank;
        });
        return copy;
      };

      // :: [Mark] The empty set of marks.
      Mark.none = [];

      // ReplaceError:: class extends Error
      // Error type raised by [`Node.replace`](#model.Node.replace) when
      // given an invalid replacement.

      function ReplaceError(message) {
        var err = Error.call(this, message);
        err.__proto__ = ReplaceError.prototype;
        return err;
      }

      ReplaceError.prototype = Object.create(Error.prototype);
      ReplaceError.prototype.constructor = ReplaceError;
      ReplaceError.prototype.name = "ReplaceError";

      // ::- A slice represents a piece cut out of a larger document. It
      // stores not only a fragment, but also the depth up to which nodes on
      // both side are ‘open’ (cut through).
      var Slice = function Slice(content, openStart, openEnd) {
        // :: Fragment The slice's content.
        this.content = content;
        // :: number The open depth at the start.
        this.openStart = openStart;
        // :: number The open depth at the end.
        this.openEnd = openEnd;
      };

      var prototypeAccessors$2 = { size: {} };

      // :: number
      // The size this slice would add when inserted into a document.
      prototypeAccessors$2.size.get = function () {
        return this.content.size - this.openStart - this.openEnd;
      };

      Slice.prototype.insertAt = function insertAt(pos, fragment) {
        var content = insertInto(this.content, pos + this.openStart, fragment, null);
        return content && new Slice(content, this.openStart, this.openEnd);
      };

      Slice.prototype.removeBetween = function removeBetween(from, to) {
        return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
      };

      // :: (Slice) → bool
      // Tests whether this slice is equal to another slice.
      Slice.prototype.eq = function eq(other) {
        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
      };

      Slice.prototype.toString = function toString() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      };

      // :: () → ?Object
      // Convert a slice to a JSON-serializable representation.
      Slice.prototype.toJSON = function toJSON() {
        if (!this.content.size) {
          return null;
        }
        var json = { content: this.content.toJSON() };
        if (this.openStart > 0) {
          json.openStart = this.openStart;
        }
        if (this.openEnd > 0) {
          json.openEnd = this.openEnd;
        }
        return json;
      };

      // :: (Schema, ?Object) → Slice
      // Deserialize a slice from its JSON representation.
      Slice.fromJSON = function fromJSON(schema, json) {
        if (!json) {
          return Slice.empty;
        }
        var openStart = json.openStart || 0,
            openEnd = json.openEnd || 0;
        if (typeof openStart != "number" || typeof openEnd != "number") {
          throw new RangeError("Invalid input for Slice.fromJSON");
        }
        return new Slice(Fragment.fromJSON(schema, json.content), json.openStart || 0, json.openEnd || 0);
      };

      // :: (Fragment, ?bool) → Slice
      // Create a slice from a fragment by taking the maximum possible
      // open value on both side of the fragment.
      Slice.maxOpen = function maxOpen(fragment, openIsolating) {
        if (openIsolating === void 0) openIsolating = true;

        var openStart = 0,
            openEnd = 0;
        for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
          openStart++;
        }
        for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {
          openEnd++;
        }
        return new Slice(fragment, openStart, openEnd);
      };

      Object.defineProperties(Slice.prototype, prototypeAccessors$2);

      function removeRange(content, from, to) {
        var ref = content.findIndex(from);
        var index = ref.index;
        var offset = ref.offset;
        var child = content.maybeChild(index);
        var ref$1 = content.findIndex(to);
        var indexTo = ref$1.index;
        var offsetTo = ref$1.offset;
        if (offset == from || child.isText) {
          if (offsetTo != to && !content.child(indexTo).isText) {
            throw new RangeError("Removing non-flat range");
          }
          return content.cut(0, from).append(content.cut(to));
        }
        if (index != indexTo) {
          throw new RangeError("Removing non-flat range");
        }
        return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
      }

      function insertInto(content, dist, insert, parent) {
        var ref = content.findIndex(dist);
        var index = ref.index;
        var offset = ref.offset;
        var child = content.maybeChild(index);
        if (offset == dist || child.isText) {
          if (parent && !parent.canReplace(index, index, insert)) {
            return null;
          }
          return content.cut(0, dist).append(insert).append(content.cut(dist));
        }
        var inner = insertInto(child.content, dist - offset - 1, insert);
        return inner && content.replaceChild(index, child.copy(inner));
      }

      // :: Slice
      // The empty slice.
      Slice.empty = new Slice(Fragment.empty, 0, 0);

      function replace($from, $to, slice) {
        if (slice.openStart > $from.depth) {
          throw new ReplaceError("Inserted content deeper than insertion position");
        }
        if ($from.depth - slice.openStart != $to.depth - slice.openEnd) {
          throw new ReplaceError("Inconsistent open depths");
        }
        return replaceOuter($from, $to, slice, 0);
      }

      function replaceOuter($from, $to, slice, depth) {
        var index = $from.index(depth),
            node = $from.node(depth);
        if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
          var inner = replaceOuter($from, $to, slice, depth + 1);
          return node.copy(node.content.replaceChild(index, inner));
        } else if (!slice.content.size) {
          return close(node, replaceTwoWay($from, $to, depth));
        } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
          // Simple, flat case
          var parent = $from.parent,
              content = parent.content;
          return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
        } else {
          var ref = prepareSliceForReplace(slice, $from);
          var start = ref.start;
          var end = ref.end;
          return close(node, replaceThreeWay($from, start, end, $to, depth));
        }
      }

      function checkJoin(main, sub) {
        if (!sub.type.compatibleContent(main.type)) {
          throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
        }
      }

      function joinable($before, $after, depth) {
        var node = $before.node(depth);
        checkJoin(node, $after.node(depth));
        return node;
      }

      function addNode(child, target) {
        var last = target.length - 1;
        if (last >= 0 && child.isText && child.sameMarkup(target[last])) {
          target[last] = child.withText(target[last].text + child.text);
        } else {
          target.push(child);
        }
      }

      function addRange($start, $end, depth, target) {
        var node = ($end || $start).node(depth);
        var startIndex = 0,
            endIndex = $end ? $end.index(depth) : node.childCount;
        if ($start) {
          startIndex = $start.index(depth);
          if ($start.depth > depth) {
            startIndex++;
          } else if ($start.textOffset) {
            addNode($start.nodeAfter, target);
            startIndex++;
          }
        }
        for (var i = startIndex; i < endIndex; i++) {
          addNode(node.child(i), target);
        }
        if ($end && $end.depth == depth && $end.textOffset) {
          addNode($end.nodeBefore, target);
        }
      }

      function close(node, content) {
        if (!node.type.validContent(content)) {
          throw new ReplaceError("Invalid content for node " + node.type.name);
        }
        return node.copy(content);
      }

      function replaceThreeWay($from, $start, $end, $to, depth) {
        var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
        var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);

        var content = [];
        addRange(null, $from, depth, content);
        if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
          checkJoin(openStart, openEnd);
          addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
        } else {
          if (openStart) {
            addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
          }
          addRange($start, $end, depth, content);
          if (openEnd) {
            addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
          }
        }
        addRange($to, null, depth, content);
        return new Fragment(content);
      }

      function replaceTwoWay($from, $to, depth) {
        var content = [];
        addRange(null, $from, depth, content);
        if ($from.depth > depth) {
          var type = joinable($from, $to, depth + 1);
          addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
        }
        addRange($to, null, depth, content);
        return new Fragment(content);
      }

      function prepareSliceForReplace(slice, $along) {
        var extra = $along.depth - slice.openStart,
            parent = $along.node(extra);
        var node = parent.copy(slice.content);
        for (var i = extra - 1; i >= 0; i--) {
          node = $along.node(i).copy(Fragment.from(node));
        }
        return { start: node.resolveNoCache(slice.openStart + extra),
          end: node.resolveNoCache(node.content.size - slice.openEnd - extra) };
      }

      // ::- You can [_resolve_](#model.Node.resolve) a position to get more
      // information about it. Objects of this class represent such a
      // resolved position, providing various pieces of context information,
      // and some helper methods.
      //
      // Throughout this interface, methods that take an optional `depth`
      // parameter will interpret undefined as `this.depth` and negative
      // numbers as `this.depth + value`.
      var ResolvedPos = function ResolvedPos(pos, path, parentOffset) {
        // :: number The position that was resolved.
        this.pos = pos;
        this.path = path;
        // :: number
        // The number of levels the parent node is from the root. If this
        // position points directly into the root node, it is 0. If it
        // points into a top-level paragraph, 1, and so on.
        this.depth = path.length / 3 - 1;
        // :: number The offset this position has into its parent node.
        this.parentOffset = parentOffset;
      };

      var prototypeAccessors$3 = { parent: {}, doc: {}, textOffset: {}, nodeAfter: {}, nodeBefore: {} };

      ResolvedPos.prototype.resolveDepth = function resolveDepth(val) {
        if (val == null) {
          return this.depth;
        }
        if (val < 0) {
          return this.depth + val;
        }
        return val;
      };

      // :: Node
      // The parent node that the position points into. Note that even if
      // a position points into a text node, that node is not considered
      // the parent—text nodes are ‘flat’ in this model, and have no content.
      prototypeAccessors$3.parent.get = function () {
        return this.node(this.depth);
      };

      // :: Node
      // The root node in which the position was resolved.
      prototypeAccessors$3.doc.get = function () {
        return this.node(0);
      };

      // :: (?number) → Node
      // The ancestor node at the given level. `p.node(p.depth)` is the
      // same as `p.parent`.
      ResolvedPos.prototype.node = function node(depth) {
        return this.path[this.resolveDepth(depth) * 3];
      };

      // :: (?number) → number
      // The index into the ancestor at the given level. If this points at
      // the 3rd node in the 2nd paragraph on the top level, for example,
      // `p.index(0)` is 2 and `p.index(1)` is 3.
      ResolvedPos.prototype.index = function index(depth) {
        return this.path[this.resolveDepth(depth) * 3 + 1];
      };

      // :: (?number) → number
      // The index pointing after this position into the ancestor at the
      // given level.
      ResolvedPos.prototype.indexAfter = function indexAfter(depth) {
        depth = this.resolveDepth(depth);
        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
      };

      // :: (?number) → number
      // The (absolute) position at the start of the node at the given
      // level.
      ResolvedPos.prototype.start = function start(depth) {
        depth = this.resolveDepth(depth);
        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      };

      // :: (?number) → number
      // The (absolute) position at the end of the node at the given
      // level.
      ResolvedPos.prototype.end = function end(depth) {
        depth = this.resolveDepth(depth);
        return this.start(depth) + this.node(depth).content.size;
      };

      // :: (?number) → number
      // The (absolute) position directly before the wrapping node at the
      // given level, or, when `level` is `this.depth + 1`, the original
      // position.
      ResolvedPos.prototype.before = function before(depth) {
        depth = this.resolveDepth(depth);
        if (!depth) {
          throw new RangeError("There is no position before the top-level node");
        }
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
      };

      // :: (?number) → number
      // The (absolute) position directly after the wrapping node at the
      // given level, or the original position when `level` is `this.depth + 1`.
      ResolvedPos.prototype.after = function after(depth) {
        depth = this.resolveDepth(depth);
        if (!depth) {
          throw new RangeError("There is no position after the top-level node");
        }
        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
      };

      // :: number
      // When this position points into a text node, this returns the
      // distance between the position and the start of the text node.
      // Will be zero for positions that point between nodes.
      prototypeAccessors$3.textOffset.get = function () {
        return this.pos - this.path[this.path.length - 1];
      };

      // :: ?Node
      // Get the node directly after the position, if any. If the position
      // points into a text node, only the part of that node after the
      // position is returned.
      prototypeAccessors$3.nodeAfter.get = function () {
        var parent = this.parent,
            index = this.index(this.depth);
        if (index == parent.childCount) {
          return null;
        }
        var dOff = this.pos - this.path[this.path.length - 1],
            child = parent.child(index);
        return dOff ? parent.child(index).cut(dOff) : child;
      };

      // :: ?Node
      // Get the node directly before the position, if any. If the
      // position points into a text node, only the part of that node
      // before the position is returned.
      prototypeAccessors$3.nodeBefore.get = function () {
        var index = this.index(this.depth);
        var dOff = this.pos - this.path[this.path.length - 1];
        if (dOff) {
          return this.parent.child(index).cut(0, dOff);
        }
        return index == 0 ? null : this.parent.child(index - 1);
      };

      // :: () → [Mark]
      // Get the marks at this position, factoring in the surrounding
      // marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the
      // position is at the start of a non-empty node, the marks of the
      // node after it (if any) are returned.
      ResolvedPos.prototype.marks = function marks() {
        var parent = this.parent,
            index = this.index();

        // In an empty parent, return the empty array
        if (parent.content.size == 0) {
          return Mark.none;
        }

        // When inside a text node, just return the text node's marks
        if (this.textOffset) {
          return parent.child(index).marks;
        }

        var main = parent.maybeChild(index - 1),
            other = parent.maybeChild(index);
        // If the `after` flag is true of there is no node before, make
        // the node after this position the main reference.
        if (!main) {
          var tmp = main;main = other;other = tmp;
        }

        // Use all marks in the main node, except those that have
        // `inclusive` set to false and are not present in the other node.
        var marks = main.marks;
        for (var i = 0; i < marks.length; i++) {
          if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) {
            marks = marks[i--].removeFromSet(marks);
          }
        }

        return marks;
      };

      // :: (ResolvedPos) → ?[Mark]
      // Get the marks after the current position, if any, except those
      // that are non-inclusive and not present at position `$end`. This
      // is mostly useful for getting the set of marks to preserve after a
      // deletion. Will return `null` if this position is at the end of
      // its parent node or its parent node isn't a textblock (in which
      // case no marks should be preserved).
      ResolvedPos.prototype.marksAcross = function marksAcross($end) {
        var after = this.parent.maybeChild(this.index());
        if (!after || !after.isInline) {
          return null;
        }

        var marks = after.marks,
            next = $end.parent.maybeChild($end.index());
        for (var i = 0; i < marks.length; i++) {
          if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) {
            marks = marks[i--].removeFromSet(marks);
          }
        }
        return marks;
      };

      // :: (number) → number
      // The depth up to which this position and the given (non-resolved)
      // position share the same parent nodes.
      ResolvedPos.prototype.sharedDepth = function sharedDepth(pos) {
        var this$1 = this;

        for (var depth = this.depth; depth > 0; depth--) {
          if (this$1.start(depth) <= pos && this$1.end(depth) >= pos) {
            return depth;
          }
        }
        return 0;
      };

      // :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange
      // Returns a range based on the place where this position and the
      // given position diverge around block content. If both point into
      // the same textblock, for example, a range around that textblock
      // will be returned. If they point into different blocks, the range
      // around those blocks in their shared ancestor is returned. You can
      // pass in an optional predicate that will be called with a parent
      // node to see if a range into that parent is acceptable.
      ResolvedPos.prototype.blockRange = function blockRange(other, pred) {
        var this$1 = this;
        if (other === void 0) other = this;

        if (other.pos < this.pos) {
          return other.blockRange(this);
        }
        for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
          if (other.pos <= this$1.end(d) && (!pred || pred(this$1.node(d)))) {
            return new NodeRange(this$1, other, d);
          }
        }
      };

      // :: (ResolvedPos) → bool
      // Query whether the given position shares the same parent node.
      ResolvedPos.prototype.sameParent = function sameParent(other) {
        return this.pos - this.parentOffset == other.pos - other.parentOffset;
      };

      // :: (ResolvedPos) → ResolvedPos
      // Return the greater of this and the given position.
      ResolvedPos.prototype.max = function max(other) {
        return other.pos > this.pos ? other : this;
      };

      // :: (ResolvedPos) → ResolvedPos
      // Return the smaller of this and the given position.
      ResolvedPos.prototype.min = function min(other) {
        return other.pos < this.pos ? other : this;
      };

      ResolvedPos.prototype.toString = function toString() {
        var this$1 = this;

        var str = "";
        for (var i = 1; i <= this.depth; i++) {
          str += (str ? "/" : "") + this$1.node(i).type.name + "_" + this$1.index(i - 1);
        }
        return str + ":" + this.parentOffset;
      };

      ResolvedPos.resolve = function resolve(doc, pos) {
        if (!(pos >= 0 && pos <= doc.content.size)) {
          throw new RangeError("Position " + pos + " out of range");
        }
        var path = [];
        var start = 0,
            parentOffset = pos;
        for (var node = doc;;) {
          var ref = node.content.findIndex(parentOffset);
          var index = ref.index;
          var offset = ref.offset;
          var rem = parentOffset - offset;
          path.push(node, index, start + offset);
          if (!rem) {
            break;
          }
          node = node.child(index);
          if (node.isText) {
            break;
          }
          parentOffset = rem - 1;
          start += offset + 1;
        }
        return new ResolvedPos(pos, path, parentOffset);
      };

      ResolvedPos.resolveCached = function resolveCached(doc, pos) {
        for (var i = 0; i < resolveCache.length; i++) {
          var cached = resolveCache[i];
          if (cached.pos == pos && cached.doc == doc) {
            return cached;
          }
        }
        var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);
        resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
        return result;
      };

      Object.defineProperties(ResolvedPos.prototype, prototypeAccessors$3);

      var resolveCache = [];
      var resolveCachePos = 0;
      var resolveCacheSize = 12;

      // ::- Represents a flat range of content, i.e. one that starts and
      // ends in the same node.
      var NodeRange = function NodeRange($from, $to, depth) {
        // :: ResolvedPos A resolved position along the start of the
        // content. May have a `depth` greater than this object's `depth`
        // property, since these are the positions that were used to
        // compute the range, not re-resolved positions directly at its
        // boundaries.
        this.$from = $from;
        // :: ResolvedPos A position along the end of the content. See
        // caveat for [`$from`](#model.NodeRange.$from).
        this.$to = $to;
        // :: number The depth of the node that this range points into.
        this.depth = depth;
      };

      var prototypeAccessors$1$1 = { start: {}, end: {}, parent: {}, startIndex: {}, endIndex: {} };

      // :: number The position at the start of the range.
      prototypeAccessors$1$1.start.get = function () {
        return this.$from.before(this.depth + 1);
      };
      // :: number The position at the end of the range.
      prototypeAccessors$1$1.end.get = function () {
        return this.$to.after(this.depth + 1);
      };

      // :: Node The parent node that the range points into.
      prototypeAccessors$1$1.parent.get = function () {
        return this.$from.node(this.depth);
      };
      // :: number The start index of the range in the parent node.
      prototypeAccessors$1$1.startIndex.get = function () {
        return this.$from.index(this.depth);
      };
      // :: number The end index of the range in the parent node.
      prototypeAccessors$1$1.endIndex.get = function () {
        return this.$to.indexAfter(this.depth);
      };

      Object.defineProperties(NodeRange.prototype, prototypeAccessors$1$1);

      var emptyAttrs = Object.create(null);

      // ::- This class represents a node in the tree that makes up a
      // ProseMirror document. So a document is an instance of `Node`, with
      // children that are also instances of `Node`.
      //
      // Nodes are persistent data structures. Instead of changing them, you
      // create new ones with the content you want. Old ones keep pointing
      // at the old document shape. This is made cheaper by sharing
      // structure between the old and new data as much as possible, which a
      // tree shape like this (without back pointers) makes easy.
      //
      // **Do not** directly mutate the properties of a `Node` object. See
      // [the guide](/docs/guide/#doc) for more information.
      var Node = function Node(type, attrs, content, marks) {
        // :: NodeType
        // The type of node that this is.
        this.type = type;

        // :: Object
        // An object mapping attribute names to values. The kind of
        // attributes allowed and required are
        // [determined](#model.NodeSpec.attrs) by the node type.
        this.attrs = attrs;

        // :: Fragment
        // A container holding the node's children.
        this.content = content || Fragment.empty;

        // :: [Mark]
        // The marks (things like whether it is emphasized or part of a
        // link) applied to this node.
        this.marks = marks || Mark.none;
      };

      var prototypeAccessors = { nodeSize: {}, childCount: {}, textContent: {}, firstChild: {}, lastChild: {}, isBlock: {}, isTextblock: {}, inlineContent: {}, isInline: {}, isText: {}, isLeaf: {}, isAtom: {} };

      // text:: ?string
      // For text nodes, this contains the node's text content.

      // :: number
      // The size of this node, as defined by the integer-based [indexing
      // scheme](/docs/guide/#doc.indexing). For text nodes, this is the
      // amount of characters. For other leaf nodes, it is one. For
      // non-leaf nodes, it is the size of the content plus two (the start
      // and end token).
      prototypeAccessors.nodeSize.get = function () {
        return this.isLeaf ? 1 : 2 + this.content.size;
      };

      // :: number
      // The number of children that the node has.
      prototypeAccessors.childCount.get = function () {
        return this.content.childCount;
      };

      // :: (number) → Node
      // Get the child node at the given index. Raises an error when the
      // index is out of range.
      Node.prototype.child = function child(index) {
        return this.content.child(index);
      };

      // :: (number) → ?Node
      // Get the child node at the given index, if it exists.
      Node.prototype.maybeChild = function maybeChild(index) {
        return this.content.maybeChild(index);
      };

      // :: ((node: Node, offset: number, index: number))
      // Call `f` for every child node, passing the node, its offset
      // into this parent node, and its index.
      Node.prototype.forEach = function forEach(f) {
        this.content.forEach(f);
      };

      // :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)
      // Invoke a callback for all descendant nodes recursively between
      // the given two positions that are relative to start of this node's
      // content. The callback is invoked with the node, its
      // parent-relative position, its parent node, and its child index.
      // When the callback returns false for a given node, that node's
      // children will not be recursed over. The last parameter can be
      // used to specify a starting position to count from.
      Node.prototype.nodesBetween = function nodesBetween(from, to, f, startPos) {
        if (startPos === void 0) startPos = 0;

        this.content.nodesBetween(from, to, f, startPos, this);
      };

      // :: ((node: Node, pos: number, parent: Node) → ?bool)
      // Call the given callback for every descendant node. Doesn't
      // descend into a node when the callback returns `false`.
      Node.prototype.descendants = function descendants(f) {
        this.nodesBetween(0, this.content.size, f);
      };

      // :: string
      // Concatenates all the text nodes found in this fragment and its
      // children.
      prototypeAccessors.textContent.get = function () {
        return this.textBetween(0, this.content.size, "");
      };

      // :: (number, number, ?string, ?string) → string
      // Get all text between positions `from` and `to`. When
      // `blockSeparator` is given, it will be inserted whenever a new
      // block node is started. When `leafText` is given, it'll be
      // inserted for every non-text leaf node encountered.
      Node.prototype.textBetween = function textBetween(from, to, blockSeparator, leafText) {
        return this.content.textBetween(from, to, blockSeparator, leafText);
      };

      // :: ?Node
      // Returns this node's first child, or `null` if there are no
      // children.
      prototypeAccessors.firstChild.get = function () {
        return this.content.firstChild;
      };

      // :: ?Node
      // Returns this node's last child, or `null` if there are no
      // children.
      prototypeAccessors.lastChild.get = function () {
        return this.content.lastChild;
      };

      // :: (Node) → bool
      // Test whether two nodes represent the same piece of document.
      Node.prototype.eq = function eq(other) {
        return this == other || this.sameMarkup(other) && this.content.eq(other.content);
      };

      // :: (Node) → bool
      // Compare the markup (type, attributes, and marks) of this node to
      // those of another. Returns `true` if both have the same markup.
      Node.prototype.sameMarkup = function sameMarkup(other) {
        return this.hasMarkup(other.type, other.attrs, other.marks);
      };

      // :: (NodeType, ?Object, ?[Mark]) → bool
      // Check whether this node's markup correspond to the given type,
      // attributes, and marks.
      Node.prototype.hasMarkup = function hasMarkup(type, attrs, marks) {
        return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
      };

      // :: (?Fragment) → Node
      // Create a new node with the same markup as this node, containing
      // the given content (or empty, if no content is given).
      Node.prototype.copy = function copy(content) {
        if (content === void 0) content = null;

        if (content == this.content) {
          return this;
        }
        return new this.constructor(this.type, this.attrs, content, this.marks);
      };

      // :: ([Mark]) → Node
      // Create a copy of this node, with the given set of marks instead
      // of the node's own marks.
      Node.prototype.mark = function mark(marks) {
        return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks);
      };

      // :: (number, ?number) → Node
      // Create a copy of this node with only the content between the
      // given positions. If `to` is not given, it defaults to the end of
      // the node.
      Node.prototype.cut = function cut(from, to) {
        if (from == 0 && to == this.content.size) {
          return this;
        }
        return this.copy(this.content.cut(from, to));
      };

      // :: (number, ?number) → Slice
      // Cut out the part of the document between the given positions, and
      // return it as a `Slice` object.
      Node.prototype.slice = function slice(from, to, includeParents) {
        if (to === void 0) to = this.content.size;
        if (includeParents === void 0) includeParents = false;

        if (from == to) {
          return Slice.empty;
        }

        var $from = this.resolve(from),
            $to = this.resolve(to);
        var depth = includeParents ? 0 : $from.sharedDepth(to);
        var start = $from.start(depth),
            node = $from.node(depth);
        var content = node.content.cut($from.pos - start, $to.pos - start);
        return new Slice(content, $from.depth - depth, $to.depth - depth);
      };

      // :: (number, number, Slice) → Node
      // Replace the part of the document between the given positions with
      // the given slice. The slice must 'fit', meaning its open sides
      // must be able to connect to the surrounding content, and its
      // content nodes must be valid children for the node they are placed
      // into. If any of this is violated, an error of type
      // [`ReplaceError`](#model.ReplaceError) is thrown.
      Node.prototype.replace = function replace$1(from, to, slice) {
        return replace(this.resolve(from), this.resolve(to), slice);
      };

      // :: (number) → ?Node
      // Find the node directly after the given position.
      Node.prototype.nodeAt = function nodeAt(pos) {
        for (var node = this;;) {
          var ref = node.content.findIndex(pos);
          var index = ref.index;
          var offset = ref.offset;
          node = node.maybeChild(index);
          if (!node) {
            return null;
          }
          if (offset == pos || node.isText) {
            return node;
          }
          pos -= offset + 1;
        }
      };

      // :: (number) → {node: ?Node, index: number, offset: number}
      // Find the (direct) child node after the given offset, if any,
      // and return it along with its index and offset relative to this
      // node.
      Node.prototype.childAfter = function childAfter(pos) {
        var ref = this.content.findIndex(pos);
        var index = ref.index;
        var offset = ref.offset;
        return { node: this.content.maybeChild(index), index: index, offset: offset };
      };

      // :: (number) → {node: ?Node, index: number, offset: number}
      // Find the (direct) child node before the given offset, if any,
      // and return it along with its index and offset relative to this
      // node.
      Node.prototype.childBefore = function childBefore(pos) {
        if (pos == 0) {
          return { node: null, index: 0, offset: 0 };
        }
        var ref = this.content.findIndex(pos);
        var index = ref.index;
        var offset = ref.offset;
        if (offset < pos) {
          return { node: this.content.child(index), index: index, offset: offset };
        }
        var node = this.content.child(index - 1);
        return { node: node, index: index - 1, offset: offset - node.nodeSize };
      };

      // :: (number) → ResolvedPos
      // Resolve the given position in the document, returning an
      // [object](#model.ResolvedPos) with information about its context.
      Node.prototype.resolve = function resolve(pos) {
        return ResolvedPos.resolveCached(this, pos);
      };

      Node.prototype.resolveNoCache = function resolveNoCache(pos) {
        return ResolvedPos.resolve(this, pos);
      };

      // :: (number, number, MarkType) → bool
      // Test whether a mark of the given type occurs in this document
      // between the two given positions.
      Node.prototype.rangeHasMark = function rangeHasMark(from, to, type) {
        var found = false;
        if (to > from) {
          this.nodesBetween(from, to, function (node) {
            if (type.isInSet(node.marks)) {
              found = true;
            }
            return !found;
          });
        }
        return found;
      };

      // :: bool
      // True when this is a block (non-inline node)
      prototypeAccessors.isBlock.get = function () {
        return this.type.isBlock;
      };

      // :: bool
      // True when this is a textblock node, a block node with inline
      // content.
      prototypeAccessors.isTextblock.get = function () {
        return this.type.isTextblock;
      };

      // :: bool
      // True when this node allows inline content.
      prototypeAccessors.inlineContent.get = function () {
        return this.type.inlineContent;
      };

      // :: bool
      // True when this is an inline node (a text node or a node that can
      // appear among text).
      prototypeAccessors.isInline.get = function () {
        return this.type.isInline;
      };

      // :: bool
      // True when this is a text node.
      prototypeAccessors.isText.get = function () {
        return this.type.isText;
      };

      // :: bool
      // True when this is a leaf node.
      prototypeAccessors.isLeaf.get = function () {
        return this.type.isLeaf;
      };

      // :: bool
      // True when this is an atom, i.e. when it does not have directly
      // editable content. This is usually the same as `isLeaf`, but can
      // be configured with the [`atom` property](#model.NodeSpec.atom) on
      // a node's spec (typically used when the node is displayed as an
      // uneditable [node view](#view.NodeView)).
      prototypeAccessors.isAtom.get = function () {
        return this.type.isAtom;
      };

      // :: () → string
      // Return a string representation of this node for debugging
      // purposes.
      Node.prototype.toString = function toString() {
        if (this.type.spec.toDebugString) {
          return this.type.spec.toDebugString(this);
        }
        var name = this.type.name;
        if (this.content.size) {
          name += "(" + this.content.toStringInner() + ")";
        }
        return wrapMarks(this.marks, name);
      };

      // :: (number) → ContentMatch
      // Get the content match in this node at the given index.
      Node.prototype.contentMatchAt = function contentMatchAt(index) {
        var match = this.type.contentMatch.matchFragment(this.content, 0, index);
        if (!match) {
          throw new Error("Called contentMatchAt on a node with invalid content");
        }
        return match;
      };

      // :: (number, number, ?Fragment, ?number, ?number) → bool
      // Test whether replacing the range between `from` and `to` (by
      // child index) with the given replacement fragment (which defaults
      // to the empty fragment) would leave the node's content valid. You
      // can optionally pass `start` and `end` indices into the
      // replacement fragment.
      Node.prototype.canReplace = function canReplace(from, to, replacement, start, end) {
        var this$1 = this;
        if (replacement === void 0) replacement = Fragment.empty;
        if (start === void 0) start = 0;
        if (end === void 0) end = replacement.childCount;

        var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
        var two = one && one.matchFragment(this.content, to);
        if (!two || !two.validEnd) {
          return false;
        }
        for (var i = start; i < end; i++) {
          if (!this$1.type.allowsMarks(replacement.child(i).marks)) {
            return false;
          }
        }
        return true;
      };

      // :: (number, number, NodeType, ?[Mark]) → bool
      // Test whether replacing the range `from` to `to` (by index) with a
      // node of the given type would leave the node's content valid.
      Node.prototype.canReplaceWith = function canReplaceWith(from, to, type, marks) {
        if (marks && !this.type.allowsMarks(marks)) {
          return false;
        }
        var start = this.contentMatchAt(from).matchType(type);
        var end = start && start.matchFragment(this.content, to);
        return end ? end.validEnd : false;
      };

      // :: (Node) → bool
      // Test whether the given node's content could be appended to this
      // node. If that node is empty, this will only return true if there
      // is at least one node type that can appear in both nodes (to avoid
      // merging completely incompatible nodes).
      Node.prototype.canAppend = function canAppend(other) {
        if (other.content.size) {
          return this.canReplace(this.childCount, this.childCount, other.content);
        } else {
          return this.type.compatibleContent(other.type);
        }
      };

      // Unused. Left for backwards compatibility.
      Node.prototype.defaultContentType = function defaultContentType(at) {
        return this.contentMatchAt(at).defaultType;
      };

      // :: ()
      // Check whether this node and its descendants conform to the
      // schema, and raise error when they do not.
      Node.prototype.check = function check() {
        if (!this.type.validContent(this.content)) {
          throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
        }
        this.content.forEach(function (node) {
          return node.check();
        });
      };

      // :: () → Object
      // Return a JSON-serializeable representation of this node.
      Node.prototype.toJSON = function toJSON() {
        var this$1 = this;

        var obj = { type: this.type.name };
        for (var _ in this$1.attrs) {
          obj.attrs = this$1.attrs;
          break;
        }
        if (this.content.size) {
          obj.content = this.content.toJSON();
        }
        if (this.marks.length) {
          obj.marks = this.marks.map(function (n) {
            return n.toJSON();
          });
        }
        return obj;
      };

      // :: (Schema, Object) → Node
      // Deserialize a node from its JSON representation.
      Node.fromJSON = function fromJSON(schema, json) {
        if (!json) {
          throw new RangeError("Invalid input for Node.fromJSON");
        }
        var marks = null;
        if (json.marks) {
          if (!Array.isArray(json.marks)) {
            throw new RangeError("Invalid mark data for Node.fromJSON");
          }
          marks = json.marks.map(schema.markFromJSON);
        }
        if (json.type == "text") {
          if (typeof json.text != "string") {
            throw new RangeError("Invalid text node in JSON");
          }
          return schema.text(json.text, marks);
        }
        var content = Fragment.fromJSON(schema, json.content);
        return schema.nodeType(json.type).create(json.attrs, content, marks);
      };

      Object.defineProperties(Node.prototype, prototypeAccessors);

      var TextNode = function (Node) {
        function TextNode(type, attrs, content, marks) {
          Node.call(this, type, attrs, null, marks);

          if (!content) {
            throw new RangeError("Empty text nodes are not allowed");
          }

          this.text = content;
        }

        if (Node) TextNode.__proto__ = Node;
        TextNode.prototype = Object.create(Node && Node.prototype);
        TextNode.prototype.constructor = TextNode;

        var prototypeAccessors$1 = { textContent: {}, nodeSize: {} };

        TextNode.prototype.toString = function toString() {
          if (this.type.spec.toDebugString) {
            return this.type.spec.toDebugString(this);
          }
          return wrapMarks(this.marks, JSON.stringify(this.text));
        };

        prototypeAccessors$1.textContent.get = function () {
          return this.text;
        };

        TextNode.prototype.textBetween = function textBetween(from, to) {
          return this.text.slice(from, to);
        };

        prototypeAccessors$1.nodeSize.get = function () {
          return this.text.length;
        };

        TextNode.prototype.mark = function mark(marks) {
          return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
        };

        TextNode.prototype.withText = function withText(text) {
          if (text == this.text) {
            return this;
          }
          return new TextNode(this.type, this.attrs, text, this.marks);
        };

        TextNode.prototype.cut = function cut(from, to) {
          if (from === void 0) from = 0;
          if (to === void 0) to = this.text.length;

          if (from == 0 && to == this.text.length) {
            return this;
          }
          return this.withText(this.text.slice(from, to));
        };

        TextNode.prototype.eq = function eq(other) {
          return this.sameMarkup(other) && this.text == other.text;
        };

        TextNode.prototype.toJSON = function toJSON() {
          var base = Node.prototype.toJSON.call(this);
          base.text = this.text;
          return base;
        };

        Object.defineProperties(TextNode.prototype, prototypeAccessors$1);

        return TextNode;
      }(Node);

      function wrapMarks(marks, str) {
        for (var i = marks.length - 1; i >= 0; i--) {
          str = marks[i].type.name + "(" + str + ")";
        }
        return str;
      }

      // ::- Instances of this class represent a match state of a node
      // type's [content expression](#model.NodeSpec.content), and can be
      // used to find out whether further content matches here, and whether
      // a given position is a valid end of the node.
      var ContentMatch = function ContentMatch(validEnd) {
        // :: bool
        // True when this match state represents a valid end of the node.
        this.validEnd = validEnd;
        this.next = [];
        this.wrapCache = [];
      };

      var prototypeAccessors$5 = { inlineContent: {}, defaultType: {}, edgeCount: {} };

      ContentMatch.parse = function parse(string, nodeTypes) {
        var stream = new TokenStream(string, nodeTypes);
        if (stream.next == null) {
          return ContentMatch.empty;
        }
        var expr = parseExpr(stream);
        if (stream.next) {
          stream.err("Unexpected trailing text");
        }
        var match = dfa(nfa(expr));
        checkForDeadEnds(match, stream);
        return match;
      };

      // :: (NodeType) → ?ContentMatch
      // Match a node type, returning a match after that node if
      // successful.
      ContentMatch.prototype.matchType = function matchType(type) {
        var this$1 = this;

        for (var i = 0; i < this.next.length; i += 2) {
          if (this$1.next[i] == type) {
            return this$1.next[i + 1];
          }
        }
        return null;
      };

      // :: (Fragment, ?number, ?number) → ?ContentMatch
      // Try to match a fragment. Returns the resulting match when
      // successful.
      ContentMatch.prototype.matchFragment = function matchFragment(frag, start, end) {
        if (start === void 0) start = 0;
        if (end === void 0) end = frag.childCount;

        var cur = this;
        for (var i = start; cur && i < end; i++) {
          cur = cur.matchType(frag.child(i).type);
        }
        return cur;
      };

      prototypeAccessors$5.inlineContent.get = function () {
        var first = this.next[0];
        return first ? first.isInline : false;
      };

      // :: ?NodeType
      // Get the first matching node type at this match position that can
      // be generated.
      prototypeAccessors$5.defaultType.get = function () {
        var this$1 = this;

        for (var i = 0; i < this.next.length; i += 2) {
          var type = this$1.next[i];
          if (!(type.isText || type.hasRequiredAttrs())) {
            return type;
          }
        }
      };

      ContentMatch.prototype.compatible = function compatible(other) {
        var this$1 = this;

        for (var i = 0; i < this.next.length; i += 2) {
          for (var j = 0; j < other.next.length; j += 2) {
            if (this$1.next[i] == other.next[j]) {
              return true;
            }
          }
        }
        return false;
      };

      // :: (Fragment, bool, ?number) → ?Fragment
      // Try to match the given fragment, and if that fails, see if it can
      // be made to match by inserting nodes in front of it. When
      // successful, return a fragment of inserted nodes (which may be
      // empty if nothing had to be inserted). When `toEnd` is true, only
      // return a fragment if the resulting match goes to the end of the
      // content expression.
      ContentMatch.prototype.fillBefore = function fillBefore(after, toEnd, startIndex) {
        if (toEnd === void 0) toEnd = false;
        if (startIndex === void 0) startIndex = 0;

        var seen = [this];
        function search(match, types) {
          var finished = match.matchFragment(after, startIndex);
          if (finished && (!toEnd || finished.validEnd)) {
            return Fragment.from(types.map(function (tp) {
              return tp.createAndFill();
            }));
          }

          for (var i = 0; i < match.next.length; i += 2) {
            var type = match.next[i],
                next = match.next[i + 1];
            if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
              seen.push(next);
              var found = search(next, types.concat(type));
              if (found) {
                return found;
              }
            }
          }
        }

        return search(this, []);
      };

      // :: (NodeType) → ?[NodeType]
      // Find a set of wrapping node types that would allow a node of the
      // given type to appear at this position. The result may be empty
      // (when it fits directly) and will be null when no such wrapping
      // exists.
      ContentMatch.prototype.findWrapping = function findWrapping(target) {
        var this$1 = this;

        for (var i = 0; i < this.wrapCache.length; i += 2) {
          if (this$1.wrapCache[i] == target) {
            return this$1.wrapCache[i + 1];
          }
        }
        var computed = this.computeWrapping(target);
        this.wrapCache.push(target, computed);
        return computed;
      };

      ContentMatch.prototype.computeWrapping = function computeWrapping(target) {
        var seen = Object.create(null),
            active = [{ match: this, type: null, via: null }];
        while (active.length) {
          var current = active.shift(),
              match = current.match;
          if (match.matchType(target)) {
            var result = [];
            for (var obj = current; obj.type; obj = obj.via) {
              result.push(obj.type);
            }
            return result.reverse();
          }
          for (var i = 0; i < match.next.length; i += 2) {
            var type = match.next[i];
            if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
              active.push({ match: type.contentMatch, type: type, via: current });
              seen[type.name] = true;
            }
          }
        }
      };

      // :: number
      // The number of outgoing edges this node has in the finite
      // automaton that describes the content expression.
      prototypeAccessors$5.edgeCount.get = function () {
        return this.next.length >> 1;
      };

      // :: (number) → {type: NodeType, next: ContentMatch}
      // Get the _n_th outgoing edge from this node in the finite
      // automaton that describes the content expression.
      ContentMatch.prototype.edge = function edge(n) {
        var i = n << 1;
        if (i > this.next.length) {
          throw new RangeError("There's no " + n + "th edge in this content match");
        }
        return { type: this.next[i], next: this.next[i + 1] };
      };

      ContentMatch.prototype.toString = function toString() {
        var seen = [];
        function scan(m) {
          seen.push(m);
          for (var i = 1; i < m.next.length; i += 2) {
            if (seen.indexOf(m.next[i]) == -1) {
              scan(m.next[i]);
            }
          }
        }
        scan(this);
        return seen.map(function (m, i) {
          var out = i + (m.validEnd ? "*" : " ") + " ";
          for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {
            out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]);
          }
          return out;
        }).join("\n");
      };

      Object.defineProperties(ContentMatch.prototype, prototypeAccessors$5);

      ContentMatch.empty = new ContentMatch(true);

      var TokenStream = function TokenStream(string, nodeTypes) {
        this.string = string;
        this.nodeTypes = nodeTypes;
        this.inline = null;
        this.pos = 0;
        this.tokens = string.split(/\s*(?=\b|\W|$)/);
        if (this.tokens[this.tokens.length - 1] == "") {
          this.tokens.pop();
        }
        if (this.tokens[0] == "") {
          this.tokens.unshift();
        }
      };

      var prototypeAccessors$1$3 = { next: {} };

      prototypeAccessors$1$3.next.get = function () {
        return this.tokens[this.pos];
      };

      TokenStream.prototype.eat = function eat(tok) {
        return this.next == tok && (this.pos++ || true);
      };

      TokenStream.prototype.err = function err(str) {
        throw new SyntaxError(str + " (in content expression '" + this.string + "')");
      };

      Object.defineProperties(TokenStream.prototype, prototypeAccessors$1$3);

      function parseExpr(stream) {
        var exprs = [];
        do {
          exprs.push(parseExprSeq(stream));
        } while (stream.eat("|"));
        return exprs.length == 1 ? exprs[0] : { type: "choice", exprs: exprs };
      }

      function parseExprSeq(stream) {
        var exprs = [];
        do {
          exprs.push(parseExprSubscript(stream));
        } while (stream.next && stream.next != ")" && stream.next != "|");
        return exprs.length == 1 ? exprs[0] : { type: "seq", exprs: exprs };
      }

      function parseExprSubscript(stream) {
        var expr = parseExprAtom(stream);
        for (;;) {
          if (stream.eat("+")) {
            expr = { type: "plus", expr: expr };
          } else if (stream.eat("*")) {
            expr = { type: "star", expr: expr };
          } else if (stream.eat("?")) {
            expr = { type: "opt", expr: expr };
          } else if (stream.eat("{")) {
            expr = parseExprRange(stream, expr);
          } else {
            break;
          }
        }
        return expr;
      }

      function parseNum(stream) {
        if (/\D/.test(stream.next)) {
          stream.err("Expected number, got '" + stream.next + "'");
        }
        var result = Number(stream.next);
        stream.pos++;
        return result;
      }

      function parseExprRange(stream, expr) {
        var min = parseNum(stream),
            max = min;
        if (stream.eat(",")) {
          if (stream.next != "}") {
            max = parseNum(stream);
          } else {
            max = -1;
          }
        }
        if (!stream.eat("}")) {
          stream.err("Unclosed braced range");
        }
        return { type: "range", min: min, max: max, expr: expr };
      }

      function resolveName(stream, name) {
        var types = stream.nodeTypes,
            type = types[name];
        if (type) {
          return [type];
        }
        var result = [];
        for (var typeName in types) {
          var type$1 = types[typeName];
          if (type$1.groups.indexOf(name) > -1) {
            result.push(type$1);
          }
        }
        if (result.length == 0) {
          stream.err("No node type or group '" + name + "' found");
        }
        return result;
      }

      function parseExprAtom(stream) {
        if (stream.eat("(")) {
          var expr = parseExpr(stream);
          if (!stream.eat(")")) {
            stream.err("Missing closing paren");
          }
          return expr;
        } else if (!/\W/.test(stream.next)) {
          var exprs = resolveName(stream, stream.next).map(function (type) {
            if (stream.inline == null) {
              stream.inline = type.isInline;
            } else if (stream.inline != type.isInline) {
              stream.err("Mixing inline and block content");
            }
            return { type: "name", value: type };
          });
          stream.pos++;
          return exprs.length == 1 ? exprs[0] : { type: "choice", exprs: exprs };
        } else {
          stream.err("Unexpected token '" + stream.next + "'");
        }
      }

      // The code below helps compile a regular-expression-like language
      // into a deterministic finite automaton. For a good introduction to
      // these concepts, see https://swtch.com/~rsc/regexp/regexp1.html

      // : (Object) → [[{term: ?any, to: number}]]
      // Construct an NFA from an expression as returned by the parser. The
      // NFA is represented as an array of states, which are themselves
      // arrays of edges, which are `{term, to}` objects. The first state is
      // the entry state and the last node is the success state.
      //
      // Note that unlike typical NFAs, the edge ordering in this one is
      // significant, in that it is used to contruct filler content when
      // necessary.
      function nfa(expr) {
        var nfa = [[]];
        connect(compile(expr, 0), node());
        return nfa;

        function node() {
          return nfa.push([]) - 1;
        }
        function edge(from, to, term) {
          var edge = { term: term, to: to };
          nfa[from].push(edge);
          return edge;
        }
        function connect(edges, to) {
          edges.forEach(function (edge) {
            return edge.to = to;
          });
        }

        function compile(expr, from) {
          if (expr.type == "choice") {
            return expr.exprs.reduce(function (out, expr) {
              return out.concat(compile(expr, from));
            }, []);
          } else if (expr.type == "seq") {
            for (var i = 0;; i++) {
              var next = compile(expr.exprs[i], from);
              if (i == expr.exprs.length - 1) {
                return next;
              }
              connect(next, from = node());
            }
          } else if (expr.type == "star") {
            var loop = node();
            edge(from, loop);
            connect(compile(expr.expr, loop), loop);
            return [edge(loop)];
          } else if (expr.type == "plus") {
            var loop$1 = node();
            connect(compile(expr.expr, from), loop$1);
            connect(compile(expr.expr, loop$1), loop$1);
            return [edge(loop$1)];
          } else if (expr.type == "opt") {
            return [edge(from)].concat(compile(expr.expr, from));
          } else if (expr.type == "range") {
            var cur = from;
            for (var i$1 = 0; i$1 < expr.min; i$1++) {
              var next$1 = node();
              connect(compile(expr.expr, cur), next$1);
              cur = next$1;
            }
            if (expr.max == -1) {
              connect(compile(expr.expr, cur), cur);
            } else {
              for (var i$2 = expr.min; i$2 < expr.max; i$2++) {
                var next$2 = node();
                edge(cur, next$2);
                connect(compile(expr.expr, cur), next$2);
                cur = next$2;
              }
            }
            return [edge(cur)];
          } else if (expr.type == "name") {
            return [edge(from, null, expr.value)];
          }
        }
      }

      function cmp(a, b) {
        return a - b;
      }

      // Get the set of nodes reachable by null edges from `node`. Omit
      // nodes with only a single null-out-edge, since they may lead to
      // needless duplicated nodes.
      function nullFrom(nfa, node) {
        var result = [];
        scan(node);
        return result.sort(cmp);

        function scan(node) {
          var edges = nfa[node];
          if (edges.length == 1 && !edges[0].term) {
            return scan(edges[0].to);
          }
          result.push(node);
          for (var i = 0; i < edges.length; i++) {
            var ref = edges[i];
            var term = ref.term;
            var to = ref.to;
            if (!term && result.indexOf(to) == -1) {
              scan(to);
            }
          }
        }
      }

      // : ([[{term: ?any, to: number}]]) → ContentMatch
      // Compiles an NFA as produced by `nfa` into a DFA, modeled as a set
      // of state objects (`ContentMatch` instances) with transitions
      // between them.
      function dfa(nfa) {
        var labeled = Object.create(null);
        return explore(nullFrom(nfa, 0));

        function explore(states) {
          var out = [];
          states.forEach(function (node) {
            nfa[node].forEach(function (ref) {
              var term = ref.term;
              var to = ref.to;

              if (!term) {
                return;
              }
              var known = out.indexOf(term),
                  set = known > -1 && out[known + 1];
              nullFrom(nfa, to).forEach(function (node) {
                if (!set) {
                  out.push(term, set = []);
                }
                if (set.indexOf(node) == -1) {
                  set.push(node);
                }
              });
            });
          });
          var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);
          for (var i = 0; i < out.length; i += 2) {
            var states$1 = out[i + 1].sort(cmp);
            state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
          }
          return state;
        }
      }

      function checkForDeadEnds(match, stream) {
        for (var i = 0, work = [match]; i < work.length; i++) {
          var state = work[i],
              dead = !state.validEnd,
              nodes = [];
          for (var j = 0; j < state.next.length; j += 2) {
            var node = state.next[j],
                next = state.next[j + 1];
            nodes.push(node.name);
            if (dead && !(node.isText || node.hasRequiredAttrs())) {
              dead = false;
            }
            if (work.indexOf(next) == -1) {
              work.push(next);
            }
          }
          if (dead) {
            stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position");
          }
        }
      }

      // For node types where all attrs have a default value (or which don't
      // have any attributes), build up a single reusable default attribute
      // object, and use it for all nodes that don't specify specific
      // attributes.
      function defaultAttrs(attrs) {
        var defaults = Object.create(null);
        for (var attrName in attrs) {
          var attr = attrs[attrName];
          if (!attr.hasDefault) {
            return null;
          }
          defaults[attrName] = attr.default;
        }
        return defaults;
      }

      function computeAttrs(attrs, value) {
        var built = Object.create(null);
        for (var name in attrs) {
          var given = value && value[name];
          if (given === undefined) {
            var attr = attrs[name];
            if (attr.hasDefault) {
              given = attr.default;
            } else {
              throw new RangeError("No value supplied for attribute " + name);
            }
          }
          built[name] = given;
        }
        return built;
      }

      function initAttrs(attrs) {
        var result = Object.create(null);
        if (attrs) {
          for (var name in attrs) {
            result[name] = new Attribute(attrs[name]);
          }
        }
        return result;
      }

      // ::- Node types are objects allocated once per `Schema` and used to
      // [tag](#model.Node.type) `Node` instances. They contain information
      // about the node type, such as its name and what kind of node it
      // represents.
      var NodeType = function NodeType(name, schema, spec) {
        // :: string
        // The name the node type has in this schema.
        this.name = name;

        // :: Schema
        // A link back to the `Schema` the node type belongs to.
        this.schema = schema;

        // :: NodeSpec
        // The spec that this type is based on
        this.spec = spec;

        this.groups = spec.group ? spec.group.split(" ") : [];
        this.attrs = initAttrs(spec.attrs);

        this.defaultAttrs = defaultAttrs(this.attrs);

        // :: ContentMatch
        // The starting match of the node type's content expression.
        this.contentMatch = null;

        // : ?[MarkType]
        // The set of marks allowed in this node. `null` means all marks
        // are allowed.
        this.markSet = null;

        // :: bool
        // True if this node type has inline content.
        this.inlineContent = null;

        // :: bool
        // True if this is a block type
        this.isBlock = !(spec.inline || name == "text");

        // :: bool
        // True if this is the text node type.
        this.isText = name == "text";
      };

      var prototypeAccessors$4 = { isInline: {}, isTextblock: {}, isLeaf: {}, isAtom: {} };

      // :: bool
      // True if this is an inline type.
      prototypeAccessors$4.isInline.get = function () {
        return !this.isBlock;
      };

      // :: bool
      // True if this is a textblock type, a block that contains inline
      // content.
      prototypeAccessors$4.isTextblock.get = function () {
        return this.isBlock && this.inlineContent;
      };

      // :: bool
      // True for node types that allow no content.
      prototypeAccessors$4.isLeaf.get = function () {
        return this.contentMatch == ContentMatch.empty;
      };

      // :: bool
      // True when this node is an atom, i.e. when it does not have
      // directly editable content.
      prototypeAccessors$4.isAtom.get = function () {
        return this.isLeaf || this.spec.atom;
      };

      NodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs(ignore) {
        var this$1 = this;

        for (var n in this$1.attrs) {
          if (this$1.attrs[n].isRequired && (!ignore || !(n in ignore))) {
            return true;
          }
        }
        return false;
      };

      NodeType.prototype.compatibleContent = function compatibleContent(other) {
        return this == other || this.contentMatch.compatible(other.contentMatch);
      };

      NodeType.prototype.computeAttrs = function computeAttrs$1(attrs) {
        if (!attrs && this.defaultAttrs) {
          return this.defaultAttrs;
        } else {
          return computeAttrs(this.attrs, attrs);
        }
      };

      // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
      // Create a `Node` of this type. The given attributes are
      // checked and defaulted (you can pass `null` to use the type's
      // defaults entirely, if no required attributes exist). `content`
      // may be a `Fragment`, a node, an array of nodes, or
      // `null`. Similarly `marks` may be `null` to default to the empty
      // set of marks.
      NodeType.prototype.create = function create(attrs, content, marks) {
        if (this.isText) {
          throw new Error("NodeType.create can't construct text nodes");
        }
        return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
      };

      // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
      // Like [`create`](#model.NodeType.create), but check the given content
      // against the node type's content restrictions, and throw an error
      // if it doesn't match.
      NodeType.prototype.createChecked = function createChecked(attrs, content, marks) {
        content = Fragment.from(content);
        if (!this.validContent(content)) {
          throw new RangeError("Invalid content for node " + this.name);
        }
        return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
      };

      // :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node
      // Like [`create`](#model.NodeType.create), but see if it is necessary to
      // add nodes to the start or end of the given fragment to make it
      // fit the node. If no fitting wrapping can be found, return null.
      // Note that, due to the fact that required nodes can always be
      // created, this will always succeed if you pass null or
      // `Fragment.empty` as content.
      NodeType.prototype.createAndFill = function createAndFill(attrs, content, marks) {
        attrs = this.computeAttrs(attrs);
        content = Fragment.from(content);
        if (content.size) {
          var before = this.contentMatch.fillBefore(content);
          if (!before) {
            return null;
          }
          content = before.append(content);
        }
        var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);
        if (!after) {
          return null;
        }
        return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
      };

      // :: (Fragment) → bool
      // Returns true if the given fragment is valid content for this node
      // type with the given attributes.
      NodeType.prototype.validContent = function validContent(content) {
        var this$1 = this;

        var result = this.contentMatch.matchFragment(content);
        if (!result || !result.validEnd) {
          return false;
        }
        for (var i = 0; i < content.childCount; i++) {
          if (!this$1.allowsMarks(content.child(i).marks)) {
            return false;
          }
        }
        return true;
      };

      // :: (MarkType) → bool
      // Check whether the given mark type is allowed in this node.
      NodeType.prototype.allowsMarkType = function allowsMarkType(markType) {
        return this.markSet == null || this.markSet.indexOf(markType) > -1;
      };

      // :: ([Mark]) → bool
      // Test whether the given set of marks are allowed in this node.
      NodeType.prototype.allowsMarks = function allowsMarks(marks) {
        var this$1 = this;

        if (this.markSet == null) {
          return true;
        }
        for (var i = 0; i < marks.length; i++) {
          if (!this$1.allowsMarkType(marks[i].type)) {
            return false;
          }
        }
        return true;
      };

      // :: ([Mark]) → [Mark]
      // Removes the marks that are not allowed in this node from the given set.
      NodeType.prototype.allowedMarks = function allowedMarks(marks) {
        var this$1 = this;

        if (this.markSet == null) {
          return marks;
        }
        var copy;
        for (var i = 0; i < marks.length; i++) {
          if (!this$1.allowsMarkType(marks[i].type)) {
            if (!copy) {
              copy = marks.slice(0, i);
            }
          } else if (copy) {
            copy.push(marks[i]);
          }
        }
        return !copy ? marks : copy.length ? copy : Mark.empty;
      };

      NodeType.compile = function compile(nodes, schema) {
        var result = Object.create(null);
        nodes.forEach(function (name, spec) {
          return result[name] = new NodeType(name, schema, spec);
        });

        var topType = schema.spec.topNode || "doc";
        if (!result[topType]) {
          throw new RangeError("Schema is missing its top node type ('" + topType + "')");
        }
        if (!result.text) {
          throw new RangeError("Every schema needs a 'text' type");
        }
        for (var _ in result.text.attrs) {
          throw new RangeError("The text node type should not have attributes");
        }

        return result;
      };

      Object.defineProperties(NodeType.prototype, prototypeAccessors$4);

      // Attribute descriptors

      var Attribute = function Attribute(options) {
        this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
        this.default = options.default;
      };

      var prototypeAccessors$1$2 = { isRequired: {} };

      prototypeAccessors$1$2.isRequired.get = function () {
        return !this.hasDefault;
      };

      Object.defineProperties(Attribute.prototype, prototypeAccessors$1$2);

      // Marks

      // ::- Like nodes, marks (which are associated with nodes to signify
      // things like emphasis or being part of a link) are
      // [tagged](#model.Mark.type) with type objects, which are
      // instantiated once per `Schema`.
      var MarkType = function MarkType(name, rank, schema, spec) {
        // :: string
        // The name of the mark type.
        this.name = name;

        // :: Schema
        // The schema that this mark type instance is part of.
        this.schema = schema;

        // :: MarkSpec
        // The spec on which the type is based.
        this.spec = spec;

        this.attrs = initAttrs(spec.attrs);

        this.rank = rank;
        this.excluded = null;
        var defaults = defaultAttrs(this.attrs);
        this.instance = defaults && new Mark(this, defaults);
      };

      // :: (?Object) → Mark
      // Create a mark of this type. `attrs` may be `null` or an object
      // containing only some of the mark's attributes. The others, if
      // they have defaults, will be added.
      MarkType.prototype.create = function create(attrs) {
        if (!attrs && this.instance) {
          return this.instance;
        }
        return new Mark(this, computeAttrs(this.attrs, attrs));
      };

      MarkType.compile = function compile(marks, schema) {
        var result = Object.create(null),
            rank = 0;
        marks.forEach(function (name, spec) {
          return result[name] = new MarkType(name, rank++, schema, spec);
        });
        return result;
      };

      // :: ([Mark]) → [Mark]
      // When there is a mark of this type in the given set, a new set
      // without it is returned. Otherwise, the input set is returned.
      MarkType.prototype.removeFromSet = function removeFromSet(set) {
        var this$1 = this;

        for (var i = 0; i < set.length; i++) {
          if (set[i].type == this$1) {
            return set.slice(0, i).concat(set.slice(i + 1));
          }
        }
        return set;
      };

      // :: ([Mark]) → ?Mark
      // Tests whether there is a mark of this type in the given set.
      MarkType.prototype.isInSet = function isInSet(set) {
        var this$1 = this;

        for (var i = 0; i < set.length; i++) {
          if (set[i].type == this$1) {
            return set[i];
          }
        }
      };

      // :: (MarkType) → bool
      // Queries whether a given mark type is
      // [excluded](#model.MarkSpec.excludes) by this one.
      MarkType.prototype.excludes = function excludes(other) {
        return this.excluded.indexOf(other) > -1;
      };

      // SchemaSpec:: interface
      // An object describing a schema, as passed to the [`Schema`](#model.Schema)
      // constructor.
      //
      //   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>
      //   The node types in this schema. Maps names to
      //   [`NodeSpec`](#model.NodeSpec) objects that describe the node type
      //   associated with that name. Their order is significant—it
      //   determines which [parse rules](#model.NodeSpec.parseDOM) take
      //   precedence by default, and which nodes come first in a given
      //   [group](#model.NodeSpec.group).
      //
      //   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>
      //   The mark types that exist in this schema. The order in which they
      //   are provided determines the order in which [mark
      //   sets](#model.Mark.addToSet) are sorted and in which [parse
      //   rules](#model.MarkSpec.parseDOM) are tried.
      //
      //   topNode:: ?string
      //   The name of the default top-level node for the schema. Defaults
      //   to `"doc"`.

      // NodeSpec:: interface
      //
      //   content:: ?string
      //   The content expression for this node, as described in the [schema
      //   guide](/docs/guide/#schema.content_expressions). When not given,
      //   the node does not allow any content.
      //
      //   marks:: ?string
      //   The marks that are allowed inside of this node. May be a
      //   space-separated string referring to mark names or groups, `"_"`
      //   to explicitly allow all marks, or `""` to disallow marks. When
      //   not given, nodes with inline content default to allowing all
      //   marks, other nodes default to not allowing marks.
      //
      //   group:: ?string
      //   The group or space-separated groups to which this node belongs,
      //   which can be referred to in the content expressions for the
      //   schema.
      //
      //   inline:: ?bool
      //   Should be set to true for inline nodes. (Implied for text nodes.)
      //
      //   atom:: ?bool
      //   Can be set to true to indicate that, though this isn't a [leaf
      //   node](#model.NodeType.isLeaf), it doesn't have directly editable
      //   content and should be treated as a single unit in the view.
      //
      //   attrs:: ?Object<AttributeSpec>
      //   The attributes that nodes of this type get.
      //
      //   selectable:: ?bool
      //   Controls whether nodes of this type can be selected as a [node
      //   selection](#state.NodeSelection). Defaults to true for non-text
      //   nodes.
      //
      //   draggable:: ?bool
      //   Determines whether nodes of this type can be dragged without
      //   being selected. Defaults to false.
      //
      //   code:: ?bool
      //   Can be used to indicate that this node contains code, which
      //   causes some commands to behave differently.
      //
      //   defining:: ?bool
      //   Determines whether this node is considered an important parent
      //   node during replace operations (such as paste). Non-defining (the
      //   default) nodes get dropped when their entire content is replaced,
      //   whereas defining nodes persist and wrap the inserted content.
      //   Likewise, in _inserted_ content the defining parents of the
      //   content are preserved when possible. Typically,
      //   non-default-paragraph textblock types, and possibly list items,
      //   are marked as defining.
      //
      //   isolating:: ?bool
      //   When enabled (default is false), the sides of nodes of this type
      //   count as boundaries that regular editing operations, like
      //   backspacing or lifting, won't cross. An example of a node that
      //   should probably have this enabled is a table cell.
      //
      //   toDOM:: ?(node: Node) → DOMOutputSpec
      //   Defines the default way a node of this type should be serialized
      //   to DOM/HTML (as used by
      //   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).
      //   Should return a DOM node or an [array
      //   structure](#model.DOMOutputSpec) that describes one, with an
      //   optional number zero (“hole”) in it to indicate where the node's
      //   content should be inserted.
      //
      //   For text nodes, the default is to create a text DOM node. Though
      //   it is possible to create a serializer where text is rendered
      //   differently, this is not supported inside the editor, so you
      //   shouldn't override that in your text node spec.
      //
      //   parseDOM:: ?[ParseRule]
      //   Associates DOM parser information with this node, which can be
      //   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to
      //   automatically derive a parser. The `node` field in the rules is
      //   implied (the name of this node will be filled in automatically).
      //   If you supply your own parser, you do not need to also specify
      //   parsing rules in your schema.
      //
      //   toDebugString:: ?(node: Node) -> string
      //   Defines the default way a node of this type should be serialized
      //   to a string representation for debugging (e.g. in error messages).

      // MarkSpec:: interface
      //
      //   attrs:: ?Object<AttributeSpec>
      //   The attributes that marks of this type get.
      //
      //   inclusive:: ?bool
      //   Whether this mark should be active when the cursor is positioned
      //   at its end (or at its start when that is also the start of the
      //   parent node). Defaults to true.
      //
      //   excludes:: ?string
      //   Determines which other marks this mark can coexist with. Should
      //   be a space-separated strings naming other marks or groups of marks.
      //   When a mark is [added](#model.Mark.addToSet) to a set, all marks
      //   that it excludes are removed in the process. If the set contains
      //   any mark that excludes the new mark but is not, itself, excluded
      //   by the new mark, the mark can not be added an the set. You can
      //   use the value `"_"` to indicate that the mark excludes all
      //   marks in the schema.
      //
      //   Defaults to only being exclusive with marks of the same type. You
      //   can set it to an empty string (or any string not containing the
      //   mark's own name) to allow multiple marks of a given type to
      //   coexist (as long as they have different attributes).
      //
      //   group:: ?string
      //   The group or space-separated groups to which this mark belongs.
      //
      //   spanning:: ?bool
      //   Determines whether marks of this type can span multiple adjacent
      //   nodes when serialized to DOM/HTML. Defaults to true.
      //
      //   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec
      //   Defines the default way marks of this type should be serialized
      //   to DOM/HTML. When the resulting spec contains a hole, that is
      //   where the marked content is placed. Otherwise, it is appended to
      //   the top node.
      //
      //   parseDOM:: ?[ParseRule]
      //   Associates DOM parser information with this mark (see the
      //   corresponding [node spec field](#model.NodeSpec.parseDOM)). The
      //   `mark` field in the rules is implied.

      // AttributeSpec:: interface
      //
      // Used to [define](#model.NodeSpec.attrs) attributes on nodes or
      // marks.
      //
      //   default:: ?any
      //   The default value for this attribute, to use when no explicit
      //   value is provided. Attributes that have no default must be
      //   provided whenever a node or mark of a type that has them is
      //   created.

      // ::- A document schema. Holds [node](#model.NodeType) and [mark
      // type](#model.MarkType) objects for the nodes and marks that may
      // occur in conforming documents, and provides functionality for
      // creating and deserializing such documents.
      var Schema = function Schema(spec) {
        var this$1 = this;

        // :: SchemaSpec
        // The [spec](#model.SchemaSpec) on which the schema is based,
        // with the added guarantee that its `nodes` and `marks`
        // properties are
        // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances
        // (not raw objects).
        this.spec = {};
        for (var prop in spec) {
          this$1.spec[prop] = spec[prop];
        }
        this.spec.nodes = OrderedMap.from(spec.nodes);
        this.spec.marks = OrderedMap.from(spec.marks);

        // :: Object<NodeType>
        // An object mapping the schema's node names to node type objects.
        this.nodes = NodeType.compile(this.spec.nodes, this);

        // :: Object<MarkType>
        // A map from mark names to mark type objects.
        this.marks = MarkType.compile(this.spec.marks, this);

        var contentExprCache = Object.create(null);
        for (var prop$1 in this$1.nodes) {
          if (prop$1 in this$1.marks) {
            throw new RangeError(prop$1 + " can not be both a node and a mark");
          }
          var type = this$1.nodes[prop$1],
              contentExpr = type.spec.content || "",
              markExpr = type.spec.marks;
          type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this$1.nodes));
          type.inlineContent = type.contentMatch.inlineContent;
          type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this$1, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
        }
        for (var prop$2 in this$1.marks) {
          var type$1 = this$1.marks[prop$2],
              excl = type$1.spec.excludes;
          type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this$1, excl.split(" "));
        }

        this.nodeFromJSON = this.nodeFromJSON.bind(this);
        this.markFromJSON = this.markFromJSON.bind(this);

        // :: NodeType
        // The type of the [default top node](#model.SchemaSpec.topNode)
        // for this schema.
        this.topNodeType = this.nodes[this.spec.topNode || "doc"];

        // :: Object
        // An object for storing whatever values modules may want to
        // compute and cache per schema. (If you want to store something
        // in it, try to use property names unlikely to clash.)
        this.cached = Object.create(null);
        this.cached.wrappings = Object.create(null);
      };

      // :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
      // Create a node in this schema. The `type` may be a string or a
      // `NodeType` instance. Attributes will be extended
      // with defaults, `content` may be a `Fragment`,
      // `null`, a `Node`, or an array of nodes.
      Schema.prototype.node = function node(type, attrs, content, marks) {
        if (typeof type == "string") {
          type = this.nodeType(type);
        } else if (!(type instanceof NodeType)) {
          throw new RangeError("Invalid node type: " + type);
        } else if (type.schema != this) {
          throw new RangeError("Node type from different schema used (" + type.name + ")");
        }

        return type.createChecked(attrs, content, marks);
      };

      // :: (string, ?[Mark]) → Node
      // Create a text node in the schema. Empty text nodes are not
      // allowed.
      Schema.prototype.text = function text(text$1, marks) {
        var type = this.nodes.text;
        return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks));
      };

      // :: (union<string, MarkType>, ?Object) → Mark
      // Create a mark with the given type and attributes.
      Schema.prototype.mark = function mark(type, attrs) {
        if (typeof type == "string") {
          type = this.marks[type];
        }
        return type.create(attrs);
      };

      // :: (Object) → Node
      // Deserialize a node from its JSON representation. This method is
      // bound.
      Schema.prototype.nodeFromJSON = function nodeFromJSON(json) {
        return Node.fromJSON(this, json);
      };

      // :: (Object) → Mark
      // Deserialize a mark from its JSON representation. This method is
      // bound.
      Schema.prototype.markFromJSON = function markFromJSON(json) {
        return Mark.fromJSON(this, json);
      };

      Schema.prototype.nodeType = function nodeType(name) {
        var found = this.nodes[name];
        if (!found) {
          throw new RangeError("Unknown node type: " + name);
        }
        return found;
      };

      function gatherMarks(schema, marks) {
        var found = [];
        for (var i = 0; i < marks.length; i++) {
          var name = marks[i],
              mark = schema.marks[name],
              ok = mark;
          if (mark) {
            found.push(mark);
          } else {
            for (var prop in schema.marks) {
              var mark$1 = schema.marks[prop];
              if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
                found.push(ok = mark$1);
              }
            }
          }
          if (!ok) {
            throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
          }
        }
        return found;
      }

      // ParseOptions:: interface
      // These are the options recognized by the
      // [`parse`](#model.DOMParser.parse) and
      // [`parseSlice`](#model.DOMParser.parseSlice) methods.
      //
      //   preserveWhitespace:: ?union<bool, "full">
      //   By default, whitespace is collapsed as per HTML's rules. Pass
      //   `true` to preserve whitespace, but normalize newlines to
      //   spaces, and `"full"` to preserve whitespace entirely.
      //
      //   findPositions:: ?[{node: dom.Node, offset: number}]
      //   When given, the parser will, beside parsing the content,
      //   record the document positions of the given DOM positions. It
      //   will do so by writing to the objects, adding a `pos` property
      //   that holds the document position. DOM positions that are not
      //   in the parsed content will not be written to.
      //
      //   from:: ?number
      //   The child node index to start parsing from.
      //
      //   to:: ?number
      //   The child node index to stop parsing at.
      //
      //   topNode:: ?Node
      //   By default, the content is parsed into the schema's default
      //   [top node type](#model.Schema.topNodeType). You can pass this
      //   option to use the type and attributes from a different node
      //   as the top container.
      //
      //   topMatch:: ?ContentMatch
      //   Provide the starting content match that content parsed into the
      //   top node is matched against.
      //
      //   context:: ?ResolvedPos
      //   A set of additional nodes to count as
      //   [context](#model.ParseRule.context) when parsing, above the
      //   given [top node](#model.ParseOptions.topNode).

      // ParseRule:: interface
      // A value that describes how to parse a given DOM node or inline
      // style as a ProseMirror node or mark.
      //
      //   tag:: ?string
      //   A CSS selector describing the kind of DOM elements to match. A
      //   single rule should have _either_ a `tag` or a `style` property.
      //
      //   namespace:: ?string
      //   The namespace to match. This should be used with `tag`.
      //   Nodes are only matched when the namespace matches or this property
      //   is null.
      //
      //   style:: ?string
      //   A CSS property name to match. When given, this rule matches
      //   inline styles that list that property. May also have the form
      //   `"property=value"`, in which case the rule only matches if the
      //   propery's value exactly matches the given value. (For more
      //   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)
      //   and return undefined to indicate that the match failed.)
      //
      //   priority:: ?number
      //   Can be used to change the order in which the parse rules in a
      //   schema are tried. Those with higher priority come first. Rules
      //   without a priority are counted as having priority 50. This
      //   property is only meaningful in a schema—when directly
      //   constructing a parser, the order of the rule array is used.
      //
      //   context:: ?string
      //   When given, restricts this rule to only match when the current
      //   context—the parent nodes into which the content is being
      //   parsed—matches this expression. Should contain one or more node
      //   names or node group names followed by single or double slashes.
      //   For example `"paragraph/"` means the rule only matches when the
      //   parent node is a paragraph, `"blockquote/paragraph/"` restricts
      //   it to be in a paragraph that is inside a blockquote, and
      //   `"section//"` matches any position inside a section—a double
      //   slash matches any sequence of ancestor nodes. To allow multiple
      //   different contexts, they can be separated by a pipe (`|`)
      //   character, as in `"blockquote/|list_item/"`.
      //
      //   node:: ?string
      //   The name of the node type to create when this rule matches. Only
      //   valid for rules with a `tag` property, not for style rules. Each
      //   rule should have one of a `node`, `mark`, or `ignore` property
      //   (except when it appears in a [node](#model.NodeSpec.parseDOM) or
      //   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`
      //   or `mark` property will be derived from its position).
      //
      //   mark:: ?string
      //   The name of the mark type to wrap the matched content in.
      //
      //   ignore:: ?bool
      //   When true, ignore content that matches this rule.
      //
      //   skip:: ?bool
      //   When true, ignore the node that matches this rule, but do parse
      //   its content.
      //
      //   attrs:: ?Object
      //   Attributes for the node or mark created by this rule. When
      //   `getAttrs` is provided, it takes precedence.
      //
      //   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>
      //   A function used to compute the attributes for the node or mark
      //   created by this rule. Can also be used to describe further
      //   conditions the DOM element or style must match. When it returns
      //   `false`, the rule won't match. When it returns null or undefined,
      //   that is interpreted as an empty/default set of attributes.
      //
      //   Called with a DOM Element for `tag` rules, and with a string (the
      //   style's value) for `style` rules.
      //
      //   contentElement:: ?union<string, (dom.Node) → dom.Node>
      //   For `tag` rules that produce non-leaf nodes or marks, by default
      //   the content of the DOM element is parsed as content of the mark
      //   or node. If the child nodes are in a descendent node, this may be
      //   a CSS selector string that the parser must use to find the actual
      //   content element, or a function that returns the actual content
      //   element to the parser.
      //
      //   getContent:: ?(dom.Node, schema: Schema) → Fragment
      //   Can be used to override the content of a matched node. When
      //   present, instead of parsing the node's child nodes, the result of
      //   this function is used.
      //
      //   preserveWhitespace:: ?union<bool, "full">
      //   Controls whether whitespace should be preserved when parsing the
      //   content inside the matched element. `false` means whitespace may
      //   be collapsed, `true` means that whitespace should be preserved
      //   but newlines normalized to spaces, and `"full"` means that
      //   newlines should also be preserved.

      // ::- A DOM parser represents a strategy for parsing DOM content into
      // a ProseMirror document conforming to a given schema. Its behavior
      // is defined by an array of [rules](#model.ParseRule).
      var DOMParser = function DOMParser(schema, rules) {
        var this$1 = this;

        // :: Schema
        // The schema into which the parser parses.
        this.schema = schema;
        // :: [ParseRule]
        // The set of [parse rules](#model.ParseRule) that the parser
        // uses, in order of precedence.
        this.rules = rules;
        this.tags = [];
        this.styles = [];

        rules.forEach(function (rule) {
          if (rule.tag) {
            this$1.tags.push(rule);
          } else if (rule.style) {
            this$1.styles.push(rule);
          }
        });
      };

      // :: (dom.Node, ?ParseOptions) → Node
      // Parse a document from the content of a DOM node.
      DOMParser.prototype.parse = function parse(dom, options) {
        if (options === void 0) options = {};

        var context = new ParseContext(this, options, false);
        context.addAll(dom, null, options.from, options.to);
        return context.finish();
      };

      // :: (dom.Node, ?ParseOptions) → Slice
      // Parses the content of the given DOM node, like
      // [`parse`](#model.DOMParser.parse), and takes the same set of
      // options. But unlike that method, which produces a whole node,
      // this one returns a slice that is open at the sides, meaning that
      // the schema constraints aren't applied to the start of nodes to
      // the left of the input and the end of nodes at the end.
      DOMParser.prototype.parseSlice = function parseSlice(dom, options) {
        if (options === void 0) options = {};

        var context = new ParseContext(this, options, true);
        context.addAll(dom, null, options.from, options.to);
        return Slice.maxOpen(context.finish());
      };

      DOMParser.prototype.matchTag = function matchTag(dom, context) {
        var this$1 = this;

        for (var i = 0; i < this.tags.length; i++) {
          var rule = this$1.tags[i];
          if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
            if (rule.getAttrs) {
              var result = rule.getAttrs(dom);
              if (result === false) {
                continue;
              }
              rule.attrs = result;
            }
            return rule;
          }
        }
      };

      DOMParser.prototype.matchStyle = function matchStyle(prop, value, context) {
        var this$1 = this;

        for (var i = 0; i < this.styles.length; i++) {
          var rule = this$1.styles[i];
          if (rule.style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) ||
          // Test that the style string either precisely matches the prop,
          // or has an '=' sign after the prop, followed by the given
          // value.
          rule.style.length > prop.length && (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value)) {
            continue;
          }
          if (rule.getAttrs) {
            var result = rule.getAttrs(value);
            if (result === false) {
              continue;
            }
            rule.attrs = result;
          }
          return rule;
        }
      };

      // : (Schema) → [ParseRule]
      DOMParser.schemaRules = function schemaRules(schema) {
        var result = [];
        function insert(rule) {
          var priority = rule.priority == null ? 50 : rule.priority,
              i = 0;
          for (; i < result.length; i++) {
            var next = result[i],
                nextPriority = next.priority == null ? 50 : next.priority;
            if (nextPriority < priority) {
              break;
            }
          }
          result.splice(i, 0, rule);
        }

        var loop = function loop(name) {
          var rules = schema.marks[name].spec.parseDOM;
          if (rules) {
            rules.forEach(function (rule) {
              insert(rule = copy(rule));
              rule.mark = name;
            });
          }
        };

        for (var name in schema.marks) loop(name);
        var loop$1 = function loop$1(name) {
          var rules$1 = schema.nodes[name$1].spec.parseDOM;
          if (rules$1) {
            rules$1.forEach(function (rule) {
              insert(rule = copy(rule));
              rule.node = name$1;
            });
          }
        };

        for (var name$1 in schema.nodes) loop$1(name);
        return result;
      };

      // :: (Schema) → DOMParser
      // Construct a DOM parser using the parsing rules listed in a
      // schema's [node specs](#model.NodeSpec.parseDOM), reordered by
      // [priority](#model.ParseRule.priority).
      DOMParser.fromSchema = function fromSchema(schema) {
        return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
      };

      // : Object<bool> The block-level tags in HTML5
      var blockTags = {
        address: true, article: true, aside: true, blockquote: true, canvas: true,
        dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,
        footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,
        h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,
        output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true
      };

      // : Object<bool> The tags that we normally ignore.
      var ignoreTags = {
        head: true, noscript: true, object: true, script: true, style: true, title: true
      };

      // : Object<bool> List tags.
      var listTags = { ol: true, ul: true };

      // Using a bitfield for node context options
      var OPT_PRESERVE_WS = 1;
      var OPT_PRESERVE_WS_FULL = 2;
      var OPT_OPEN_LEFT = 4;

      function wsOptionsFor(preserveWhitespace) {
        return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
      }

      var NodeContext = function NodeContext(type, attrs, marks, solid, match, options) {
        this.type = type;
        this.attrs = attrs;
        this.solid = solid;
        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
        this.options = options;
        this.content = [];
        this.marks = marks;
        this.activeMarks = Mark.none;
      };

      NodeContext.prototype.findWrapping = function findWrapping(node) {
        if (!this.match) {
          if (!this.type) {
            return [];
          }
          var fill = this.type.contentMatch.fillBefore(Fragment.from(node));
          if (fill) {
            this.match = this.type.contentMatch.matchFragment(fill);
          } else {
            var start = this.type.contentMatch,
                wrap;
            if (wrap = start.findWrapping(node.type)) {
              this.match = start;
              return wrap;
            } else {
              return null;
            }
          }
        }
        return this.match.findWrapping(node.type);
      };

      NodeContext.prototype.finish = function finish(openEnd) {
        if (!(this.options & OPT_PRESERVE_WS)) {
          // Strip trailing whitespace
          var last = this.content[this.content.length - 1],
              m;
          if (last && last.isText && (m = /\s+$/.exec(last.text))) {
            if (last.text.length == m[0].length) {
              this.content.pop();
            } else {
              this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length));
            }
          }
        }
        var content = Fragment.from(this.content);
        if (!openEnd && this.match) {
          content = content.append(this.match.fillBefore(Fragment.empty, true));
        }
        return this.type ? this.type.create(this.attrs, content, this.marks) : content;
      };

      var ParseContext = function ParseContext(parser, options, open) {
        // : DOMParser The parser we are using.
        this.parser = parser;
        // : Object The options passed to this parse.
        this.options = options;
        this.isOpen = open;
        this.pendingMarks = [];
        var topNode = options.topNode,
            topContext;
        var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);
        if (topNode) {
          topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
        } else if (open) {
          topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
        } else {
          topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
        }
        this.nodes = [topContext];
        // : [Mark] The current set of marks
        this.open = 0;
        this.find = options.findPositions;
        this.needsBlock = false;
      };

      var prototypeAccessors$6 = { top: {}, currentPos: {} };

      prototypeAccessors$6.top.get = function () {
        return this.nodes[this.open];
      };

      // : (dom.Node)
      // Add a DOM node to the content. Text is inserted as text node,
      // otherwise, the node is passed to `addElement` or, if it has a
      // `style` attribute, `addElementWithStyles`.
      ParseContext.prototype.addDOM = function addDOM(dom) {
        var this$1 = this;

        if (dom.nodeType == 3) {
          this.addTextNode(dom);
        } else if (dom.nodeType == 1) {
          var style = dom.getAttribute("style");
          var marks = style ? this.readStyles(parseStyles(style)) : null;
          if (marks != null) {
            for (var i = 0; i < marks.length; i++) {
              this$1.addPendingMark(marks[i]);
            }
          }
          this.addElement(dom);
          if (marks != null) {
            for (var i$1 = 0; i$1 < marks.length; i$1++) {
              this$1.removePendingMark(marks[i$1]);
            }
          }
        }
      };

      ParseContext.prototype.addTextNode = function addTextNode(dom) {
        var value = dom.nodeValue;
        var top = this.top;
        if ((top.type ? top.type.inlineContent : top.content.length && top.content[0].isInline) || /\S/.test(value)) {
          if (!(top.options & OPT_PRESERVE_WS)) {
            value = value.replace(/\s+/g, " ");
            // If this starts with whitespace, and there is no node before it, or
            // a hard break, or a text node that ends with whitespace, strip the
            // leading space.
            if (/^\s/.test(value) && this.open == this.nodes.length - 1) {
              var nodeBefore = top.content[top.content.length - 1];
              var domNodeBefore = dom.previousSibling;
              if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == 'BR' || nodeBefore.isText && /\s$/.test(nodeBefore.text)) {
                value = value.slice(1);
              }
            }
          } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
            value = value.replace(/\r?\n|\r/g, " ");
          }
          if (value) {
            this.insertNode(this.parser.schema.text(value));
          }
          this.findInText(dom);
        } else {
          this.findInside(dom);
        }
      };

      // : (dom.Element)
      // Try to find a handler for the given tag and use that to parse. If
      // none is found, the element's content nodes are added directly.
      ParseContext.prototype.addElement = function addElement(dom) {
        var name = dom.nodeName.toLowerCase();
        if (listTags.hasOwnProperty(name)) {
          normalizeList(dom);
        }
        var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || this.parser.matchTag(dom, this);
        if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
          this.findInside(dom);
        } else if (!rule || rule.skip) {
          if (rule && rule.skip.nodeType) {
            dom = rule.skip;
          }
          var sync,
              top = this.top,
              oldNeedsBlock = this.needsBlock;
          if (blockTags.hasOwnProperty(name)) {
            sync = true;
            if (!top.type) {
              this.needsBlock = true;
            }
          }
          this.addAll(dom);
          if (sync) {
            this.sync(top);
          }
          this.needsBlock = oldNeedsBlock;
        } else {
          this.addElementByRule(dom, rule);
        }
      };

      // Run any style parser associated with the node's styles. Either
      // return an array of marks, or null to indicate some of the styles
      // had a rule with `ignore` set.
      ParseContext.prototype.readStyles = function readStyles(styles) {
        var this$1 = this;

        var marks = Mark.none;
        for (var i = 0; i < styles.length; i += 2) {
          var rule = this$1.parser.matchStyle(styles[i], styles[i + 1], this$1);
          if (!rule) {
            continue;
          }
          if (rule.ignore) {
            return null;
          }
          marks = this$1.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
        }
        return marks;
      };

      // : (dom.Element, ParseRule) → bool
      // Look up a handler for the given node. If none are found, return
      // false. Otherwise, apply it, use its return value to drive the way
      // the node's content is wrapped, and return true.
      ParseContext.prototype.addElementByRule = function addElementByRule(dom, rule) {
        var this$1 = this;

        var sync, nodeType, markType, mark;
        if (rule.node) {
          nodeType = this.parser.schema.nodes[rule.node];
          if (nodeType.isLeaf) {
            this.insertNode(nodeType.create(rule.attrs));
          } else {
            sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);
          }
        } else {
          markType = this.parser.schema.marks[rule.mark];
          mark = markType.create(rule.attrs);
          this.addPendingMark(mark);
        }
        var startIn = this.top;

        if (nodeType && nodeType.isLeaf) {
          this.findInside(dom);
        } else if (rule.getContent) {
          this.findInside(dom);
          rule.getContent(dom, this.parser.schema).forEach(function (node) {
            return this$1.insertNode(node);
          });
        } else {
          var contentDOM = rule.contentElement;
          if (typeof contentDOM == "string") {
            contentDOM = dom.querySelector(contentDOM);
          } else if (typeof contentDOM == "function") {
            contentDOM = contentDOM(dom);
          }
          if (!contentDOM) {
            contentDOM = dom;
          }
          this.findAround(dom, contentDOM, true);
          this.addAll(contentDOM, sync);
        }
        if (sync) {
          this.sync(startIn);this.open--;
        }
        if (mark) {
          this.removePendingMark(mark);
        }
        return true;
      };

      // : (dom.Node, ?NodeBuilder, ?number, ?number)
      // Add all child nodes between `startIndex` and `endIndex` (or the
      // whole node, if not given). If `sync` is passed, use it to
      // synchronize after every block element.
      ParseContext.prototype.addAll = function addAll(parent, sync, startIndex, endIndex) {
        var this$1 = this;

        var index = startIndex || 0;
        for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
          this$1.findAtPoint(parent, index);
          this$1.addDOM(dom);
          if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {
            this$1.sync(sync);
          }
        }
        this.findAtPoint(parent, index);
      };

      // Try to find a way to fit the given node type into the current
      // context. May add intermediate wrappers and/or leave non-solid
      // nodes that we're in.
      ParseContext.prototype.findPlace = function findPlace(node) {
        var this$1 = this;

        var route, sync;
        for (var depth = this.open; depth >= 0; depth--) {
          var cx = this$1.nodes[depth];
          var found = cx.findWrapping(node);
          if (found && (!route || route.length > found.length)) {
            route = found;
            sync = cx;
            if (!found.length) {
              break;
            }
          }
          if (cx.solid) {
            break;
          }
        }
        if (!route) {
          return false;
        }
        this.sync(sync);
        for (var i = 0; i < route.length; i++) {
          this$1.enterInner(route[i], null, false);
        }
        return true;
      };

      // : (Node) → ?Node
      // Try to insert the given node, adjusting the context when needed.
      ParseContext.prototype.insertNode = function insertNode(node) {
        if (node.isInline && this.needsBlock && !this.top.type) {
          var block = this.textblockFromContext();
          if (block) {
            this.enterInner(block);
          }
        }
        if (this.findPlace(node)) {
          this.closeExtra();
          var top = this.top;
          this.applyPendingMarks(top);
          if (top.match) {
            top.match = top.match.matchType(node.type);
          }
          var marks = top.activeMarks;
          for (var i = 0; i < node.marks.length; i++) {
            if (!top.type || top.type.allowsMarkType(node.marks[i].type)) {
              marks = node.marks[i].addToSet(marks);
            }
          }
          top.content.push(node.mark(marks));
        }
      };

      ParseContext.prototype.applyPendingMarks = function applyPendingMarks(top) {
        var this$1 = this;

        for (var i = 0; i < this.pendingMarks.length; i++) {
          var mark = this$1.pendingMarks[i];
          if ((!top.type || top.type.allowsMarkType(mark.type)) && !mark.type.isInSet(top.activeMarks)) {
            top.activeMarks = mark.addToSet(top.activeMarks);
            this$1.pendingMarks.splice(i--, 1);
          }
        }
      };

      // : (NodeType, ?Object) → bool
      // Try to start a node of the given type, adjusting the context when
      // necessary.
      ParseContext.prototype.enter = function enter(type, attrs, preserveWS) {
        var ok = this.findPlace(type.create(attrs));
        if (ok) {
          this.applyPendingMarks(this.top);
          this.enterInner(type, attrs, true, preserveWS);
        }
        return ok;
      };

      // Open a node of the given type
      ParseContext.prototype.enterInner = function enterInner(type, attrs, solid, preserveWS) {
        this.closeExtra();
        var top = this.top;
        top.match = top.match && top.match.matchType(type, attrs);
        var options = preserveWS == null ? top.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);
        if (top.options & OPT_OPEN_LEFT && top.content.length == 0) {
          options |= OPT_OPEN_LEFT;
        }
        this.nodes.push(new NodeContext(type, attrs, top.activeMarks, solid, null, options));
        this.open++;
      };

      // Make sure all nodes above this.open are finished and added to
      // their parents
      ParseContext.prototype.closeExtra = function closeExtra(openEnd) {
        var this$1 = this;

        var i = this.nodes.length - 1;
        if (i > this.open) {
          for (; i > this.open; i--) {
            this$1.nodes[i - 1].content.push(this$1.nodes[i].finish(openEnd));
          }
          this.nodes.length = this.open + 1;
        }
      };

      ParseContext.prototype.finish = function finish() {
        this.open = 0;
        this.closeExtra(this.isOpen);
        return this.nodes[0].finish(this.isOpen || this.options.topOpen);
      };

      ParseContext.prototype.sync = function sync(to) {
        var this$1 = this;

        for (var i = this.open; i >= 0; i--) {
          if (this$1.nodes[i] == to) {
            this$1.open = i;
            return;
          }
        }
      };

      ParseContext.prototype.addPendingMark = function addPendingMark(mark) {
        this.pendingMarks.push(mark);
      };

      ParseContext.prototype.removePendingMark = function removePendingMark(mark) {
        var found = this.pendingMarks.lastIndexOf(mark);
        if (found > -1) {
          this.pendingMarks.splice(found, 1);
        } else {
          var top = this.top;
          top.activeMarks = mark.removeFromSet(top.activeMarks);
        }
      };

      prototypeAccessors$6.currentPos.get = function () {
        var this$1 = this;

        this.closeExtra();
        var pos = 0;
        for (var i = this.open; i >= 0; i--) {
          var content = this$1.nodes[i].content;
          for (var j = content.length - 1; j >= 0; j--) {
            pos += content[j].nodeSize;
          }
          if (i) {
            pos++;
          }
        }
        return pos;
      };

      ParseContext.prototype.findAtPoint = function findAtPoint(parent, offset) {
        var this$1 = this;

        if (this.find) {
          for (var i = 0; i < this.find.length; i++) {
            if (this$1.find[i].node == parent && this$1.find[i].offset == offset) {
              this$1.find[i].pos = this$1.currentPos;
            }
          }
        }
      };

      ParseContext.prototype.findInside = function findInside(parent) {
        var this$1 = this;

        if (this.find) {
          for (var i = 0; i < this.find.length; i++) {
            if (this$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1.find[i].node)) {
              this$1.find[i].pos = this$1.currentPos;
            }
          }
        }
      };

      ParseContext.prototype.findAround = function findAround(parent, content, before) {
        var this$1 = this;

        if (parent != content && this.find) {
          for (var i = 0; i < this.find.length; i++) {
            if (this$1.find[i].pos == null && parent.nodeType == 1 && parent.contains(this$1.find[i].node)) {
              var pos = content.compareDocumentPosition(this$1.find[i].node);
              if (pos & (before ? 2 : 4)) {
                this$1.find[i].pos = this$1.currentPos;
              }
            }
          }
        }
      };

      ParseContext.prototype.findInText = function findInText(textNode) {
        var this$1 = this;

        if (this.find) {
          for (var i = 0; i < this.find.length; i++) {
            if (this$1.find[i].node == textNode) {
              this$1.find[i].pos = this$1.currentPos - (textNode.nodeValue.length - this$1.find[i].offset);
            }
          }
        }
      };

      // : (string) → bool
      // Determines whether the given [context
      // string](#ParseRule.context) matches this context.
      ParseContext.prototype.matchesContext = function matchesContext(context) {
        var this$1 = this;

        if (context.indexOf("|") > -1) {
          return context.split(/\s*\|\s*/).some(this.matchesContext, this);
        }

        var parts = context.split("/");
        var option = this.options.context;
        var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
        var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
        var match = function match(i, depth) {
          for (; i >= 0; i--) {
            var part = parts[i];
            if (part == "") {
              if (i == parts.length - 1 || i == 0) {
                continue;
              }
              for (; depth >= minDepth; depth--) {
                if (match(i - 1, depth)) {
                  return true;
                }
              }
              return false;
            } else {
              var next = depth > 0 || depth == 0 && useRoot ? this$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
              if (!next || next.name != part && next.groups.indexOf(part) == -1) {
                return false;
              }
              depth--;
            }
          }
          return true;
        };
        return match(parts.length - 1, this.open);
      };

      ParseContext.prototype.textblockFromContext = function textblockFromContext() {
        var this$1 = this;

        var $context = this.options.context;
        if ($context) {
          for (var d = $context.depth; d >= 0; d--) {
            var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
            if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
              return deflt;
            }
          }
        }
        for (var name in this$1.parser.schema.nodes) {
          var type = this$1.parser.schema.nodes[name];
          if (type.isTextblock && type.defaultAttrs) {
            return type;
          }
        }
      };

      Object.defineProperties(ParseContext.prototype, prototypeAccessors$6);

      // Kludge to work around directly nested list nodes produced by some
      // tools and allowed by browsers to mean that the nested list is
      // actually part of the list item above it.
      function normalizeList(dom) {
        for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
          var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
          if (name && listTags.hasOwnProperty(name) && prevItem) {
            prevItem.appendChild(child);
            child = prevItem;
          } else if (name == "li") {
            prevItem = child;
          } else if (name) {
            prevItem = null;
          }
        }
      }

      // Apply a CSS selector.
      function matches(dom, selector) {
        return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
      }

      // : (string) → [string]
      // Tokenize a style attribute into property/value pairs.
      function parseStyles(style) {
        var re = /\s*([\w-]+)\s*:\s*([^;]+)/g,
            m,
            result = [];
        while (m = re.exec(style)) {
          result.push(m[1], m[2].trim());
        }
        return result;
      }

      function copy(obj) {
        var copy = {};
        for (var prop in obj) {
          copy[prop] = obj[prop];
        }
        return copy;
      }

      // DOMOutputSpec:: interface
      // A description of a DOM structure. Can be either a string, which is
      // interpreted as a text node, a DOM node, which is interpreted as
      // itself, or an array.
      //
      // An array describes a DOM element. The first value in the array
      // should be a string—the name of the DOM element. If the second
      // element is plain object, it is interpreted as a set of attributes
      // for the element. Any elements after that (including the 2nd if it's
      // not an attribute object) are interpreted as children of the DOM
      // elements, and must either be valid `DOMOutputSpec` values, or the
      // number zero.
      //
      // The number zero (pronounced “hole”) is used to indicate the place
      // where a node's child nodes should be inserted. It it occurs in an
      // output spec, it should be the only child element in its parent
      // node.

      // ::- A DOM serializer knows how to convert ProseMirror nodes and
      // marks of various types to DOM nodes.
      var DOMSerializer = function DOMSerializer(nodes, marks) {
        // :: Object<(node: Node) → DOMOutputSpec>
        // The node serialization functions.
        this.nodes = nodes || {};
        // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>
        // The mark serialization functions.
        this.marks = marks || {};
      };

      // :: (Fragment, ?Object) → dom.DocumentFragment
      // Serialize the content of this fragment to a DOM fragment. When
      // not in the browser, the `document` option, containing a DOM
      // document, should be passed so that the serializer can create
      // nodes.
      DOMSerializer.prototype.serializeFragment = function serializeFragment(fragment, options, target) {
        var this$1 = this;
        if (options === void 0) options = {};

        if (!target) {
          target = doc(options).createDocumentFragment();
        }

        var top = target,
            active = null;
        fragment.forEach(function (node) {
          if (active || node.marks.length) {
            if (!active) {
              active = [];
            }
            var keep = 0,
                rendered = 0;
            while (keep < active.length && rendered < node.marks.length) {
              var next = node.marks[rendered];
              if (!this$1.marks[next.type.name]) {
                rendered++;continue;
              }
              if (!next.eq(active[keep]) || next.type.spec.spanning === false) {
                break;
              }
              keep += 2;rendered++;
            }
            while (keep < active.length) {
              top = active.pop();
              active.pop();
            }
            while (rendered < node.marks.length) {
              var add = node.marks[rendered++];
              var markDOM = this$1.serializeMark(add, node.isInline, options);
              if (markDOM) {
                active.push(add, top);
                top.appendChild(markDOM.dom);
                top = markDOM.contentDOM || markDOM.dom;
              }
            }
          }
          top.appendChild(this$1.serializeNode(node, options));
        });

        return target;
      };

      // :: (Node, ?Object) → dom.Node
      // Serialize this node to a DOM node. This can be useful when you
      // need to serialize a part of a document, as opposed to the whole
      // document. To serialize a whole document, use
      // [`serializeFragment`](#model.DOMSerializer.serializeFragment) on
      // its [content](#model.Node.content).
      DOMSerializer.prototype.serializeNode = function serializeNode(node, options) {
        if (options === void 0) options = {};

        var ref = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
        var dom = ref.dom;
        var contentDOM = ref.contentDOM;
        if (contentDOM) {
          if (node.isLeaf) {
            throw new RangeError("Content hole not allowed in a leaf node spec");
          }
          if (options.onContent) {
            options.onContent(node, contentDOM, options);
          } else {
            this.serializeFragment(node.content, options, contentDOM);
          }
        }
        return dom;
      };

      DOMSerializer.prototype.serializeNodeAndMarks = function serializeNodeAndMarks(node, options) {
        var this$1 = this;
        if (options === void 0) options = {};

        var dom = this.serializeNode(node, options);
        for (var i = node.marks.length - 1; i >= 0; i--) {
          var wrap = this$1.serializeMark(node.marks[i], node.isInline, options);
          if (wrap) {
            (wrap.contentDOM || wrap.dom).appendChild(dom);
            dom = wrap.dom;
          }
        }
        return dom;
      };

      DOMSerializer.prototype.serializeMark = function serializeMark(mark, inline, options) {
        if (options === void 0) options = {};

        var toDOM = this.marks[mark.type.name];
        return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
      };

      // :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}
      // Render an [output spec](#model.DOMOutputSpec) to a DOM node. If
      // the spec has a hole (zero) in it, `contentDOM` will point at the
      // node with the hole.
      DOMSerializer.renderSpec = function renderSpec(doc, structure) {
        if (typeof structure == "string") {
          return { dom: doc.createTextNode(structure) };
        }
        if (structure.nodeType != null) {
          return { dom: structure };
        }
        var dom = doc.createElement(structure[0]),
            contentDOM = null;
        var attrs = structure[1],
            start = 1;
        if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
          start = 2;
          for (var name in attrs) {
            if (attrs[name] != null) {
              dom.setAttribute(name, attrs[name]);
            }
          }
        }
        for (var i = start; i < structure.length; i++) {
          var child = structure[i];
          if (child === 0) {
            if (i < structure.length - 1 || i > start) {
              throw new RangeError("Content hole must be the only child of its parent node");
            }
            return { dom: dom, contentDOM: dom };
          } else {
            var ref = DOMSerializer.renderSpec(doc, child);
            var inner = ref.dom;
            var innerContent = ref.contentDOM;
            dom.appendChild(inner);
            if (innerContent) {
              if (contentDOM) {
                throw new RangeError("Multiple content holes");
              }
              contentDOM = innerContent;
            }
          }
        }
        return { dom: dom, contentDOM: contentDOM };
      };

      // :: (Schema) → DOMSerializer
      // Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)
      // properties in a schema's node and mark specs.
      DOMSerializer.fromSchema = function fromSchema(schema) {
        return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
      };

      // : (Schema) → Object<(node: Node) → DOMOutputSpec>
      // Gather the serializers in a schema's node specs into an object.
      // This can be useful as a base to build a custom serializer from.
      DOMSerializer.nodesFromSchema = function nodesFromSchema(schema) {
        var result = gatherToDOM(schema.nodes);
        if (!result.text) {
          result.text = function (node) {
            return node.text;
          };
        }
        return result;
      };

      // : (Schema) → Object<(mark: Mark) → DOMOutputSpec>
      // Gather the serializers in a schema's mark specs into an object.
      DOMSerializer.marksFromSchema = function marksFromSchema(schema) {
        return gatherToDOM(schema.marks);
      };

      function gatherToDOM(obj) {
        var result = {};
        for (var name in obj) {
          var toDOM = obj[name].spec.toDOM;
          if (toDOM) {
            result[name] = toDOM;
          }
        }
        return result;
      }

      function doc(options) {
        // declare global: window
        return options.document || window.document;
      }

      exports.Node = Node;
      exports.ResolvedPos = ResolvedPos;
      exports.NodeRange = NodeRange;
      exports.Fragment = Fragment;
      exports.Slice = Slice;
      exports.ReplaceError = ReplaceError;
      exports.Mark = Mark;
      exports.Schema = Schema;
      exports.NodeType = NodeType;
      exports.MarkType = MarkType;
      exports.ContentMatch = ContentMatch;
      exports.DOMParser = DOMParser;
      exports.DOMSerializer = DOMSerializer;
      
    });

    unwrapExports(dist);
    var dist_1 = dist.Node;
    var dist_2 = dist.ResolvedPos;
    var dist_3 = dist.NodeRange;
    var dist_4 = dist.Fragment;
    var dist_5 = dist.Slice;
    var dist_6 = dist.ReplaceError;
    var dist_7 = dist.Mark;
    var dist_8 = dist.Schema;
    var dist_9 = dist.NodeType;
    var dist_10 = dist.MarkType;
    var dist_11 = dist.ContentMatch;
    var dist_12 = dist.DOMParser;
    var dist_13 = dist.DOMSerializer;

    var dist$1 = createCommonjsModule(function (module, exports) {

      Object.defineProperty(exports, '__esModule', { value: true });

      // Mappable:: interface
      // There are several things that positions can be mapped through.
      // Such objects conform to this interface.
      //
      //   map:: (pos: number, assoc: ?number) → number
      //   Map a position through this object. When given, `assoc` (should
      //   be -1 or 1, defaults to 1) determines with which side the
      //   position is associated, which determines in which direction to
      //   move when a chunk of content is inserted at the mapped position.
      //
      //   mapResult:: (pos: number, assoc: ?number) → MapResult
      //   Map a position, and return an object containing additional
      //   information about the mapping. The result's `deleted` field tells
      //   you whether the position was deleted (completely enclosed in a
      //   replaced range) during the mapping. When content on only one side
      //   is deleted, the position itself is only considered deleted when
      //   `assoc` points in the direction of the deleted content.

      // Recovery values encode a range index and an offset. They are
      // represented as numbers, because tons of them will be created when
      // mapping, for example, a large number of decorations. The number's
      // lower 16 bits provide the index, the remaining bits the offset.
      //
      // Note: We intentionally don't use bit shift operators to en- and
      // decode these, since those clip to 32 bits, which we might in rare
      // cases want to overflow. A 64-bit float can represent 48-bit
      // integers precisely.

      var lower16 = 0xffff;
      var factor16 = Math.pow(2, 16);

      function makeRecover(index, offset) {
        return index + offset * factor16;
      }
      function recoverIndex(value) {
        return value & lower16;
      }
      function recoverOffset(value) {
        return (value - (value & lower16)) / factor16;
      }

      // ::- An object representing a mapped position with extra
      // information.
      var MapResult = function MapResult(pos, deleted, recover) {
        if (deleted === void 0) deleted = false;
        if (recover === void 0) recover = null;

        // :: number The mapped version of the position.
        this.pos = pos;
        // :: bool Tells you whether the position was deleted, that is,
        // whether the step removed its surroundings from the document.
        this.deleted = deleted;
        this.recover = recover;
      };

      // :: class extends Mappable
      // A map describing the deletions and insertions made by a step, which
      // can be used to find the correspondence between positions in the
      // pre-step version of a document and the same position in the
      // post-step version.
      var StepMap = function StepMap(ranges, inverted) {
        if (inverted === void 0) inverted = false;

        this.ranges = ranges;
        this.inverted = inverted;
      };

      StepMap.prototype.recover = function recover(value) {
        var this$1 = this;

        var diff = 0,
            index = recoverIndex(value);
        if (!this.inverted) {
          for (var i = 0; i < index; i++) {
            diff += this$1.ranges[i * 3 + 2] - this$1.ranges[i * 3 + 1];
          }
        }
        return this.ranges[index * 3] + diff + recoverOffset(value);
      };

      // : (number, ?number) → MapResult
      StepMap.prototype.mapResult = function mapResult(pos, assoc) {
        if (assoc === void 0) assoc = 1;
        return this._map(pos, assoc, false);
      };

      // : (number, ?number) → number
      StepMap.prototype.map = function map(pos, assoc) {
        if (assoc === void 0) assoc = 1;
        return this._map(pos, assoc, true);
      };

      StepMap.prototype._map = function _map(pos, assoc, simple) {
        var this$1 = this;

        var diff = 0,
            oldIndex = this.inverted ? 2 : 1,
            newIndex = this.inverted ? 1 : 2;
        for (var i = 0; i < this.ranges.length; i += 3) {
          var start = this$1.ranges[i] - (this$1.inverted ? diff : 0);
          if (start > pos) {
            break;
          }
          var oldSize = this$1.ranges[i + oldIndex],
              newSize = this$1.ranges[i + newIndex],
              end = start + oldSize;
          if (pos <= end) {
            var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
            var result = start + diff + (side < 0 ? 0 : newSize);
            if (simple) {
              return result;
            }
            var recover = makeRecover(i / 3, pos - start);
            return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover);
          }
          diff += newSize - oldSize;
        }
        return simple ? pos + diff : new MapResult(pos + diff);
      };

      StepMap.prototype.touches = function touches(pos, recover) {
        var this$1 = this;

        var diff = 0,
            index = recoverIndex(recover);
        var oldIndex = this.inverted ? 2 : 1,
            newIndex = this.inverted ? 1 : 2;
        for (var i = 0; i < this.ranges.length; i += 3) {
          var start = this$1.ranges[i] - (this$1.inverted ? diff : 0);
          if (start > pos) {
            break;
          }
          var oldSize = this$1.ranges[i + oldIndex],
              end = start + oldSize;
          if (pos <= end && i == index * 3) {
            return true;
          }
          diff += this$1.ranges[i + newIndex] - oldSize;
        }
        return false;
      };

      // :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))
      // Calls the given function on each of the changed ranges included in
      // this map.
      StepMap.prototype.forEach = function forEach(f) {
        var this$1 = this;

        var oldIndex = this.inverted ? 2 : 1,
            newIndex = this.inverted ? 1 : 2;
        for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
          var start = this$1.ranges[i],
              oldStart = start - (this$1.inverted ? diff : 0),
              newStart = start + (this$1.inverted ? 0 : diff);
          var oldSize = this$1.ranges[i + oldIndex],
              newSize = this$1.ranges[i + newIndex];
          f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
          diff += newSize - oldSize;
        }
      };

      // :: () → StepMap
      // Create an inverted version of this map. The result can be used to
      // map positions in the post-step document to the pre-step document.
      StepMap.prototype.invert = function invert() {
        return new StepMap(this.ranges, !this.inverted);
      };

      StepMap.prototype.toString = function toString() {
        return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
      };

      // :: (n: number) → StepMap
      // Create a map that moves all positions by offset `n` (which may be
      // negative). This can be useful when applying steps meant for a
      // sub-document to a larger document, or vice-versa.
      StepMap.offset = function offset(n) {
        return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
      };

      StepMap.empty = new StepMap([]);

      // :: class extends Mappable
      // A mapping represents a pipeline of zero or more [step
      // maps](#transform.StepMap). It has special provisions for losslessly
      // handling mapping positions through a series of steps in which some
      // steps are inverted versions of earlier steps. (This comes up when
      // ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for
      // collaboration or history management.)
      var Mapping = function Mapping(maps, mirror, from, to) {
        // :: [StepMap]
        // The step maps in this mapping.
        this.maps = maps || [];
        // :: number
        // The starting position in the `maps` array, used when `map` or
        // `mapResult` is called.
        this.from = from || 0;
        // :: number
        // The end position in the `maps` array.
        this.to = to == null ? this.maps.length : to;
        this.mirror = mirror;
      };

      // :: (?number, ?number) → Mapping
      // Create a mapping that maps only through a part of this one.
      Mapping.prototype.slice = function slice(from, to) {
        if (from === void 0) from = 0;
        if (to === void 0) to = this.maps.length;

        return new Mapping(this.maps, this.mirror, from, to);
      };

      Mapping.prototype.copy = function copy() {
        return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
      };

      // :: (StepMap, ?number)
      // Add a step map to the end of this mapping. If `mirrors` is
      // given, it should be the index of the step map that is the mirror
      // image of this one.
      Mapping.prototype.appendMap = function appendMap(map, mirrors) {
        this.to = this.maps.push(map);
        if (mirrors != null) {
          this.setMirror(this.maps.length - 1, mirrors);
        }
      };

      // :: (Mapping)
      // Add all the step maps in a given mapping to this one (preserving
      // mirroring information).
      Mapping.prototype.appendMapping = function appendMapping(mapping) {
        var this$1 = this;

        for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
          var mirr = mapping.getMirror(i);
          this$1.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
        }
      };

      // :: (number) → ?number
      // Finds the offset of the step map that mirrors the map at the
      // given offset, in this mapping (as per the second argument to
      // `appendMap`).
      Mapping.prototype.getMirror = function getMirror(n) {
        var this$1 = this;

        if (this.mirror) {
          for (var i = 0; i < this.mirror.length; i++) {
            if (this$1.mirror[i] == n) {
              return this$1.mirror[i + (i % 2 ? -1 : 1)];
            }
          }
        }
      };

      Mapping.prototype.setMirror = function setMirror(n, m) {
        if (!this.mirror) {
          this.mirror = [];
        }
        this.mirror.push(n, m);
      };

      // :: (Mapping)
      // Append the inverse of the given mapping to this one.
      Mapping.prototype.appendMappingInverted = function appendMappingInverted(mapping) {
        var this$1 = this;

        for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
          var mirr = mapping.getMirror(i);
          this$1.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
        }
      };

      // () → Mapping
      // Create an inverted version of this mapping.
      Mapping.prototype.invert = function invert() {
        var inverse = new Mapping();
        inverse.appendMappingInverted(this);
        return inverse;
      };

      // : (number, ?number) → number
      // Map a position through this mapping.
      Mapping.prototype.map = function map(pos, assoc) {
        var this$1 = this;
        if (assoc === void 0) assoc = 1;

        if (this.mirror) {
          return this._map(pos, assoc, true);
        }
        for (var i = this.from; i < this.to; i++) {
          pos = this$1.maps[i].map(pos, assoc);
        }
        return pos;
      };

      // : (number, ?number) → MapResult
      // Map a position through this mapping, returning a mapping
      // result.
      Mapping.prototype.mapResult = function mapResult(pos, assoc) {
        if (assoc === void 0) assoc = 1;
        return this._map(pos, assoc, false);
      };

      Mapping.prototype._map = function _map(pos, assoc, simple) {
        var this$1 = this;

        var deleted = false,
            recoverables = null;

        for (var i = this.from; i < this.to; i++) {
          var map = this$1.maps[i],
              rec = recoverables && recoverables[i];
          if (rec != null && map.touches(pos, rec)) {
            pos = map.recover(rec);
            continue;
          }

          var result = map.mapResult(pos, assoc);
          if (result.recover != null) {
            var corr = this$1.getMirror(i);
            if (corr != null && corr > i && corr < this$1.to) {
              if (result.deleted) {
                i = corr;
                pos = this$1.maps[corr].recover(result.recover);
                continue;
              } else {
                (recoverables || (recoverables = Object.create(null)))[corr] = result.recover;
              }
            }
          }

          if (result.deleted) {
            deleted = true;
          }
          pos = result.pos;
        }

        return simple ? pos : new MapResult(pos, deleted);
      };

      function TransformError(message) {
        var err = Error.call(this, message);
        err.__proto__ = TransformError.prototype;
        return err;
      }

      TransformError.prototype = Object.create(Error.prototype);
      TransformError.prototype.constructor = TransformError;
      TransformError.prototype.name = "TransformError";

      // ::- Abstraction to build up and track an array of
      // [steps](#transform.Step) representing a document transformation.
      //
      // Most transforming methods return the `Transform` object itself, so
      // that they can be chained.
      var Transform = function Transform(doc) {
        // :: Node
        // The current document (the result of applying the steps in the
        // transform).
        this.doc = doc;
        // :: [Step]
        // The steps in this transform.
        this.steps = [];
        // :: [Node]
        // The documents before each of the steps.
        this.docs = [];
        // :: Mapping
        // A mapping with the maps for each of the steps in this transform.
        this.mapping = new Mapping();
      };

      var prototypeAccessors = { before: {}, docChanged: {} };

      // :: Node The starting document.
      prototypeAccessors.before.get = function () {
        return this.docs.length ? this.docs[0] : this.doc;
      };

      // :: (step: Step) → this
      // Apply a new step in this transform, saving the result. Throws an
      // error when the step fails.
      Transform.prototype.step = function step(object) {
        var result = this.maybeStep(object);
        if (result.failed) {
          throw new TransformError(result.failed);
        }
        return this;
      };

      // :: (Step) → StepResult
      // Try to apply a step in this transformation, ignoring it if it
      // fails. Returns the step result.
      Transform.prototype.maybeStep = function maybeStep(step) {
        var result = step.apply(this.doc);
        if (!result.failed) {
          this.addStep(step, result.doc);
        }
        return result;
      };

      // :: bool
      // True when the document has been changed (when there are any
      // steps).
      prototypeAccessors.docChanged.get = function () {
        return this.steps.length > 0;
      };

      Transform.prototype.addStep = function addStep(step, doc) {
        this.docs.push(this.doc);
        this.steps.push(step);
        this.mapping.appendMap(step.getMap());
        this.doc = doc;
      };

      Object.defineProperties(Transform.prototype, prototypeAccessors);

      function mustOverride() {
        throw new Error("Override me");
      }

      var stepsByID = Object.create(null);

      // ::- A step object represents an atomic change. It generally applies
      // only to the document it was created for, since the positions
      // stored in it will only make sense for that document.
      //
      // New steps are defined by creating classes that extend `Step`,
      // overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
      // methods, and registering your class with a unique
      // JSON-serialization identifier using
      // [`Step.jsonID`](#transform.Step^jsonID).
      var Step = function Step() {};

      Step.prototype.apply = function apply(_doc) {
        return mustOverride();
      };

      // :: () → StepMap
      // Get the step map that represents the changes made by this step,
      // and which can be used to transform between positions in the old
      // and the new document.
      Step.prototype.getMap = function getMap() {
        return StepMap.empty;
      };

      // :: (doc: Node) → Step
      // Create an inverted version of this step. Needs the document as it
      // was before the step as argument.
      Step.prototype.invert = function invert(_doc) {
        return mustOverride();
      };

      // :: (mapping: Mappable) → ?Step
      // Map this step through a mappable thing, returning either a
      // version of that step with its positions adjusted, or `null` if
      // the step was entirely deleted by the mapping.
      Step.prototype.map = function map(_mapping) {
        return mustOverride();
      };

      // :: (other: Step) → ?Step
      // Try to merge this step with another one, to be applied directly
      // after it. Returns the merged step when possible, null if the
      // steps can't be merged.
      Step.prototype.merge = function merge(_other) {
        return null;
      };

      // :: () → Object
      // Create a JSON-serializeable representation of this step. When
      // defining this for a custom subclass, make sure the result object
      // includes the step type's [JSON id](#transform.Step^jsonID) under
      // the `stepType` property.
      Step.prototype.toJSON = function toJSON() {
        return mustOverride();
      };

      // :: (Schema, Object) → Step
      // Deserialize a step from its JSON representation. Will call
      // through to the step class' own implementation of this method.
      Step.fromJSON = function fromJSON(schema, json) {
        if (!json || !json.stepType) {
          throw new RangeError("Invalid input for Step.fromJSON");
        }
        var type = stepsByID[json.stepType];
        if (!type) {
          throw new RangeError("No step type " + json.stepType + " defined");
        }
        return type.fromJSON(schema, json);
      };

      // :: (string, constructor<Step>)
      // To be able to serialize steps to JSON, each step needs a string
      // ID to attach to its JSON representation. Use this method to
      // register an ID for your step classes. Try to pick something
      // that's unlikely to clash with steps from other modules.
      Step.jsonID = function jsonID(id, stepClass) {
        if (id in stepsByID) {
          throw new RangeError("Duplicate use of step JSON ID " + id);
        }
        stepsByID[id] = stepClass;
        stepClass.prototype.jsonID = id;
        return stepClass;
      };

      // ::- The result of [applying](#transform.Step.apply) a step. Contains either a
      // new document or a failure value.
      var StepResult = function StepResult(doc, failed) {
        // :: ?Node The transformed document.
        this.doc = doc;
        // :: ?string Text providing information about a failed step.
        this.failed = failed;
      };

      // :: (Node) → StepResult
      // Create a successful step result.
      StepResult.ok = function ok(doc) {
        return new StepResult(doc, null);
      };

      // :: (string) → StepResult
      // Create a failed step result.
      StepResult.fail = function fail(message) {
        return new StepResult(null, message);
      };

      // :: (Node, number, number, Slice) → StepResult
      // Call [`Node.replace`](#model.Node.replace) with the given
      // arguments. Create a successful result if it succeeds, and a
      // failed one if it throws a `ReplaceError`.
      StepResult.fromReplace = function fromReplace(doc, from, to, slice) {
        try {
          return StepResult.ok(doc.replace(from, to, slice));
        } catch (e) {
          if (e instanceof dist.ReplaceError) {
            return StepResult.fail(e.message);
          }
          throw e;
        }
      };

      // ::- Replace a part of the document with a slice of new content.
      var ReplaceStep = function (Step$$1) {
        function ReplaceStep(from, to, slice, structure) {
          Step$$1.call(this);
          this.from = from;
          this.to = to;
          this.slice = slice;
          this.structure = !!structure;
        }

        if (Step$$1) ReplaceStep.__proto__ = Step$$1;
        ReplaceStep.prototype = Object.create(Step$$1 && Step$$1.prototype);
        ReplaceStep.prototype.constructor = ReplaceStep;

        ReplaceStep.prototype.apply = function apply(doc) {
          if (this.structure && contentBetween(doc, this.from, this.to)) {
            return StepResult.fail("Structure replace would overwrite content");
          }
          return StepResult.fromReplace(doc, this.from, this.to, this.slice);
        };

        ReplaceStep.prototype.getMap = function getMap() {
          return new StepMap([this.from, this.to - this.from, this.slice.size]);
        };

        ReplaceStep.prototype.invert = function invert(doc) {
          return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));
        };

        ReplaceStep.prototype.map = function map(mapping) {
          var from = mapping.mapResult(this.from, 1),
              to = mapping.mapResult(this.to, -1);
          if (from.deleted && to.deleted) {
            return null;
          }
          return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);
        };

        ReplaceStep.prototype.merge = function merge(other) {
          if (!(other instanceof ReplaceStep) || other.structure != this.structure) {
            return null;
          }

          if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
            var slice = this.slice.size + other.slice.size == 0 ? dist.Slice.empty : new dist.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
            return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
          } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
            var slice$1 = this.slice.size + other.slice.size == 0 ? dist.Slice.empty : new dist.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
            return new ReplaceStep(other.from, this.to, slice$1, this.structure);
          } else {
            return null;
          }
        };

        ReplaceStep.prototype.toJSON = function toJSON() {
          var json = { stepType: "replace", from: this.from, to: this.to };
          if (this.slice.size) {
            json.slice = this.slice.toJSON();
          }
          if (this.structure) {
            json.structure = true;
          }
          return json;
        };

        ReplaceStep.fromJSON = function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number") {
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
          }
          return new ReplaceStep(json.from, json.to, dist.Slice.fromJSON(schema, json.slice), !!json.structure);
        };

        return ReplaceStep;
      }(Step);

      Step.jsonID("replace", ReplaceStep);

      // ::- Replace a part of the document with a slice of content, but
      // preserve a range of the replaced content by moving it into the
      // slice.
      var ReplaceAroundStep = function (Step$$1) {
        function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {
          Step$$1.call(this);
          this.from = from;
          this.to = to;
          this.gapFrom = gapFrom;
          this.gapTo = gapTo;
          this.slice = slice;
          this.insert = insert;
          this.structure = !!structure;
        }

        if (Step$$1) ReplaceAroundStep.__proto__ = Step$$1;
        ReplaceAroundStep.prototype = Object.create(Step$$1 && Step$$1.prototype);
        ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;

        ReplaceAroundStep.prototype.apply = function apply(doc) {
          if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) {
            return StepResult.fail("Structure gap-replace would overwrite content");
          }

          var gap = doc.slice(this.gapFrom, this.gapTo);
          if (gap.openStart || gap.openEnd) {
            return StepResult.fail("Gap is not a flat range");
          }
          var inserted = this.slice.insertAt(this.insert, gap.content);
          if (!inserted) {
            return StepResult.fail("Content does not fit in gap");
          }
          return StepResult.fromReplace(doc, this.from, this.to, inserted);
        };

        ReplaceAroundStep.prototype.getMap = function getMap() {
          return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
        };

        ReplaceAroundStep.prototype.invert = function invert(doc) {
          var gap = this.gapTo - this.gapFrom;
          return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
        };

        ReplaceAroundStep.prototype.map = function map(mapping) {
          var from = mapping.mapResult(this.from, 1),
              to = mapping.mapResult(this.to, -1);
          var gapFrom = mapping.map(this.gapFrom, -1),
              gapTo = mapping.map(this.gapTo, 1);
          if (from.deleted && to.deleted || gapFrom < from.pos || gapTo > to.pos) {
            return null;
          }
          return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
        };

        ReplaceAroundStep.prototype.toJSON = function toJSON() {
          var json = { stepType: "replaceAround", from: this.from, to: this.to,
            gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert };
          if (this.slice.size) {
            json.slice = this.slice.toJSON();
          }
          if (this.structure) {
            json.structure = true;
          }
          return json;
        };

        ReplaceAroundStep.fromJSON = function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") {
            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
          }
          return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, dist.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
        };

        return ReplaceAroundStep;
      }(Step);

      Step.jsonID("replaceAround", ReplaceAroundStep);

      function contentBetween(doc, from, to) {
        var $from = doc.resolve(from),
            dist$$1 = to - from,
            depth = $from.depth;
        while (dist$$1 > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
          depth--;
          dist$$1--;
        }
        if (dist$$1 > 0) {
          var next = $from.node(depth).maybeChild($from.indexAfter(depth));
          while (dist$$1 > 0) {
            if (!next || next.isLeaf) {
              return true;
            }
            next = next.firstChild;
            dist$$1--;
          }
        }
        return false;
      }

      function canCut(node, start, end) {
        return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
      }

      // :: (NodeRange) → ?number
      // Try to find a target depth to which the content in the given range
      // can be lifted. Will not go across
      // [isolating](#model.NodeSpec.isolating) parent nodes.
      function liftTarget(range) {
        var parent = range.parent;
        var content = parent.content.cutByIndex(range.startIndex, range.endIndex);
        for (var depth = range.depth;; --depth) {
          var node = range.$from.node(depth);
          var index = range.$from.index(depth),
              endIndex = range.$to.indexAfter(depth);
          if (depth < range.depth && node.canReplace(index, endIndex, content)) {
            return depth;
          }
          if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) {
            break;
          }
        }
      }

      // :: (NodeRange, number) → this
      // Split the content in the given range off from its parent, if there
      // is sibling content before or after it, and move it up the tree to
      // the depth specified by `target`. You'll probably want to use
      // [`liftTarget`](#transform.liftTarget) to compute `target`, to make
      // sure the lift is valid.
      Transform.prototype.lift = function (range, target) {
        var $from = range.$from;
        var $to = range.$to;
        var depth = range.depth;

        var gapStart = $from.before(depth + 1),
            gapEnd = $to.after(depth + 1);
        var start = gapStart,
            end = gapEnd;

        var before = dist.Fragment.empty,
            openStart = 0;
        for (var d = depth, splitting = false; d > target; d--) {
          if (splitting || $from.index(d) > 0) {
            splitting = true;
            before = dist.Fragment.from($from.node(d).copy(before));
            openStart++;
          } else {
            start--;
          }
        }
        var after = dist.Fragment.empty,
            openEnd = 0;
        for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--) {
          if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
            splitting$1 = true;
            after = dist.Fragment.from($to.node(d$1).copy(after));
            openEnd++;
          } else {
            end++;
          }
        }

        return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new dist.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
      };

      // :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]
      // Try to find a valid way to wrap the content in the given range in a
      // node of the given type. May introduce extra nodes around and inside
      // the wrapper node, if necessary. Returns null if no valid wrapping
      // could be found. When `innerRange` is given, that range's content is
      // used as the content to fit into the wrapping, instead of the
      // content of `range`.
      function findWrapping(range, nodeType, attrs, innerRange) {
        if (innerRange === void 0) innerRange = range;

        var around = findWrappingOutside(range, nodeType);
        var inner = around && findWrappingInside(innerRange, nodeType);
        if (!inner) {
          return null;
        }
        return around.map(withAttrs).concat({ type: nodeType, attrs: attrs }).concat(inner.map(withAttrs));
      }

      function withAttrs(type) {
        return { type: type, attrs: null };
      }

      function findWrappingOutside(range, type) {
        var parent = range.parent;
        var startIndex = range.startIndex;
        var endIndex = range.endIndex;
        var around = parent.contentMatchAt(startIndex).findWrapping(type);
        if (!around) {
          return null;
        }
        var outer = around.length ? around[0] : type;
        return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
      }

      function findWrappingInside(range, type) {
        var parent = range.parent;
        var startIndex = range.startIndex;
        var endIndex = range.endIndex;
        var inner = parent.child(startIndex);
        var inside = type.contentMatch.findWrapping(inner.type);
        if (!inside) {
          return null;
        }
        var lastType = inside.length ? inside[inside.length - 1] : type;
        var innerMatch = lastType.contentMatch;
        for (var i = startIndex; innerMatch && i < endIndex; i++) {
          innerMatch = innerMatch.matchType(parent.child(i).type);
        }
        if (!innerMatch || !innerMatch.validEnd) {
          return null;
        }
        return inside;
      }

      // :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this
      // Wrap the given [range](#model.NodeRange) in the given set of wrappers.
      // The wrappers are assumed to be valid in this position, and should
      // probably be computed with [`findWrapping`](#transform.findWrapping).
      Transform.prototype.wrap = function (range, wrappers) {
        var content = dist.Fragment.empty;
        for (var i = wrappers.length - 1; i >= 0; i--) {
          content = dist.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
        }

        var start = range.start,
            end = range.end;
        return this.step(new ReplaceAroundStep(start, end, start, end, new dist.Slice(content, 0, 0), wrappers.length, true));
      };

      // :: (number, ?number, NodeType, ?Object) → this
      // Set the type of all textblocks (partly) between `from` and `to` to
      // the given node type with the given attributes.
      Transform.prototype.setBlockType = function (from, to, type, attrs) {
        var this$1 = this;
        if (to === void 0) to = from;

        if (!type.isTextblock) {
          throw new RangeError("Type given to setBlockType should be a textblock");
        }
        var mapFrom = this.steps.length;
        this.doc.nodesBetween(from, to, function (node, pos) {
          if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {
            // Ensure all markup that isn't allowed in the new node type is cleared
            this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);
            var mapping = this$1.mapping.slice(mapFrom);
            var startM = mapping.map(pos, 1),
                endM = mapping.map(pos + node.nodeSize, 1);
            this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new dist.Slice(dist.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
            return false;
          }
        });
        return this;
      };

      function canChangeType(doc, pos, type) {
        var $pos = doc.resolve(pos),
            index = $pos.index();
        return $pos.parent.canReplaceWith(index, index + 1, type);
      }

      // :: (number, ?NodeType, ?Object, ?[Mark]) → this
      // Change the type, attributes, and/or marks of the node at `pos`.
      // When `type` isn't given, the existing node type is preserved,
      Transform.prototype.setNodeMarkup = function (pos, type, attrs, marks) {
        var node = this.doc.nodeAt(pos);
        if (!node) {
          throw new RangeError("No node at given position");
        }
        if (!type) {
          type = node.type;
        }
        var newNode = type.create(attrs, null, marks || node.marks);
        if (node.isLeaf) {
          return this.replaceWith(pos, pos + node.nodeSize, newNode);
        }

        if (!type.validContent(node.content)) {
          throw new RangeError("Invalid content for node type " + type.name);
        }

        return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new dist.Slice(dist.Fragment.from(newNode), 0, 0), 1, true));
      };

      // :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool
      // Check whether splitting at the given position is allowed.
      function canSplit(doc, pos, depth, typesAfter) {
        if (depth === void 0) depth = 1;

        var $pos = doc.resolve(pos),
            base = $pos.depth - depth;
        var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
        if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) {
          return false;
        }
        for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
          var node = $pos.node(d),
              index$1 = $pos.index(d);
          if (node.type.spec.isolating) {
            return false;
          }
          var rest = node.content.cutByIndex(index$1, node.childCount);
          var after = typesAfter && typesAfter[i] || node;
          if (after != node) {
            rest = rest.replaceChild(0, after.type.create(after.attrs));
          }
          if (!node.canReplace(index$1 + 1, node.childCount) || !after.type.validContent(rest)) {
            return false;
          }
        }
        var index = $pos.indexAfter(base);
        var baseType = typesAfter && typesAfter[0];
        return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);
      }

      // :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this
      // Split the node at the given position, and optionally, if `depth` is
      // greater than one, any number of nodes above that. By default, the
      // parts split off will inherit the node type of the original node.
      // This can be changed by passing an array of types and attributes to
      // use after the split.
      Transform.prototype.split = function (pos, depth, typesAfter) {
        if (depth === void 0) depth = 1;

        var $pos = this.doc.resolve(pos),
            before = dist.Fragment.empty,
            after = dist.Fragment.empty;
        for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
          before = dist.Fragment.from($pos.node(d).copy(before));
          var typeAfter = typesAfter && typesAfter[i];
          after = dist.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
        }
        return this.step(new ReplaceStep(pos, pos, new dist.Slice(before.append(after), depth, depth, true)));
      };

      // :: (Node, number) → bool
      // Test whether the blocks before and after a given position can be
      // joined.
      function canJoin(doc, pos) {
        var $pos = doc.resolve(pos),
            index = $pos.index();
        return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
      }

      function joinable(a, b) {
        return a && b && !a.isLeaf && a.canAppend(b);
      }

      // :: (Node, number, ?number) → ?number
      // Find an ancestor of the given position that can be joined to the
      // block before (or after if `dir` is positive). Returns the joinable
      // point, if any.
      function joinPoint(doc, pos, dir) {
        if (dir === void 0) dir = -1;

        var $pos = doc.resolve(pos);
        for (var d = $pos.depth;; d--) {
          var before = void 0,
              after = void 0;
          if (d == $pos.depth) {
            before = $pos.nodeBefore;
            after = $pos.nodeAfter;
          } else if (dir > 0) {
            before = $pos.node(d + 1);
            after = $pos.node(d).maybeChild($pos.index(d) + 1);
          } else {
            before = $pos.node(d).maybeChild($pos.index(d) - 1);
            after = $pos.node(d + 1);
          }
          if (before && !before.isTextblock && joinable(before, after)) {
            return pos;
          }
          if (d == 0) {
            break;
          }
          pos = dir < 0 ? $pos.before(d) : $pos.after(d);
        }
      }

      // :: (number, ?number) → this
      // Join the blocks around the given position. If depth is 2, their
      // last and first siblings are also joined, and so on.
      Transform.prototype.join = function (pos, depth) {
        if (depth === void 0) depth = 1;

        var step = new ReplaceStep(pos - depth, pos + depth, dist.Slice.empty, true);
        return this.step(step);
      };

      // :: (Node, number, NodeType) → ?number
      // Try to find a point where a node of the given type can be inserted
      // near `pos`, by searching up the node hierarchy when `pos` itself
      // isn't a valid place but is at the start or end of a node. Return
      // null if no position was found.
      function insertPoint(doc, pos, nodeType) {
        var $pos = doc.resolve(pos);
        if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) {
          return pos;
        }

        if ($pos.parentOffset == 0) {
          for (var d = $pos.depth - 1; d >= 0; d--) {
            var index = $pos.index(d);
            if ($pos.node(d).canReplaceWith(index, index, nodeType)) {
              return $pos.before(d + 1);
            }
            if (index > 0) {
              return null;
            }
          }
        }
        if ($pos.parentOffset == $pos.parent.content.size) {
          for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
            var index$1 = $pos.indexAfter(d$1);
            if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) {
              return $pos.after(d$1 + 1);
            }
            if (index$1 < $pos.node(d$1).childCount) {
              return null;
            }
          }
        }
      }

      // :: (Node, number, Slice) → ?number
      // Finds a position at or around the given position where the given
      // slice can be inserted. Will look at parent nodes' nearest boundary
      // and try there, even if the original position wasn't directly at the
      // start or end of that node. Returns null when no position was found.
      function dropPoint(doc, pos, slice) {
        var $pos = doc.resolve(pos);
        if (!slice.content.size) {
          return pos;
        }
        var content = slice.content;
        for (var i = 0; i < slice.openStart; i++) {
          content = content.firstChild.content;
        }
        for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
          for (var d = $pos.depth; d >= 0; d--) {
            var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
            var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
            if (pass == 1 ? $pos.node(d).canReplace(insertPos, insertPos, content) : $pos.node(d).contentMatchAt(insertPos).findWrapping(content.firstChild.type)) {
              return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
            }
          }
        }
        return null;
      }

      function mapFragment(fragment, f, parent) {
        var mapped = [];
        for (var i = 0; i < fragment.childCount; i++) {
          var child = fragment.child(i);
          if (child.content.size) {
            child = child.copy(mapFragment(child.content, f, child));
          }
          if (child.isInline) {
            child = f(child, parent, i);
          }
          mapped.push(child);
        }
        return dist.Fragment.fromArray(mapped);
      }

      // ::- Add a mark to all inline content between two positions.
      var AddMarkStep = function (Step$$1) {
        function AddMarkStep(from, to, mark) {
          Step$$1.call(this);
          this.from = from;
          this.to = to;
          this.mark = mark;
        }

        if (Step$$1) AddMarkStep.__proto__ = Step$$1;
        AddMarkStep.prototype = Object.create(Step$$1 && Step$$1.prototype);
        AddMarkStep.prototype.constructor = AddMarkStep;

        AddMarkStep.prototype.apply = function apply(doc) {
          var this$1 = this;

          var oldSlice = doc.slice(this.from, this.to),
              $from = doc.resolve(this.from);
          var parent = $from.node($from.sharedDepth(this.to));
          var slice = new dist.Slice(mapFragment(oldSlice.content, function (node, parent) {
            if (!parent.type.allowsMarkType(this$1.mark.type)) {
              return node;
            }
            return node.mark(this$1.mark.addToSet(node.marks));
          }, parent), oldSlice.openStart, oldSlice.openEnd);
          return StepResult.fromReplace(doc, this.from, this.to, slice);
        };

        AddMarkStep.prototype.invert = function invert() {
          return new RemoveMarkStep(this.from, this.to, this.mark);
        };

        AddMarkStep.prototype.map = function map(mapping) {
          var from = mapping.mapResult(this.from, 1),
              to = mapping.mapResult(this.to, -1);
          if (from.deleted && to.deleted || from.pos >= to.pos) {
            return null;
          }
          return new AddMarkStep(from.pos, to.pos, this.mark);
        };

        AddMarkStep.prototype.merge = function merge(other) {
          if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
            return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
          }
        };

        AddMarkStep.prototype.toJSON = function toJSON() {
          return { stepType: "addMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to };
        };

        AddMarkStep.fromJSON = function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number") {
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
          }
          return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
        };

        return AddMarkStep;
      }(Step);

      Step.jsonID("addMark", AddMarkStep);

      // ::- Remove a mark from all inline content between two positions.
      var RemoveMarkStep = function (Step$$1) {
        function RemoveMarkStep(from, to, mark) {
          Step$$1.call(this);
          this.from = from;
          this.to = to;
          this.mark = mark;
        }

        if (Step$$1) RemoveMarkStep.__proto__ = Step$$1;
        RemoveMarkStep.prototype = Object.create(Step$$1 && Step$$1.prototype);
        RemoveMarkStep.prototype.constructor = RemoveMarkStep;

        RemoveMarkStep.prototype.apply = function apply(doc) {
          var this$1 = this;

          var oldSlice = doc.slice(this.from, this.to);
          var slice = new dist.Slice(mapFragment(oldSlice.content, function (node) {
            return node.mark(this$1.mark.removeFromSet(node.marks));
          }), oldSlice.openStart, oldSlice.openEnd);
          return StepResult.fromReplace(doc, this.from, this.to, slice);
        };

        RemoveMarkStep.prototype.invert = function invert() {
          return new AddMarkStep(this.from, this.to, this.mark);
        };

        RemoveMarkStep.prototype.map = function map(mapping) {
          var from = mapping.mapResult(this.from, 1),
              to = mapping.mapResult(this.to, -1);
          if (from.deleted && to.deleted || from.pos >= to.pos) {
            return null;
          }
          return new RemoveMarkStep(from.pos, to.pos, this.mark);
        };

        RemoveMarkStep.prototype.merge = function merge(other) {
          if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
            return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
          }
        };

        RemoveMarkStep.prototype.toJSON = function toJSON() {
          return { stepType: "removeMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to };
        };

        RemoveMarkStep.fromJSON = function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number") {
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
          }
          return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
        };

        return RemoveMarkStep;
      }(Step);

      Step.jsonID("removeMark", RemoveMarkStep);

      // :: (number, number, Mark) → this
      // Add the given mark to the inline content between `from` and `to`.
      Transform.prototype.addMark = function (from, to, mark) {
        var this$1 = this;

        var removed = [],
            added = [],
            removing = null,
            adding = null;
        this.doc.nodesBetween(from, to, function (node, pos, parent) {
          if (!node.isInline) {
            return;
          }
          var marks = node.marks;
          if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
            var start = Math.max(pos, from),
                end = Math.min(pos + node.nodeSize, to);
            var newSet = mark.addToSet(marks);

            for (var i = 0; i < marks.length; i++) {
              if (!marks[i].isInSet(newSet)) {
                if (removing && removing.to == start && removing.mark.eq(marks[i])) {
                  removing.to = end;
                } else {
                  removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
                }
              }
            }

            if (adding && adding.to == start) {
              adding.to = end;
            } else {
              added.push(adding = new AddMarkStep(start, end, mark));
            }
          }
        });

        removed.forEach(function (s) {
          return this$1.step(s);
        });
        added.forEach(function (s) {
          return this$1.step(s);
        });
        return this;
      };

      // :: (number, number, ?union<Mark, MarkType>) → this
      // Remove marks from inline nodes between `from` and `to`. When `mark`
      // is a single mark, remove precisely that mark. When it is a mark type,
      // remove all marks of that type. When it is null, remove all marks of
      // any type.
      Transform.prototype.removeMark = function (from, to, mark) {
        var this$1 = this;
        if (mark === void 0) mark = null;

        var matched = [],
            step = 0;
        this.doc.nodesBetween(from, to, function (node, pos) {
          if (!node.isInline) {
            return;
          }
          step++;
          var toRemove = null;
          if (mark instanceof dist.MarkType) {
            var found = mark.isInSet(node.marks);
            if (found) {
              toRemove = [found];
            }
          } else if (mark) {
            if (mark.isInSet(node.marks)) {
              toRemove = [mark];
            }
          } else {
            toRemove = node.marks;
          }
          if (toRemove && toRemove.length) {
            var end = Math.min(pos + node.nodeSize, to);
            for (var i = 0; i < toRemove.length; i++) {
              var style = toRemove[i],
                  found$1 = void 0;
              for (var j = 0; j < matched.length; j++) {
                var m = matched[j];
                if (m.step == step - 1 && style.eq(matched[j].style)) {
                  found$1 = m;
                }
              }
              if (found$1) {
                found$1.to = end;
                found$1.step = step;
              } else {
                matched.push({ style: style, from: Math.max(pos, from), to: end, step: step });
              }
            }
          }
        });
        matched.forEach(function (m) {
          return this$1.step(new RemoveMarkStep(m.from, m.to, m.style));
        });
        return this;
      };

      // :: (number, NodeType, ?ContentMatch) → this
      // Removes all marks and nodes from the content of the node at `pos`
      // that don't match the given new parent node type. Accepts an
      // optional starting [content match](#model.ContentMatch) as third
      // argument.
      Transform.prototype.clearIncompatible = function (pos, parentType, match) {
        var this$1 = this;
        if (match === void 0) match = parentType.contentMatch;

        var node = this.doc.nodeAt(pos);
        var delSteps = [],
            cur = pos + 1;
        for (var i = 0; i < node.childCount; i++) {
          var child = node.child(i),
              end = cur + child.nodeSize;
          var allowed = match.matchType(child.type, child.attrs);
          if (!allowed) {
            delSteps.push(new ReplaceStep(cur, end, dist.Slice.empty));
          } else {
            match = allowed;
            for (var j = 0; j < child.marks.length; j++) {
              if (!parentType.allowsMarkType(child.marks[j].type)) {
                this$1.step(new RemoveMarkStep(cur, end, child.marks[j]));
              }
            }
          }
          cur = end;
        }
        if (!match.validEnd) {
          var fill = match.fillBefore(dist.Fragment.empty, true);
          this.replace(cur, cur, new dist.Slice(fill, 0, 0));
        }
        for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
          this$1.step(delSteps[i$1]);
        }
        return this;
      };

      // :: (Node, number, ?number, ?Slice) → ?Step
      // ‘Fit’ a slice into a given position in the document, producing a
      // [step](#transform.Step) that inserts it. Will return null if
      // there's no meaningful way to insert the slice here, or inserting it
      // would be a no-op (an empty slice over an empty range).
      function replaceStep(doc, from, to, slice) {
        if (to === void 0) to = from;
        if (slice === void 0) slice = dist.Slice.empty;

        if (from == to && !slice.size) {
          return null;
        }

        var $from = doc.resolve(from),
            $to = doc.resolve(to);
        // Optimization -- avoid work if it's obvious that it's not needed.
        if (fitsTrivially($from, $to, slice)) {
          return new ReplaceStep(from, to, slice);
        }
        var placed = placeSlice($from, slice);

        var fittedLeft = fitLeft($from, placed);
        var fitted = fitRight($from, $to, fittedLeft);
        if (!fitted) {
          return null;
        }
        if (fittedLeft.size != fitted.size && canMoveText($from, $to, fittedLeft)) {
          var d = $to.depth,
              after = $to.after(d);
          while (d > 1 && after == $to.end(--d)) {
            ++after;
          }
          var fittedAfter = fitRight($from, doc.resolve(after), fittedLeft);
          if (fittedAfter) {
            return new ReplaceAroundStep(from, after, to, $to.end(), fittedAfter, fittedLeft.size);
          }
        }
        return fitted.size || from != to ? new ReplaceStep(from, to, fitted) : null;
      }

      // :: (number, ?number, ?Slice) → this
      // Replace the part of the document between `from` and `to` with the
      // given `slice`.
      Transform.prototype.replace = function (from, to, slice) {
        if (to === void 0) to = from;
        if (slice === void 0) slice = dist.Slice.empty;

        var step = replaceStep(this.doc, from, to, slice);
        if (step) {
          this.step(step);
        }
        return this;
      };

      // :: (number, number, union<Fragment, Node, [Node]>) → this
      // Replace the given range with the given content, which may be a
      // fragment, node, or array of nodes.
      Transform.prototype.replaceWith = function (from, to, content) {
        return this.replace(from, to, new dist.Slice(dist.Fragment.from(content), 0, 0));
      };

      // :: (number, number) → this
      // Delete the content between the given positions.
      Transform.prototype.delete = function (from, to) {
        return this.replace(from, to, dist.Slice.empty);
      };

      // :: (number, union<Fragment, Node, [Node]>) → this
      // Insert the given content at the given position.
      Transform.prototype.insert = function (pos, content) {
        return this.replaceWith(pos, pos, content);
      };

      function fitLeftInner($from, depth, placed, placedBelow) {
        var content = dist.Fragment.empty,
            openEnd = 0,
            placedHere = placed[depth];
        if ($from.depth > depth) {
          var inner = fitLeftInner($from, depth + 1, placed, placedBelow || placedHere);
          openEnd = inner.openEnd + 1;
          content = dist.Fragment.from($from.node(depth + 1).copy(inner.content));
        }

        if (placedHere) {
          content = content.append(placedHere.content);
          openEnd = placedHere.openEnd;
        }
        if (placedBelow) {
          content = content.append($from.node(depth).contentMatchAt($from.indexAfter(depth)).fillBefore(dist.Fragment.empty, true));
          openEnd = 0;
        }

        return { content: content, openEnd: openEnd };
      }

      function fitLeft($from, placed) {
        var ref = fitLeftInner($from, 0, placed, false);
        var content = ref.content;
        var openEnd = ref.openEnd;
        return new dist.Slice(content, $from.depth, openEnd || 0);
      }

      function fitRightJoin(content, parent, $from, $to, depth, openStart, openEnd) {
        var match,
            count = content.childCount,
            matchCount = count - (openEnd > 0 ? 1 : 0);
        var parentNode = openStart < 0 ? parent : $from.node(depth);
        if (openStart < 0) {
          match = parentNode.contentMatchAt(matchCount);
        } else if (count == 1 && openEnd > 0) {
          match = parentNode.contentMatchAt(openStart ? $from.index(depth) : $from.indexAfter(depth));
        } else {
          match = parentNode.contentMatchAt($from.indexAfter(depth)).matchFragment(content, count > 0 && openStart ? 1 : 0, matchCount);
        }

        var toNode = $to.node(depth);
        if (openEnd > 0 && depth < $to.depth) {
          var after = toNode.content.cutByIndex($to.indexAfter(depth)).addToStart(content.lastChild);
          var joinable$1 = match.fillBefore(after, true);
          // Can't insert content if there's a single node stretched across this gap
          if (joinable$1 && joinable$1.size && openStart > 0 && count == 1) {
            joinable$1 = null;
          }

          if (joinable$1) {
            var inner = fitRightJoin(content.lastChild.content, content.lastChild, $from, $to, depth + 1, count == 1 ? openStart - 1 : -1, openEnd - 1);
            if (inner) {
              var last = content.lastChild.copy(inner);
              if (joinable$1.size) {
                return content.cutByIndex(0, count - 1).append(joinable$1).addToEnd(last);
              } else {
                return content.replaceChild(count - 1, last);
              }
            }
          }
        }
        if (openEnd > 0) {
          match = match.matchType((count == 1 && openStart > 0 ? $from.node(depth + 1) : content.lastChild).type);
        }

        // If we're here, the next level can't be joined, so we see what
        // happens if we leave it open.
        var toIndex = $to.index(depth);
        if (toIndex == toNode.childCount && !toNode.type.compatibleContent(parent.type)) {
          return null;
        }
        var joinable = match.fillBefore(toNode.content, true, toIndex);
        for (var i = toIndex; joinable && i < toNode.content.childCount; i++) {
          if (!parentNode.type.allowsMarks(toNode.content.child(i).marks)) {
            joinable = null;
          }
        }
        if (!joinable) {
          return null;
        }

        if (openEnd > 0) {
          var closed = fitRightClosed(content.lastChild, openEnd - 1, $from, depth + 1, count == 1 ? openStart - 1 : -1);
          content = content.replaceChild(count - 1, closed);
        }
        content = content.append(joinable);
        if ($to.depth > depth) {
          content = content.addToEnd(fitRightSeparate($to, depth + 1));
        }
        return content;
      }

      function fitRightClosed(node, openEnd, $from, depth, openStart) {
        var match,
            content = node.content,
            count = content.childCount;
        if (openStart >= 0) {
          match = $from.node(depth).contentMatchAt($from.indexAfter(depth)).matchFragment(content, openStart > 0 ? 1 : 0, count);
        } else {
          match = node.contentMatchAt(count);
        }

        if (openEnd > 0) {
          var closed = fitRightClosed(content.lastChild, openEnd - 1, $from, depth + 1, count == 1 ? openStart - 1 : -1);
          content = content.replaceChild(count - 1, closed);
        }

        return node.copy(content.append(match.fillBefore(dist.Fragment.empty, true)));
      }

      function fitRightSeparate($to, depth) {
        var node = $to.node(depth);
        var fill = node.contentMatchAt(0).fillBefore(node.content, true, $to.index(depth));
        if ($to.depth > depth) {
          fill = fill.addToEnd(fitRightSeparate($to, depth + 1));
        }
        return node.copy(fill);
      }

      function normalizeSlice(content, openStart, openEnd) {
        while (openStart > 0 && openEnd > 0 && content.childCount == 1) {
          content = content.firstChild.content;
          openStart--;
          openEnd--;
        }
        return new dist.Slice(content, openStart, openEnd);
      }

      // : (ResolvedPos, ResolvedPos, number, Slice) → Slice
      function fitRight($from, $to, slice) {
        var fitted = fitRightJoin(slice.content, $from.node(0), $from, $to, 0, slice.openStart, slice.openEnd);
        if (!fitted) {
          return null;
        }
        return normalizeSlice(fitted, slice.openStart, $to.depth);
      }

      function fitsTrivially($from, $to, slice) {
        return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
      }

      function canMoveText($from, $to, slice) {
        if (!$to.parent.isTextblock) {
          return false;
        }

        var parent = slice.openEnd ? nodeRight(slice.content, slice.openEnd) : $from.node($from.depth - (slice.openStart - slice.openEnd));
        if (!parent.isTextblock) {
          return false;
        }
        for (var i = $to.index(); i < $to.parent.childCount; i++) {
          if (!parent.type.allowsMarks($to.parent.child(i).marks)) {
            return false;
          }
        }
        var match;
        if (slice.openEnd) {
          match = parent.contentMatchAt(parent.childCount);
        } else {
          match = parent.contentMatchAt(parent.childCount);
          if (slice.size) {
            match = match.matchFragment(slice.content, slice.openStart ? 1 : 0);
          }
        }
        match = match.matchFragment($to.parent.content, $to.index());
        return match && match.validEnd;
      }

      function nodeRight(content, depth) {
        for (var i = 1; i < depth; i++) {
          content = content.lastChild.content;
        }
        return content.lastChild;
      }

      // Algorithm for 'placing' the elements of a slice into a gap:
      //
      // We consider the content of each node that is open to the left to be
      // independently placeable. I.e. in <p("foo"), p("bar")>, when the
      // paragraph on the left is open, "foo" can be placed (somewhere on
      // the left side of the replacement gap) independently from p("bar").
      //
      // So placeSlice splits up a slice into a number of sub-slices,
      // along with information on where they can be placed on the given
      // left-side edge. It works by walking the open side of the slice,
      // from the inside out, and trying to find a landing spot for each
      // element, by simultaneously scanning over the gap side. When no
      // place is found for an open node's content, it is left in that node.

      // : (ResolvedPos, Slice) → [{content: Fragment, openEnd: number, depth: number}]
      function placeSlice($from, slice) {
        var frontier = new Frontier($from);
        for (var pass = 1; slice.size && pass <= 3; pass++) {
          slice = frontier.placeSlice(slice.content, slice.openStart, slice.openEnd, pass);
        }
        while (frontier.open.length) {
          frontier.closeNode();
        }
        return frontier.placed;
      }

      // Helper class that models the open side of the insert position,
      // keeping track of the content match and already inserted content
      // at each depth.
      var Frontier = function Frontier($pos) {
        var this$1 = this;

        // : [{parent: Node, match: ContentMatch, content: Fragment, wrapper: bool, openEnd: number, depth: number}]
        this.open = [];
        for (var d = 0; d <= $pos.depth; d++) {
          var parent = $pos.node(d),
              match = parent.contentMatchAt($pos.indexAfter(d));
          this$1.open.push({ parent: parent, match: match, content: dist.Fragment.empty, wrapper: false, openEnd: 0, depth: d });
        }
        this.placed = [];
      };

      // : (Fragment, number, number, number, ?Node) → Slice
      // Tries to place the content of the given slice, and returns a
      // slice containing unplaced content.
      //
      // pass 1: try to fit directly
      // pass 2: allow wrapper nodes to be introduced
      // pass 3: allow unwrapping of nodes that aren't open
      Frontier.prototype.placeSlice = function placeSlice(fragment, openStart, openEnd, pass, parent) {
        var this$1 = this;

        if (openStart > 0) {
          var first = fragment.firstChild;
          var inner = this.placeSlice(first.content, Math.max(0, openStart - 1), openEnd && fragment.childCount == 1 ? openEnd - 1 : 0, pass, first);
          if (inner.content != first.content) {
            if (inner.content.size) {
              fragment = fragment.replaceChild(0, first.copy(inner.content));
              openStart = inner.openStart + 1;
            } else {
              if (fragment.childCount == 1) {
                openEnd = 0;
              }
              fragment = fragment.cutByIndex(1);
              openStart = 0;
            }
          }
        }
        var result = this.placeContent(fragment, openStart, openEnd, pass, parent);
        if (pass > 2 && result.size && openStart == 0) {
          for (var i = 0; i < result.content.childCount; i++) {
            var child = result.content.child(i);
            this$1.placeContent(child.content, 0, openEnd && i == result.content.childCount.length - 1 ? openEnd - 1 : 0, pass, child);
          }
          result = dist.Fragment.empty;
        }
        return result;
      };

      Frontier.prototype.placeContent = function placeContent(fragment, openStart, openEnd, pass, parent) {
        var this$1 = this;

        var i = 0;
        // Go over the fragment's children
        for (; i < fragment.childCount; i++) {
          var child = fragment.child(i),
              placed = false,
              last = i == fragment.childCount - 1;
          // Try each open node in turn, starting from the innermost
          for (var d = this.open.length - 1; d >= 0; d--) {
            var open = this$1.open[d],
                wrap = void 0;

            // If pass > 1, it is allowed to wrap the node to help find a
            // fit, so if findWrappeing returns something, we add open
            // nodes to the frontier for that wrapping.
            if (pass > 1 && (wrap = open.match.findWrapping(child.type)) && !(parent && wrap.length && wrap[wrap.length - 1] == parent.type)) {
              while (this.open.length - 1 > d) {
                this$1.closeNode();
              }
              for (var w = 0; w < wrap.length; w++) {
                open.match = open.match.matchType(wrap[w]);
                d++;
                open = { parent: wrap[w].create(),
                  match: wrap[w].contentMatch,
                  content: dist.Fragment.empty, wrapper: true, openEnd: 0, depth: d + w };
                this$1.open.push(open);
              }
            }

            // See if the child fits here
            var match = open.match.matchType(child.type);
            if (!match) {
              var fill = open.match.fillBefore(dist.Fragment.from(child));
              if (fill) {
                for (var j = 0; j < fill.childCount; j++) {
                  var ch = fill.child(j);
                  this$1.addNode(open, ch, 0);
                  match = open.match.matchFragment(ch);
                }
              } else if (parent && open.match.matchType(parent.type)) {
                // Don't continue looking further up if the parent node
                // would fit here.
                break;
              } else {
                continue;
              }
            }

            // Close open nodes above this one, since we're starting to
            // add to this.
            while (this.open.length - 1 > d) {
              this$1.closeNode();
            }
            // Strip marks from the child or close its start when necessary
            child = child.mark(open.parent.type.allowedMarks(child.marks));
            if (openStart) {
              child = closeNodeStart(child, openStart, last ? openEnd : 0);
              openStart = 0;
            }
            // Add the child to this open node and adjust its metadata
            this$1.addNode(open, child, last ? openEnd : 0);
            open.match = match;
            if (last) {
              openEnd = 0;
            }
            placed = true;
            break;
          }
          // As soon as we've failed to place a node we stop looking at
          // later nodes
          if (!placed) {
            break;
          }
        }
        // Close the current open node if it's not the the root and we
        // either placed up to the end of the node or the the current
        // slice depth's node type matches the open node's type
        if (this.open.length > 1 && (i > 0 && i == fragment.childCount || parent && this.open[this.open.length - 1].parent.type == parent.type)) {
          this.closeNode();
        }

        return new dist.Slice(fragment.cutByIndex(i), openStart, openEnd);
      };

      Frontier.prototype.addNode = function addNode(open, node, openEnd) {
        open.content = closeFragmentEnd(open.content, open.openEnd).addToEnd(node);
        open.openEnd = openEnd;
      };

      Frontier.prototype.closeNode = function closeNode() {
        var open = this.open.pop();
        if (open.content.size == 0) {
          // Nothing here
        } else if (open.wrapper) {
          this.addNode(this.open[this.open.length - 1], open.parent.copy(open.content), open.openEnd + 1);
        } else {
          this.placed[open.depth] = { depth: open.depth, content: open.content, openEnd: open.openEnd };
        }
      };

      function closeNodeStart(node, openStart, openEnd) {
        var content = node.content;
        if (openStart > 1) {
          var first = closeNodeStart(node.firstChild, openStart - 1, node.childCount == 1 ? openEnd - 1 : 0);
          content = node.content.replaceChild(0, first);
        }
        var fill = node.type.contentMatch.fillBefore(content, openEnd == 0);
        return node.copy(fill.append(content));
      }

      function closeNodeEnd(node, depth) {
        var content = node.content;
        if (depth > 1) {
          var last = closeNodeEnd(node.lastChild, depth - 1);
          content = node.content.replaceChild(node.childCount - 1, last);
        }
        var fill = node.contentMatchAt(node.childCount).fillBefore(dist.Fragment.empty, true);
        return node.copy(content.append(fill));
      }

      function closeFragmentEnd(fragment, depth) {
        return depth ? fragment.replaceChild(fragment.childCount - 1, closeNodeEnd(fragment.lastChild, depth)) : fragment;
      }

      // :: (number, number, Slice) → this
      // Replace a range of the document with a given slice, using `from`,
      // `to`, and the slice's [`openStart`](#model.Slice.openStart) property
      // as hints, rather than fixed start and end points. This method may
      // grow the replaced area or close open nodes in the slice in order to
      // get a fit that is more in line with WYSIWYG expectations, by
      // dropping fully covered parent nodes of the replaced region when
      // they are marked [non-defining](#model.NodeSpec.defining), or
      // including an open parent node from the slice that _is_ marked as
      // [defining](#model.NodeSpec.defining).
      //
      // This is the method, for example, to handle paste. The similar
      // [`replace`](#transform.Transform.replace) method is a more
      // primitive tool which will _not_ move the start and end of its given
      // range, and is useful in situations where you need more precise
      // control over what happens.
      Transform.prototype.replaceRange = function (from, to, slice) {
        var this$1 = this;

        if (!slice.size) {
          return this.deleteRange(from, to);
        }

        var $from = this.doc.resolve(from),
            $to = this.doc.resolve(to);
        if (fitsTrivially($from, $to, slice)) {
          return this.step(new ReplaceStep(from, to, slice));
        }

        var targetDepths = coveredDepths($from, this.doc.resolve(to));
        // Can't replace the whole document, so remove 0 if it's present
        if (targetDepths[targetDepths.length - 1] == 0) {
          targetDepths.pop();
        }
        // Negative numbers represent not expansion over the whole node at
        // that depth, but replacing from $from.before(-D) to $to.pos.
        var preferredTarget = -($from.depth + 1);
        targetDepths.unshift(preferredTarget);
        // This loop picks a preferred target depth, if one of the covering
        // depths is not outside of a defining node, and adds negative
        // depths for any depth that has $from at its start and does not
        // cross a defining node.
        for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
          var spec = $from.node(d).type.spec;
          if (spec.defining || spec.isolating) {
            break;
          }
          if (targetDepths.indexOf(d) > -1) {
            preferredTarget = d;
          } else if ($from.before(d) == pos) {
            targetDepths.splice(1, 0, -d);
          }
        }
        // Try to fit each possible depth of the slice into each possible
        // target depth, starting with the preferred depths.
        var preferredTargetIndex = targetDepths.indexOf(preferredTarget);

        var leftNodes = [],
            preferredDepth = slice.openStart;
        for (var content = slice.content, i = 0;; i++) {
          var node = content.firstChild;
          leftNodes.push(node);
          if (i == slice.openStart) {
            break;
          }
          content = node.content;
        }
        // Back up if the node directly above openStart, or the node above
        // that separated only by a non-defining textblock node, is defining.
        if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
          preferredDepth -= 1;
        } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
          preferredDepth -= 2;
        }

        for (var j = slice.openStart; j >= 0; j--) {
          var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
          var insert = leftNodes[openDepth];
          if (!insert) {
            continue;
          }
          for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
            // Loop over possible expansion levels, starting with the
            // preferred one
            var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length],
                expand = true;
            if (targetDepth < 0) {
              expand = false;targetDepth = -targetDepth;
            }
            var parent = $from.node(targetDepth - 1),
                index = $from.index(targetDepth - 1);
            if (parent.canReplaceWith(index, index, insert.type, insert.marks)) {
              return this$1.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new dist.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
            }
          }
        }

        return this.replace(from, to, slice);
      };

      function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
        if (depth < oldOpen) {
          var first = fragment.firstChild;
          fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
        }
        if (depth > newOpen) {
          fragment = parent.contentMatchAt(0).fillBefore(fragment, true).append(fragment);
        }
        return fragment;
      }

      // :: (number, number, Node) → this
      // Replace the given range with a node, but use `from` and `to` as
      // hints, rather than precise positions. When from and to are the same
      // and are at the start or end of a parent node in which the given
      // node doesn't fit, this method may _move_ them out towards a parent
      // that does allow the given node to be placed. When the given range
      // completely covers a parent node, this method may completely replace
      // that parent node.
      Transform.prototype.replaceRangeWith = function (from, to, node) {
        if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {
          var point = insertPoint(this.doc, from, node.type);
          if (point != null) {
            from = to = point;
          }
        }
        return this.replaceRange(from, to, new dist.Slice(dist.Fragment.from(node), 0, 0));
      };

      // :: (number, number) → this
      // Delete the given range, expanding it to cover fully covered
      // parent nodes until a valid replace is found.
      Transform.prototype.deleteRange = function (from, to) {
        var this$1 = this;

        var $from = this.doc.resolve(from),
            $to = this.doc.resolve(to);
        var covered = coveredDepths($from, $to);
        for (var i = 0; i < covered.length; i++) {
          var depth = covered[i],
              last = i == covered.length - 1;
          if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
            return this$1.delete($from.start(depth), $to.end(depth));
          }
          if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
            return this$1.delete($from.before(depth), $to.after(depth));
          }
        }
        for (var d = 1; d <= $from.depth; d++) {
          if (from - $from.start(d) == $from.depth - d && to > $from.end(d)) {
            return this$1.delete($from.before(d), to);
          }
        }
        return this.delete(from, to);
      };

      // : (ResolvedPos, ResolvedPos) → [number]
      // Returns an array of all depths for which $from - $to spans the
      // whole content of the nodes at that depth.
      function coveredDepths($from, $to) {
        var result = [],
            minDepth = Math.min($from.depth, $to.depth);
        for (var d = minDepth; d >= 0; d--) {
          var start = $from.start(d);
          if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {
            break;
          }
          if (start == $to.start(d)) {
            result.push(d);
          }
        }
        return result;
      }

      exports.Transform = Transform;
      exports.TransformError = TransformError;
      exports.Step = Step;
      exports.StepResult = StepResult;
      exports.joinPoint = joinPoint;
      exports.canJoin = canJoin;
      exports.canSplit = canSplit;
      exports.insertPoint = insertPoint;
      exports.dropPoint = dropPoint;
      exports.liftTarget = liftTarget;
      exports.findWrapping = findWrapping;
      exports.StepMap = StepMap;
      exports.MapResult = MapResult;
      exports.Mapping = Mapping;
      exports.AddMarkStep = AddMarkStep;
      exports.RemoveMarkStep = RemoveMarkStep;
      exports.ReplaceStep = ReplaceStep;
      exports.ReplaceAroundStep = ReplaceAroundStep;
      exports.replaceStep = replaceStep;
      
    });

    unwrapExports(dist$1);
    var dist_1$1 = dist$1.Transform;
    var dist_2$1 = dist$1.TransformError;
    var dist_3$1 = dist$1.Step;
    var dist_4$1 = dist$1.StepResult;
    var dist_5$1 = dist$1.joinPoint;
    var dist_6$1 = dist$1.canJoin;
    var dist_7$1 = dist$1.canSplit;
    var dist_8$1 = dist$1.insertPoint;
    var dist_9$1 = dist$1.dropPoint;
    var dist_10$1 = dist$1.liftTarget;
    var dist_11$1 = dist$1.findWrapping;
    var dist_12$1 = dist$1.StepMap;
    var dist_13$1 = dist$1.MapResult;
    var dist_14 = dist$1.Mapping;
    var dist_15 = dist$1.AddMarkStep;
    var dist_16 = dist$1.RemoveMarkStep;
    var dist_17 = dist$1.ReplaceStep;
    var dist_18 = dist$1.ReplaceAroundStep;
    var dist_19 = dist$1.replaceStep;

    var dist$2 = createCommonjsModule(function (module, exports) {

      Object.defineProperty(exports, '__esModule', { value: true });

      var classesById = Object.create(null);

      // ::- Superclass for editor selections. Every selection type should
      // extend this. Should not be instantiated directly.
      var Selection = function Selection($anchor, $head, ranges) {
        // :: [SelectionRange]
        // The ranges covered by the selection.
        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
        // :: ResolvedPos
        // The resolved anchor of the selection (the side that stays in
        // place when the selection is modified).
        this.$anchor = $anchor;
        // :: ResolvedPos
        // The resolved head of the selection (the side that moves when
        // the selection is modified).
        this.$head = $head;
      };

      var prototypeAccessors = { anchor: {}, head: {}, from: {}, to: {}, $from: {}, $to: {}, empty: {} };

      // :: number
      // The selection's anchor, as an unresolved position.
      prototypeAccessors.anchor.get = function () {
        return this.$anchor.pos;
      };

      // :: number
      // The selection's head.
      prototypeAccessors.head.get = function () {
        return this.$head.pos;
      };

      // :: number
      // The lower bound of the selection's main range.
      prototypeAccessors.from.get = function () {
        return this.$from.pos;
      };

      // :: number
      // The upper bound of the selection's main range.
      prototypeAccessors.to.get = function () {
        return this.$to.pos;
      };

      // :: ResolvedPos
      // The resolved lowerbound of the selection's main range.
      prototypeAccessors.$from.get = function () {
        return this.ranges[0].$from;
      };

      // :: ResolvedPos
      // The resolved upper bound of the selection's main range.
      prototypeAccessors.$to.get = function () {
        return this.ranges[0].$to;
      };

      // :: bool
      // Indicates whether the selection contains any content.
      prototypeAccessors.empty.get = function () {
        var ranges = this.ranges;
        for (var i = 0; i < ranges.length; i++) {
          if (ranges[i].$from.pos != ranges[i].$to.pos) {
            return false;
          }
        }
        return true;
      };

      // eq:: (Selection) → bool
      // Test whether the selection is the same as another selection.

      // map:: (doc: Node, mapping: Mappable) → Selection
      // Map this selection through a [mappable](#transform.Mappable) thing. `doc`
      // should be the new document to which we are mapping.

      // :: () → Slice
      // Get the content of this selection as a slice.
      Selection.prototype.content = function content() {
        return this.$from.node(0).slice(this.from, this.to, true);
      };

      // :: (Transaction, ?Slice)
      // Replace the selection with a slice or, if no slice is given,
      // delete the selection. Will append to the given transaction.
      Selection.prototype.replace = function replace(tr, content) {
        if (content === void 0) content = dist.Slice.empty;

        // Put the new selection at the position after the inserted
        // content. When that ended in an inline node, search backwards,
        // to get the position after that node. If not, search forward.
        var lastNode = content.content.lastChild,
            lastParent = null;
        for (var i = 0; i < content.openEnd; i++) {
          lastParent = lastNode;
          lastNode = lastNode.lastChild;
        }

        var mapFrom = tr.steps.length,
            ranges = this.ranges;
        for (var i$1 = 0; i$1 < ranges.length; i$1++) {
          var ref = ranges[i$1];
          var $from = ref.$from;
          var $to = ref.$to;
          var mapping = tr.mapping.slice(mapFrom);
          tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? dist.Slice.empty : content);
          if (i$1 == 0) {
            selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
          }
        }
      };

      // :: (Transaction, Node)
      // Replace the selection with the given node, appending the changes
      // to the given transaction.
      Selection.prototype.replaceWith = function replaceWith(tr, node) {
        var mapFrom = tr.steps.length,
            ranges = this.ranges;
        for (var i = 0; i < ranges.length; i++) {
          var ref = ranges[i];
          var $from = ref.$from;
          var $to = ref.$to;
          var mapping = tr.mapping.slice(mapFrom);
          var from = mapping.map($from.pos),
              to = mapping.map($to.pos);
          if (i) {
            tr.deleteRange(from, to);
          } else {
            tr.replaceRangeWith(from, to, node);
            selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
          }
        }
      };

      // toJSON:: () → Object
      // Convert the selection to a JSON representation. When implementing
      // this for a custom selection class, make sure to give the object a
      // `type` property whose value matches the ID under which you
      // [registered](#state.Selection^jsonID) your class.

      // :: (ResolvedPos, number, ?bool) → ?Selection
      // Find a valid cursor or leaf node selection starting at the given
      // position and searching back if `dir` is negative, and forward if
      // positive. When `textOnly` is true, only consider cursor
      // selections. Will return null when no valid selection position is
      // found.
      Selection.findFrom = function findFrom($pos, dir, textOnly) {
        var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
        if (inner) {
          return inner;
        }

        for (var depth = $pos.depth - 1; depth >= 0; depth--) {
          var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
          if (found) {
            return found;
          }
        }
      };

      // :: (ResolvedPos, ?number) → Selection
      // Find a valid cursor or leaf node selection near the given
      // position. Searches forward first by default, but if `bias` is
      // negative, it will search backwards first.
      Selection.near = function near($pos, bias) {
        if (bias === void 0) bias = 1;

        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
      };

      // :: (Node) → Selection
      // Find the cursor or leaf node selection closest to the start of
      // the given document. Will return an
      // [`AllSelection`](#state.AllSelection) if no valid position
      // exists.
      Selection.atStart = function atStart(doc) {
        return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
      };

      // :: (Node) → Selection
      // Find the cursor or leaf node selection closest to the end of the
      // given document.
      Selection.atEnd = function atEnd(doc) {
        return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);
      };

      // :: (Node, Object) → Selection
      // Deserialize the JSON representation of a selection. Must be
      // implemented for custom classes (as a static class method).
      Selection.fromJSON = function fromJSON(doc, json) {
        if (!json || !json.type) {
          throw new RangeError("Invalid input for Selection.fromJSON");
        }
        var cls = classesById[json.type];
        if (!cls) {
          throw new RangeError("No selection type " + json.type + " defined");
        }
        return cls.fromJSON(doc, json);
      };

      // :: (string, constructor<Selection>)
      // To be able to deserialize selections from JSON, custom selection
      // classes must register themselves with an ID string, so that they
      // can be disambiguated. Try to pick something that's unlikely to
      // clash with classes from other modules.
      Selection.jsonID = function jsonID(id, selectionClass) {
        if (id in classesById) {
          throw new RangeError("Duplicate use of selection JSON ID " + id);
        }
        classesById[id] = selectionClass;
        selectionClass.prototype.jsonID = id;
        return selectionClass;
      };

      // :: () → SelectionBookmark
      // Get a [bookmark](#state.SelectionBookmark) for this selection,
      // which is a value that can be mapped without having access to a
      // current document, and later resolved to a real selection for a
      // given document again. (This is used mostly by the history to
      // track and restore old selections.) The default implementation of
      // this method just converts the selection to a text selection and
      // returns the bookmark for that.
      Selection.prototype.getBookmark = function getBookmark() {
        return TextSelection.between(this.$anchor, this.$head).getBookmark();
      };

      Object.defineProperties(Selection.prototype, prototypeAccessors);

      // :: bool
      // Controls whether, when a selection of this type is active in the
      // browser, the selected range should be visible to the user. Defaults
      // to `true`.
      Selection.prototype.visible = true;

      // SelectionBookmark:: interface
      // A lightweight, document-independent representation of a selection.
      // You can define a custom bookmark type for a custom selection class
      // to make the history handle it well.
      //
      //   map:: (mapping: Mapping) → SelectionBookmark
      //   Map the bookmark through a set of changes.
      //
      //   resolve:: (doc: Node) → Selection
      //   Resolve the bookmark to a real selection again. This may need to
      //   do some error checking and may fall back to a default (usually
      //   [`TextSelection.between`](#state.TextSelection^between)) if
      //   mapping made the bookmark invalid.

      // ::- Represents a selected range in a document.
      var SelectionRange = function SelectionRange($from, $to) {
        // :: ResolvedPos
        // The lower bound of the range.
        this.$from = $from;
        // :: ResolvedPos
        // The upper bound of the range.
        this.$to = $to;
      };

      // ::- A text selection represents a classical editor selection, with
      // a head (the moving side) and anchor (immobile side), both of which
      // point into textblock nodes. It can be empty (a regular cursor
      // position).
      var TextSelection = function (Selection) {
        function TextSelection($anchor, $head) {
          if ($head === void 0) $head = $anchor;

          Selection.call(this, $anchor, $head);
        }

        if (Selection) TextSelection.__proto__ = Selection;
        TextSelection.prototype = Object.create(Selection && Selection.prototype);
        TextSelection.prototype.constructor = TextSelection;

        var prototypeAccessors$1 = { $cursor: {} };

        // :: ?ResolvedPos
        // Returns a resolved position if this is a cursor selection (an
        // empty text selection), and null otherwise.
        prototypeAccessors$1.$cursor.get = function () {
          return this.$anchor.pos == this.$head.pos ? this.$head : null;
        };

        TextSelection.prototype.map = function map(doc, mapping) {
          var $head = doc.resolve(mapping.map(this.head));
          if (!$head.parent.inlineContent) {
            return Selection.near($head);
          }
          var $anchor = doc.resolve(mapping.map(this.anchor));
          return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
        };

        TextSelection.prototype.replace = function replace(tr, content) {
          if (content === void 0) content = dist.Slice.empty;

          Selection.prototype.replace.call(this, tr, content);
          if (content == dist.Slice.empty) {
            var marks = this.$from.marksAcross(this.$to);
            if (marks) {
              tr.ensureMarks(marks);
            }
          }
        };

        TextSelection.prototype.eq = function eq(other) {
          return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
        };

        TextSelection.prototype.getBookmark = function getBookmark() {
          return new TextBookmark(this.anchor, this.head);
        };

        TextSelection.prototype.toJSON = function toJSON() {
          return { type: "text", anchor: this.anchor, head: this.head };
        };

        TextSelection.fromJSON = function fromJSON(doc, json) {
          if (typeof json.anchor != "number" || typeof json.head != "number") {
            throw new RangeError("Invalid input for TextSelection.fromJSON");
          }
          return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));
        };

        // :: (Node, number, ?number) → TextSelection
        // Create a text selection from non-resolved positions.
        TextSelection.create = function create(doc, anchor, head) {
          if (head === void 0) head = anchor;

          var $anchor = doc.resolve(anchor);
          return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
        };

        // :: (ResolvedPos, ResolvedPos, ?number) → Selection
        // Return a text selection that spans the given positions or, if
        // they aren't text positions, find a text selection near them.
        // `bias` determines whether the method searches forward (default)
        // or backwards (negative number) first. Will fall back to calling
        // [`Selection.near`](#state.Selection^near) when the document
        // doesn't contain a valid text position.
        TextSelection.between = function between($anchor, $head, bias) {
          var dPos = $anchor.pos - $head.pos;
          if (!bias || dPos) {
            bias = dPos >= 0 ? 1 : -1;
          }
          if (!$head.parent.inlineContent) {
            var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
            if (found) {
              $head = found.$head;
            } else {
              return Selection.near($head, bias);
            }
          }
          if (!$anchor.parent.inlineContent) {
            if (dPos == 0) {
              $anchor = $head;
            } else {
              $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
              if ($anchor.pos < $head.pos != dPos < 0) {
                $anchor = $head;
              }
            }
          }
          return new TextSelection($anchor, $head);
        };

        Object.defineProperties(TextSelection.prototype, prototypeAccessors$1);

        return TextSelection;
      }(Selection);

      Selection.jsonID("text", TextSelection);

      var TextBookmark = function TextBookmark(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      };
      TextBookmark.prototype.map = function map(mapping) {
        return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
      };
      TextBookmark.prototype.resolve = function resolve(doc) {
        return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));
      };

      // ::- A node selection is a selection that points at a single node.
      // All nodes marked [selectable](#model.NodeSpec.selectable) can be
      // the target of a node selection. In such a selection, `from` and
      // `to` point directly before and after the selected node, `anchor`
      // equals `from`, and `head` equals `to`..
      var NodeSelection = function (Selection) {
        function NodeSelection($pos) {
          var node = $pos.nodeAfter;
          var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
          Selection.call(this, $pos, $end);
          // :: Node The selected node.
          this.node = node;
        }

        if (Selection) NodeSelection.__proto__ = Selection;
        NodeSelection.prototype = Object.create(Selection && Selection.prototype);
        NodeSelection.prototype.constructor = NodeSelection;

        NodeSelection.prototype.map = function map(doc, mapping) {
          var ref = mapping.mapResult(this.anchor);
          var deleted = ref.deleted;
          var pos = ref.pos;
          var $pos = doc.resolve(pos);
          if (deleted) {
            return Selection.near($pos);
          }
          return new NodeSelection($pos);
        };

        NodeSelection.prototype.content = function content() {
          return new dist.Slice(dist.Fragment.from(this.node), 0, 0);
        };

        NodeSelection.prototype.eq = function eq(other) {
          return other instanceof NodeSelection && other.anchor == this.anchor;
        };

        NodeSelection.prototype.toJSON = function toJSON() {
          return { type: "node", anchor: this.anchor };
        };

        NodeSelection.prototype.getBookmark = function getBookmark() {
          return new NodeBookmark(this.anchor);
        };

        NodeSelection.fromJSON = function fromJSON(doc, json) {
          if (typeof json.anchor != "number") {
            throw new RangeError("Invalid input for NodeSelection.fromJSON");
          }
          return new NodeSelection(doc.resolve(json.anchor));
        };

        // :: (Node, number) → NodeSelection
        // Create a node selection from non-resolved positions.
        NodeSelection.create = function create(doc, from) {
          return new this(doc.resolve(from));
        };

        // :: (Node) → bool
        // Determines whether the given node may be selected as a node
        // selection.
        NodeSelection.isSelectable = function isSelectable(node) {
          return !node.isText && node.type.spec.selectable !== false;
        };

        return NodeSelection;
      }(Selection);

      NodeSelection.prototype.visible = false;

      Selection.jsonID("node", NodeSelection);

      var NodeBookmark = function NodeBookmark(anchor) {
        this.anchor = anchor;
      };
      NodeBookmark.prototype.map = function map(mapping) {
        var ref = mapping.mapResult(this.anchor);
        var deleted = ref.deleted;
        var pos = ref.pos;
        return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
      };
      NodeBookmark.prototype.resolve = function resolve(doc) {
        var $pos = doc.resolve(this.anchor),
            node = $pos.nodeAfter;
        if (node && NodeSelection.isSelectable(node)) {
          return new NodeSelection($pos);
        }
        return Selection.near($pos);
      };

      // ::- A selection type that represents selecting the whole document
      // (which can not necessarily be expressed with a text selection, when
      // there are for example leaf block nodes at the start or end of the
      // document).
      var AllSelection = function (Selection) {
        function AllSelection(doc) {
          Selection.call(this, doc.resolve(0), doc.resolve(doc.content.size));
        }

        if (Selection) AllSelection.__proto__ = Selection;
        AllSelection.prototype = Object.create(Selection && Selection.prototype);
        AllSelection.prototype.constructor = AllSelection;

        AllSelection.prototype.toJSON = function toJSON() {
          return { type: "all" };
        };

        AllSelection.fromJSON = function fromJSON(doc) {
          return new AllSelection(doc);
        };

        AllSelection.prototype.map = function map(doc) {
          return new AllSelection(doc);
        };

        AllSelection.prototype.eq = function eq(other) {
          return other instanceof AllSelection;
        };

        AllSelection.prototype.getBookmark = function getBookmark() {
          return AllBookmark;
        };

        return AllSelection;
      }(Selection);

      Selection.jsonID("all", AllSelection);

      var AllBookmark = {
        map: function map() {
          return this;
        },
        resolve: function resolve(doc) {
          return new AllSelection(doc);
        }
      };

      // FIXME we'll need some awareness of text direction when scanning for selections

      // Try to find a selection inside the given node. `pos` points at the
      // position where the search starts. When `text` is true, only return
      // text selections.
      function findSelectionIn(doc, node, pos, index, dir, text) {
        if (node.inlineContent) {
          return TextSelection.create(doc, pos);
        }
        for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
          var child = node.child(i);
          if (!child.isAtom) {
            var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
            if (inner) {
              return inner;
            }
          } else if (!text && NodeSelection.isSelectable(child)) {
            return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
          }
          pos += child.nodeSize * dir;
        }
      }

      function selectionToInsertionEnd(tr, startLen, bias) {
        var last = tr.steps.length - 1;
        if (last < startLen) {
          return;
        }
        var step = tr.steps[last];
        if (!(step instanceof dist$1.ReplaceStep || step instanceof dist$1.ReplaceAroundStep)) {
          return;
        }
        var map = tr.mapping.maps[last],
            end;
        map.forEach(function (_from, _to, _newFrom, newTo) {
          if (end == null) {
            end = newTo;
          }
        });
        tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
      }

      var UPDATED_SEL = 1;
      var UPDATED_MARKS = 2;
      var UPDATED_SCROLL = 4;

      // ::- An editor state transaction, which can be applied to a state to
      // create an updated state. Use
      // [`EditorState.tr`](#state.EditorState.tr) to create an instance.
      //
      // Transactions track changes to the document (they are a subclass of
      // [`Transform`](#transform.Transform)), but also other state changes,
      // like selection updates and adjustments of the set of [stored
      // marks](#state.EditorState.storedMarks). In addition, you can store
      // metadata properties in a transaction, which are extra pieces of
      // information that client code or plugins can use to describe what a
      // transacion represents, so that they can update their [own
      // state](#state.StateField) accordingly.
      //
      // The [editor view](#view.EditorView) uses a few metadata properties:
      // it will attach a property `"pointer"` with the value `true` to
      // selection transactions directly caused by mouse or touch input, and
      // a `"uiEvent"` property of that may be `"paste"`, `"cut"`, or `"drop"`.
      var Transaction = function (Transform$$1) {
        function Transaction(state) {
          Transform$$1.call(this, state.doc);
          // :: number
          // The timestamp associated with this transaction, in the same
          // format as `Date.now()`.
          this.time = Date.now();
          this.curSelection = state.selection;
          // The step count for which the current selection is valid.
          this.curSelectionFor = 0;
          // :: ?[Mark]
          // The stored marks set by this transaction, if any.
          this.storedMarks = state.storedMarks;
          // Bitfield to track which aspects of the state were updated by
          // this transaction.
          this.updated = 0;
          // Object used to store metadata properties for the transaction.
          this.meta = Object.create(null);
        }

        if (Transform$$1) Transaction.__proto__ = Transform$$1;
        Transaction.prototype = Object.create(Transform$$1 && Transform$$1.prototype);
        Transaction.prototype.constructor = Transaction;

        var prototypeAccessors = { selection: {}, selectionSet: {}, storedMarksSet: {}, isGeneric: {}, scrolledIntoView: {} };

        // :: Selection
        // The transaction's current selection. This defaults to the editor
        // selection [mapped](#state.Selection.map) through the steps in the
        // transaction, but can be overwritten with
        // [`setSelection`](#state.Transaction.setSelection).
        prototypeAccessors.selection.get = function () {
          if (this.curSelectionFor < this.steps.length) {
            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
            this.curSelectionFor = this.steps.length;
          }
          return this.curSelection;
        };

        // :: (Selection) → Transaction
        // Update the transaction's current selection. Will determine the
        // selection that the editor gets when the transaction is applied.
        Transaction.prototype.setSelection = function setSelection(selection) {
          this.curSelection = selection;
          this.curSelectionFor = this.steps.length;
          this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
          this.storedMarks = null;
          return this;
        };

        // :: bool
        // Whether the selection was explicitly updated by this transaction.
        prototypeAccessors.selectionSet.get = function () {
          return (this.updated & UPDATED_SEL) > 0;
        };

        // :: (?[Mark]) → Transaction
        // Set the current stored marks.
        Transaction.prototype.setStoredMarks = function setStoredMarks(marks) {
          this.storedMarks = marks;
          this.updated |= UPDATED_MARKS;
          return this;
        };

        // :: ([Mark]) → Transaction
        // Make sure the current stored marks or, if that is null, the marks
        // at the selection, match the given set of marks. Does nothing if
        // this is already the case.
        Transaction.prototype.ensureMarks = function ensureMarks(marks) {
          if (!dist.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) {
            this.setStoredMarks(marks);
          }
          return this;
        };

        // :: (Mark) → Transaction
        // Add a mark to the set of stored marks.
        Transaction.prototype.addStoredMark = function addStoredMark(mark) {
          return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
        };

        // :: (union<Mark, MarkType>) → Transaction
        // Remove a mark or mark type from the set of stored marks.
        Transaction.prototype.removeStoredMark = function removeStoredMark(mark) {
          return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
        };

        // :: bool
        // Whether the stored marks were explicitly set for this transaction.
        prototypeAccessors.storedMarksSet.get = function () {
          return (this.updated & UPDATED_MARKS) > 0;
        };

        Transaction.prototype.addStep = function addStep(step, doc) {
          Transform$$1.prototype.addStep.call(this, step, doc);
          this.updated = this.updated & ~UPDATED_MARKS;
          this.storedMarks = null;
        };

        // :: (number) → Transaction
        // Update the timestamp for the transaction.
        Transaction.prototype.setTime = function setTime(time) {
          this.time = time;
          return this;
        };

        // :: (Slice) → Transaction
        // Replace the current selection with the given slice.
        Transaction.prototype.replaceSelection = function replaceSelection(slice) {
          this.selection.replace(this, slice);
          return this;
        };

        // :: (Node, ?bool) → Transaction
        // Replace the selection with the given node. When `inheritMarks` is
        // true and the content is inline, it inherits the marks from the
        // place where it is inserted.
        Transaction.prototype.replaceSelectionWith = function replaceSelectionWith(node, inheritMarks) {
          var selection = this.selection;
          if (inheritMarks !== false) {
            node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || dist.Mark.none));
          }
          selection.replaceWith(this, node);
          return this;
        };

        // :: () → Transaction
        // Delete the selection.
        Transaction.prototype.deleteSelection = function deleteSelection() {
          this.selection.replace(this);
          return this;
        };

        // :: (string, from: ?number, to: ?number) → Transaction
        // Replace the given range, or the selection if no range is given,
        // with a text node containing the given string.
        Transaction.prototype.insertText = function insertText(text, from, to) {
          if (to === void 0) to = from;

          var schema = this.doc.type.schema;
          if (from == null) {
            if (!text) {
              return this.deleteSelection();
            }
            return this.replaceSelectionWith(schema.text(text), true);
          } else {
            if (!text) {
              return this.deleteRange(from, to);
            }
            var marks = this.storedMarks;
            if (!marks) {
              var $from = this.doc.resolve(from);
              marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
            }
            return this.replaceRangeWith(from, to, schema.text(text, marks));
          }
        };

        // :: (union<string, Plugin, PluginKey>, any) → Transaction
        // Store a metadata property in this transaction, keyed either by
        // name or by plugin.
        Transaction.prototype.setMeta = function setMeta(key, value) {
          this.meta[typeof key == "string" ? key : key.key] = value;
          return this;
        };

        // :: (union<string, Plugin, PluginKey>) → any
        // Retrieve a metadata property for a given name or plugin.
        Transaction.prototype.getMeta = function getMeta(key) {
          return this.meta[typeof key == "string" ? key : key.key];
        };

        // :: bool
        // Returns true if this transaction doesn't contain any metadata,
        // and can thus safely be extended.
        prototypeAccessors.isGeneric.get = function () {
          var this$1 = this;

          for (var _ in this$1.meta) {
            return false;
          }
          return true;
        };

        // :: () → Transaction
        // Indicate that the editor should scroll the selection into view
        // when updated to the state produced by this transaction.
        Transaction.prototype.scrollIntoView = function scrollIntoView() {
          this.updated |= UPDATED_SCROLL;
          return this;
        };

        prototypeAccessors.scrolledIntoView.get = function () {
          return (this.updated & UPDATED_SCROLL) > 0;
        };

        Object.defineProperties(Transaction.prototype, prototypeAccessors);

        return Transaction;
      }(dist$1.Transform);

      function bind(f, self) {
        return !self || !f ? f : f.bind(self);
      }

      var FieldDesc = function FieldDesc(name, desc, self) {
        this.name = name;
        this.init = bind(desc.init, self);
        this.apply = bind(desc.apply, self);
      };

      var baseFields = [new FieldDesc("doc", {
        init: function init(config) {
          return config.doc || config.schema.topNodeType.createAndFill();
        },
        apply: function apply(tr) {
          return tr.doc;
        }
      }), new FieldDesc("selection", {
        init: function init(config, instance) {
          return config.selection || Selection.atStart(instance.doc);
        },
        apply: function apply(tr) {
          return tr.selection;
        }
      }), new FieldDesc("storedMarks", {
        init: function init(config) {
          return config.storedMarks || null;
        },
        apply: function apply(tr, _marks, _old, state) {
          return state.selection.$cursor ? tr.storedMarks : null;
        }
      }), new FieldDesc("scrollToSelection", {
        init: function init() {
          return 0;
        },
        apply: function apply(tr, prev) {
          return tr.scrolledIntoView ? prev + 1 : prev;
        }
      })];

      // Object wrapping the part of a state object that stays the same
      // across transactions. Stored in the state's `config` property.
      var Configuration = function Configuration(schema, plugins) {
        var this$1 = this;

        this.schema = schema;
        this.fields = baseFields.concat();
        this.plugins = [];
        this.pluginsByKey = Object.create(null);
        if (plugins) {
          plugins.forEach(function (plugin) {
            if (this$1.pluginsByKey[plugin.key]) {
              throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
            }
            this$1.plugins.push(plugin);
            this$1.pluginsByKey[plugin.key] = plugin;
            if (plugin.spec.state) {
              this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
            }
          });
        }
      };

      // ::- The state of a ProseMirror editor is represented by an object
      // of this type. A state is a persistent data structure—it isn't
      // updated, but rather a new state value is computed from an old one
      // using the [`apply`](#state.EditorState.apply) method.
      //
      // A state holds a number of built-in fields, and plugins can
      // [define](#state.PluginSpec.state) additional fields.
      var EditorState = function EditorState(config) {
        this.config = config;
      };

      var prototypeAccessors$1 = { schema: {}, plugins: {}, tr: {} };

      // doc:: Node
      // The current document.

      // selection:: Selection
      // The selection.

      // storedMarks:: ?[Mark]
      // A set of marks to apply to the next input. Will be null when
      // no explicit marks have been set.

      // :: Schema
      // The schema of the state's document.
      prototypeAccessors$1.schema.get = function () {
        return this.config.schema;
      };

      // :: [Plugin]
      // The plugins that are active in this state.
      prototypeAccessors$1.plugins.get = function () {
        return this.config.plugins;
      };

      // :: (Transaction) → EditorState
      // Apply the given transaction to produce a new state.
      EditorState.prototype.apply = function apply(tr) {
        return this.applyTransaction(tr).state;
      };

      // : (Transaction) → ?Transaction
      EditorState.prototype.filterTransaction = function filterTransaction(tr, ignore) {
        var this$1 = this;
        if (ignore === void 0) ignore = -1;

        for (var i = 0; i < this.config.plugins.length; i++) {
          if (i != ignore) {
            var plugin = this$1.config.plugins[i];
            if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this$1)) {
              return false;
            }
          }
        }
        return true;
      };

      // :: (Transaction) → {state: EditorState, transactions: [Transaction]}
      // Verbose variant of [`apply`](#state.EditorState.apply) that
      // returns the precise transactions that were applied (which might
      // be influenced by the [transaction
      // hooks](#state.PluginSpec.filterTransaction) of
      // plugins) along with the new state.
      EditorState.prototype.applyTransaction = function applyTransaction(rootTr) {
        var this$1 = this;

        if (!this.filterTransaction(rootTr)) {
          return { state: this, transactions: [] };
        }

        var trs = [rootTr],
            newState = this.applyInner(rootTr),
            seen = null;
        // This loop repeatedly gives plugins a chance to respond to
        // transactions as new transactions are added, making sure to only
        // pass the transactions the plugin did not see before.
        outer: for (;;) {
          var haveNew = false;
          for (var i = 0; i < this.config.plugins.length; i++) {
            var plugin = this$1.config.plugins[i];
            if (plugin.spec.appendTransaction) {
              var n = seen ? seen[i].n : 0,
                  oldState = seen ? seen[i].state : this$1;
              var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
              if (tr && newState.filterTransaction(tr, i)) {
                tr.setMeta("appendedTransaction", rootTr);
                if (!seen) {
                  seen = [];
                  for (var j = 0; j < this.config.plugins.length; j++) {
                    seen.push(j < i ? { state: newState, n: trs.length } : { state: this$1, n: 0 });
                  }
                }
                trs.push(tr);
                newState = newState.applyInner(tr);
                haveNew = true;
              }
              if (seen) {
                seen[i] = { state: newState, n: trs.length };
              }
            }
          }
          if (!haveNew) {
            return { state: newState, transactions: trs };
          }
        }
      };

      // : (Transaction) → EditorState
      EditorState.prototype.applyInner = function applyInner(tr) {
        var this$1 = this;

        if (!tr.before.eq(this.doc)) {
          throw new RangeError("Applying a mismatched transaction");
        }
        var newInstance = new EditorState(this.config),
            fields = this.config.fields;
        for (var i = 0; i < fields.length; i++) {
          var field = fields[i];
          newInstance[field.name] = field.apply(tr, this$1[field.name], this$1, newInstance);
        }
        for (var i$1 = 0; i$1 < applyListeners.length; i$1++) {
          applyListeners[i$1](this$1, tr, newInstance);
        }
        return newInstance;
      };

      // :: Transaction
      // Start a [transaction](#state.Transaction) from this state.
      prototypeAccessors$1.tr.get = function () {
        return new Transaction(this);
      };

      // :: (Object) → EditorState
      // Create a new state.
      //
      // config::- Configuration options. Must contain `schema` or `doc` (or both).
      //
      //    schema:: ?Schema
      //    The schema to use.
      //
      //    doc:: ?Node
      //    The starting document.
      //
      //    selection:: ?Selection
      //    A valid selection in the document.
      //
      //    storedMarks:: ?[Mark]
      //    The initial set of [stored marks](#state.EditorState.storedMarks).
      //
      //    plugins:: ?[Plugin]
      //    The plugins that should be active in this state.
      EditorState.create = function create(config) {
        var $config = new Configuration(config.schema || config.doc.type.schema, config.plugins);
        var instance = new EditorState($config);
        for (var i = 0; i < $config.fields.length; i++) {
          instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
        }
        return instance;
      };

      // :: (Object) → EditorState
      // Create a new state based on this one, but with an adjusted set of
      // active plugins. State fields that exist in both sets of plugins
      // are kept unchanged. Those that no longer exist are dropped, and
      // those that are new are initialized using their
      // [`init`](#state.StateField.init) method, passing in the new
      // configuration object..
      //
      // config::- configuration options
      //
      //   schema:: ?Schema
      //   New schema to use.
      //
      //   plugins:: ?[Plugin]
      //   New set of active plugins.
      EditorState.prototype.reconfigure = function reconfigure(config) {
        var this$1 = this;

        var $config = new Configuration(config.schema || this.schema, config.plugins);
        var fields = $config.fields,
            instance = new EditorState($config);
        for (var i = 0; i < fields.length; i++) {
          var name = fields[i].name;
          instance[name] = this$1.hasOwnProperty(name) ? this$1[name] : fields[i].init(config, instance);
        }
        return instance;
      };

      // :: (?union<Object<Plugin>, string, number>) → Object
      // Serialize this state to JSON. If you want to serialize the state
      // of plugins, pass an object mapping property names to use in the
      // resulting JSON object to plugin objects. The argument may also be
      // a string or number, in which case it is ignored, to support the
      // way `JSON.stringify` calls `toString` methods.
      EditorState.prototype.toJSON = function toJSON(pluginFields) {
        var this$1 = this;

        var result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
        if (this.storedMarks) {
          result.storedMarks = this.storedMarks.map(function (m) {
            return m.toJSON();
          });
        }
        if (pluginFields && typeof pluginFields == 'object') {
          for (var prop in pluginFields) {
            if (prop == "doc" || prop == "selection") {
              throw new RangeError("The JSON fields `doc` and `selection` are reserved");
            }
            var plugin = pluginFields[prop],
                state = plugin.spec.state;
            if (state && state.toJSON) {
              result[prop] = state.toJSON.call(plugin, this$1[plugin.key]);
            }
          }
        }
        return result;
      };

      // :: (Object, Object, ?Object<Plugin>) → EditorState
      // Deserialize a JSON representation of a state. `config` should
      // have at least a `schema` field, and should contain array of
      // plugins to initialize the state with. `pluginFields` can be used
      // to deserialize the state of plugins, by associating plugin
      // instances with the property names they use in the JSON object.
      //
      // config::- configuration options
      //
      //   schema:: Schema
      //   The schema to use.
      //
      //   plugins:: ?[Plugin]
      //   The set of active plugins.
      EditorState.fromJSON = function fromJSON(config, json, pluginFields) {
        if (!json) {
          throw new RangeError("Invalid input for EditorState.fromJSON");
        }
        if (!config.schema) {
          throw new RangeError("Required config field 'schema' missing");
        }
        var $config = new Configuration(config.schema, config.plugins);
        var instance = new EditorState($config);
        $config.fields.forEach(function (field) {
          if (field.name == "doc") {
            instance.doc = dist.Node.fromJSON(config.schema, json.doc);
          } else if (field.name == "selection") {
            instance.selection = Selection.fromJSON(instance.doc, json.selection);
          } else if (field.name == "storedMarks") {
            if (json.storedMarks) {
              instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
            }
          } else {
            if (pluginFields) {
              for (var prop in pluginFields) {
                var plugin = pluginFields[prop],
                    state = plugin.spec.state;
                if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                  // This field belongs to a plugin mapped to a JSON field, read it from there.
                  instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
                  return;
                }
              }
            }
            instance[field.name] = field.init(config, instance);
          }
        });
        return instance;
      };

      // Kludge to allow the view to track mappings between different
      // instances of a state.
      EditorState.addApplyListener = function addApplyListener(f) {
        applyListeners.push(f);
      };
      EditorState.removeApplyListener = function removeApplyListener(f) {
        var found = applyListeners.indexOf(f);
        if (found > -1) {
          applyListeners.splice(found, 1);
        }
      };

      Object.defineProperties(EditorState.prototype, prototypeAccessors$1);

      var applyListeners = [];

      // PluginSpec:: interface
      //
      // This is the type passed to the [`Plugin`](#state.Plugin)
      // constructor. It provides a definition for a plugin.
      //
      //   props:: ?EditorProps
      //   The [view props](#view.EditorProps) added by this plugin. Props
      //   that are functions will be bound to have the plugin instance as
      //   their `this` binding.
      //
      //   state:: ?StateField<any>
      //   Allows a plugin to define a [state field](#state.StateField), an
      //   extra slot in the state object in which it can keep its own data.
      //
      //   key:: ?PluginKey
      //   Can be used to make this a keyed plugin. You can have only one
      //   plugin with a given key in a given state, but it is possible to
      //   access the plugin's configuration and state through the key,
      //   without having access to the plugin instance object.
      //
      //   view:: ?(EditorView) → Object
      //   When the plugin needs to interact with the editor view, or
      //   set something up in the DOM, use this field. The function
      //   will be called when the plugin's state is associated with an
      //   editor view.
      //
      //     return::-
      //     Should return an object with the following optional
      //     properties:
      //
      //       update:: ?(view: EditorView, prevState: EditorState)
      //       Called whenever the view's state is updated.
      //
      //       destroy:: ?()
      //       Called when the view is destroyed or receives a state
      //       with different plugins.
      //
      //   filterTransaction:: ?(Transaction, EditorState) → bool
      //   When present, this will be called before a transaction is
      //   applied by the state, allowing the plugin to cancel it (by
      //   returning false).
      //
      //   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction
      //   Allows the plugin to append another transaction to be applied
      //   after the given array of transactions. When another plugin
      //   appends a transaction after this was called, it is called again
      //   with the new state and new transactions—but only the new
      //   transactions, i.e. it won't be passed transactions that it
      //   already saw.

      function bindProps(obj, self, target) {
        for (var prop in obj) {
          var val = obj[prop];
          if (val instanceof Function) {
            val = val.bind(self);
          } else if (prop == "handleDOMEvents") {
            val = bindProps(val, self, {});
          }
          target[prop] = val;
        }
        return target;
      }

      // ::- Plugins bundle functionality that can be added to an editor.
      // They are part of the [editor state](#state.EditorState) and
      // may influence that state and the view that contains it.
      var Plugin = function Plugin(spec) {
        // :: EditorProps
        // The [props](#view.EditorProps) exported by this plugin.
        this.props = {};
        if (spec.props) {
          bindProps(spec.props, this, this.props);
        }
        // :: Object
        // The plugin's [spec object](#state.PluginSpec).
        this.spec = spec;
        this.key = spec.key ? spec.key.key : createKey("plugin");
      };

      // :: (EditorState) → any
      // Extract the plugin's state field from an editor state.
      Plugin.prototype.getState = function getState(state) {
        return state[this.key];
      };

      // StateField:: interface<T>
      // A plugin spec may provide a state field (under its
      // [`state`](#state.PluginSpec.state) property) of this type, which
      // describes the state it wants to keep. Functions provided here are
      // always called with the plugin instance as their `this` binding.
      //
      //   init:: (config: Object, instance: EditorState) → T
      //   Initialize the value of the field. `config` will be the object
      //   passed to [`EditorState.create`](#state.EditorState^create). Note
      //   that `instance` is a half-initialized state instance, and will
      //   not have values for plugin fields initialized after this one.
      //
      //   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T
      //   Apply the given transaction to this state field, producing a new
      //   field value. Note that the `newState` argument is again a partially
      //   constructed state does not yet contain the state from plugins
      //   coming after this one.
      //
      //   toJSON:: ?(value: T) → *
      //   Convert this field to JSON. Optional, can be left off to disable
      //   JSON serialization for the field.
      //
      //   fromJSON:: ?(config: Object, value: *, state: EditorState) → T
      //   Deserialize the JSON representation of this field. Note that the
      //   `state` argument is again a half-initialized state.

      var keys = Object.create(null);

      function createKey(name) {
        if (name in keys) {
          return name + "$" + ++keys[name];
        }
        keys[name] = 0;
        return name + "$";
      }

      // ::- A key is used to [tag](#state.PluginSpec.key)
      // plugins in a way that makes it possible to find them, given an
      // editor state. Assigning a key does mean only one plugin of that
      // type can be active in a state.
      var PluginKey = function PluginKey(name) {
        if (name === void 0) name = "key";
        this.key = createKey(name);
      };

      // :: (EditorState) → ?Plugin
      // Get the active plugin with this key, if any, from an editor
      // state.
      PluginKey.prototype.get = function get(state) {
        return state.config.pluginsByKey[this.key];
      };

      // :: (EditorState) → ?any
      // Get the plugin's state from an editor state.
      PluginKey.prototype.getState = function getState(state) {
        return state[this.key];
      };

      exports.Selection = Selection;
      exports.SelectionRange = SelectionRange;
      exports.TextSelection = TextSelection;
      exports.NodeSelection = NodeSelection;
      exports.AllSelection = AllSelection;
      exports.Transaction = Transaction;
      exports.EditorState = EditorState;
      exports.Plugin = Plugin;
      exports.PluginKey = PluginKey;
      
    });

    unwrapExports(dist$2);
    var dist_1$2 = dist$2.Selection;
    var dist_2$2 = dist$2.SelectionRange;
    var dist_3$2 = dist$2.TextSelection;
    var dist_4$2 = dist$2.NodeSelection;
    var dist_5$2 = dist$2.AllSelection;
    var dist_6$2 = dist$2.Transaction;
    var dist_7$2 = dist$2.EditorState;
    var dist_8$2 = dist$2.Plugin;
    var dist_9$2 = dist$2.PluginKey;

    var commands = createCommonjsModule(function (module, exports) {

      Object.defineProperty(exports, '__esModule', { value: true });

      // :: (EditorState, ?(tr: Transaction)) → bool
      // Delete the selection, if there is one.
      function deleteSelection(state, dispatch) {
        if (state.selection.empty) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.deleteSelection().scrollIntoView());
        }
        return true;
      }

      // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
      // If the selection is empty and at the start of a textblock, try to
      // reduce the distance between that block and the one before it—if
      // there's a block directly before it that can be joined, join them.
      // If not, try to move the selected block closer to the next one in
      // the document structure by lifting it out of its parent or moving it
      // into a parent of the previous block. Will use the view for accurate
      // (bidi-aware) start-of-textblock detection if given.
      function joinBackward(state, dispatch, view) {
        var ref = state.selection;
        var $cursor = ref.$cursor;
        if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) {
          return false;
        }

        var $cut = findCutBefore($cursor);

        // If there is no node before this, try to lift
        if (!$cut) {
          var range = $cursor.blockRange(),
              target = range && dist$1.liftTarget(range);
          if (target == null) {
            return false;
          }
          if (dispatch) {
            dispatch(state.tr.lift(range, target).scrollIntoView());
          }
          return true;
        }

        var before = $cut.nodeBefore;
        // Apply the joining algorithm
        if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) {
          return true;
        }

        // If the node below has no content and the node above is
        // selectable, delete the node below and select the one above.
        if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || dist$2.NodeSelection.isSelectable(before))) {
          if (dispatch) {
            var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
            tr.setSelection(textblockAt(before, "end") ? dist$2.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : dist$2.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
            dispatch(tr.scrollIntoView());
          }
          return true;
        }

        // If the node before is an atom, delete it
        if (before.isAtom && $cut.depth == $cursor.depth - 1) {
          if (dispatch) {
            dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
          }
          return true;
        }

        return false;
      }

      function textblockAt(node, side) {
        for (; node; node = side == "start" ? node.firstChild : node.lastChild) {
          if (node.isTextblock) {
            return true;
          }
        }
        return false;
      }

      // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
      // When the selection is empty and at the start of a textblock, select
      // the node before that textblock, if possible. This is intended to be
      // bound to keys like backspace, after
      // [`joinBackward`](#commands.joinBackward) or other deleting
      // commands, as a fall-back behavior when the schema doesn't allow
      // deletion at the selected point.
      function selectNodeBackward(state, dispatch, view) {
        var ref = state.selection;
        var $cursor = ref.$cursor;
        if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) {
          return false;
        }

        var $cut = findCutBefore($cursor),
            node = $cut && $cut.nodeBefore;
        if (!node || !dist$2.NodeSelection.isSelectable(node)) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.setSelection(dist$2.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
        }
        return true;
      }

      function findCutBefore($pos) {
        if (!$pos.parent.type.spec.isolating) {
          for (var i = $pos.depth - 1; i >= 0; i--) {
            if ($pos.index(i) > 0) {
              return $pos.doc.resolve($pos.before(i + 1));
            }
            if ($pos.node(i).type.spec.isolating) {
              break;
            }
          }
        }
        return null;
      }

      // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
      // If the selection is empty and the cursor is at the end of a
      // textblock, try to reduce or remove the boundary between that block
      // and the one after it, either by joining them or by moving the other
      // block closer to this one in the tree structure. Will use the view
      // for accurate start-of-textblock detection if given.
      function joinForward(state, dispatch, view) {
        var ref = state.selection;
        var $cursor = ref.$cursor;
        if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) {
          return false;
        }

        var $cut = findCutAfter($cursor);

        // If there is no node after this, there's nothing to do
        if (!$cut) {
          return false;
        }

        var after = $cut.nodeAfter;
        // Try the joining algorithm
        if (deleteBarrier(state, $cut, dispatch)) {
          return true;
        }

        // If the node above has no content and the node below is
        // selectable, delete the node above and select the one below.
        if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || dist$2.NodeSelection.isSelectable(after))) {
          if (dispatch) {
            var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
            tr.setSelection(textblockAt(after, "start") ? dist$2.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : dist$2.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
            dispatch(tr.scrollIntoView());
          }
          return true;
        }

        // If the next node is an atom, delete it
        if (after.isAtom && $cut.depth == $cursor.depth - 1) {
          if (dispatch) {
            dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
          }
          return true;
        }

        return false;
      }

      // :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
      // When the selection is empty and at the end of a textblock, select
      // the node coming after that textblock, if possible. This is intended
      // to be bound to keys like delete, after
      // [`joinForward`](#commands.joinForward) and similar deleting
      // commands, to provide a fall-back behavior when the schema doesn't
      // allow deletion at the selected point.
      function selectNodeForward(state, dispatch, view) {
        var ref = state.selection;
        var $cursor = ref.$cursor;
        if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) {
          return false;
        }

        var $cut = findCutAfter($cursor),
            node = $cut && $cut.nodeAfter;
        if (!node || !dist$2.NodeSelection.isSelectable(node)) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.setSelection(dist$2.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
        }
        return true;
      }

      function findCutAfter($pos) {
        if (!$pos.parent.type.spec.isolating) {
          for (var i = $pos.depth - 1; i >= 0; i--) {
            var parent = $pos.node(i);
            if ($pos.index(i) + 1 < parent.childCount) {
              return $pos.doc.resolve($pos.after(i + 1));
            }
            if (parent.type.spec.isolating) {
              break;
            }
          }
        }
        return null;
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // Join the selected block or, if there is a text selection, the
      // closest ancestor block of the selection that can be joined, with
      // the sibling above it.
      function joinUp(state, dispatch) {
        var sel = state.selection,
            nodeSel = sel instanceof dist$2.NodeSelection,
            point;
        if (nodeSel) {
          if (sel.node.isTextblock || !dist$1.canJoin(state.doc, sel.from)) {
            return false;
          }
          point = sel.from;
        } else {
          point = dist$1.joinPoint(state.doc, sel.from, -1);
          if (point == null) {
            return false;
          }
        }
        if (dispatch) {
          var tr = state.tr.join(point);
          if (nodeSel) {
            tr.setSelection(dist$2.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
          }
          dispatch(tr.scrollIntoView());
        }
        return true;
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // Join the selected block, or the closest ancestor of the selection
      // that can be joined, with the sibling after it.
      function joinDown(state, dispatch) {
        var sel = state.selection,
            point;
        if (sel instanceof dist$2.NodeSelection) {
          if (sel.node.isTextblock || !dist$1.canJoin(state.doc, sel.to)) {
            return false;
          }
          point = sel.to;
        } else {
          point = dist$1.joinPoint(state.doc, sel.to, 1);
          if (point == null) {
            return false;
          }
        }
        if (dispatch) {
          dispatch(state.tr.join(point).scrollIntoView());
        }
        return true;
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // Lift the selected block, or the closest ancestor block of the
      // selection that can be lifted, out of its parent node.
      function lift(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        var range = $from.blockRange($to),
            target = range && dist$1.liftTarget(range);
        if (target == null) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.lift(range, target).scrollIntoView());
        }
        return true;
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // If the selection is in a node whose type has a truthy
      // [`code`](#model.NodeSpec.code) property in its spec, replace the
      // selection with a newline character.
      function newlineInCode(state, dispatch) {
        var ref = state.selection;
        var $head = ref.$head;
        var $anchor = ref.$anchor;
        if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.insertText("\n").scrollIntoView());
        }
        return true;
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // When the selection is in a node with a truthy
      // [`code`](#model.NodeSpec.code) property in its spec, create a
      // default block after the code block, and move the cursor there.
      function exitCode(state, dispatch) {
        var ref = state.selection;
        var $head = ref.$head;
        var $anchor = ref.$anchor;
        if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
          return false;
        }
        var above = $head.node(-1),
            after = $head.indexAfter(-1),
            type = above.contentMatchAt(after).defaultType;
        if (!above.canReplaceWith(after, after, type)) {
          return false;
        }
        if (dispatch) {
          var pos = $head.after(),
              tr = state.tr.replaceWith(pos, pos, type.createAndFill());
          tr.setSelection(dist$2.Selection.near(tr.doc.resolve(pos), 1));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // If a block node is selected, create an empty paragraph before (if
      // it is its parent's first child) or after it.
      function createParagraphNear(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        if ($from.parent.inlineContent || $to.parent.inlineContent) {
          return false;
        }
        var type = $from.parent.contentMatchAt($to.indexAfter()).defaultType;
        if (!type || !type.isTextblock) {
          return false;
        }
        if (dispatch) {
          var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
          var tr = state.tr.insert(side, type.createAndFill());
          tr.setSelection(dist$2.TextSelection.create(tr.doc, side + 1));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // If the cursor is in an empty textblock that can be lifted, lift the
      // block.
      function liftEmptyBlock(state, dispatch) {
        var ref = state.selection;
        var $cursor = ref.$cursor;
        if (!$cursor || $cursor.parent.content.size) {
          return false;
        }
        if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
          var before = $cursor.before();
          if (dist$1.canSplit(state.doc, before)) {
            if (dispatch) {
              dispatch(state.tr.split(before).scrollIntoView());
            }
            return true;
          }
        }
        var range = $cursor.blockRange(),
            target = range && dist$1.liftTarget(range);
        if (target == null) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.lift(range, target).scrollIntoView());
        }
        return true;
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // Split the parent block of the selection. If the selection is a text
      // selection, also delete its content.
      function splitBlock(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var $to = ref.$to;
        if (state.selection instanceof dist$2.NodeSelection && state.selection.node.isBlock) {
          if (!$from.parentOffset || !dist$1.canSplit(state.doc, $from.pos)) {
            return false;
          }
          if (dispatch) {
            dispatch(state.tr.split($from.pos).scrollIntoView());
          }
          return true;
        }

        if (!$from.parent.isBlock) {
          return false;
        }

        if (dispatch) {
          var atEnd = $to.parentOffset == $to.parent.content.size;
          var tr = state.tr;
          if (state.selection instanceof dist$2.TextSelection) {
            tr.deleteSelection();
          }
          var deflt = $from.depth == 0 ? null : $from.node(-1).contentMatchAt($from.indexAfter(-1)).defaultType;
          var types = atEnd && deflt ? [{ type: deflt }] : null;
          var can = dist$1.canSplit(tr.doc, $from.pos, 1, types);
          if (!types && !can && dist$1.canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{ type: deflt }])) {
            types = [{ type: deflt }];
            can = true;
          }
          if (can) {
            tr.split(tr.mapping.map($from.pos), 1, types);
            if (!atEnd && !$from.parentOffset && $from.parent.type != deflt && $from.node(-1).canReplace($from.index(-1), $from.indexAfter(-1), dist.Fragment.from(deflt.create(), $from.parent))) {
              tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
            }
          }
          dispatch(tr.scrollIntoView());
        }
        return true;
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // Acts like [`splitBlock`](#commands.splitBlock), but without
      // resetting the set of active marks at the cursor.
      function splitBlockKeepMarks(state, dispatch) {
        return splitBlock(state, dispatch && function (tr) {
          var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
          if (marks) {
            tr.ensureMarks(marks);
          }
          dispatch(tr);
        });
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // Move the selection to the node wrapping the current selection, if
      // any. (Will not select the document node.)
      function selectParentNode(state, dispatch) {
        var ref = state.selection;
        var $from = ref.$from;
        var to = ref.to;
        var pos;
        var same = $from.sharedDepth(to);
        if (same == 0) {
          return false;
        }
        pos = $from.before(same);
        if (dispatch) {
          dispatch(state.tr.setSelection(dist$2.NodeSelection.create(state.doc, pos)));
        }
        return true;
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // Select the whole document.
      function selectAll(state, dispatch) {
        if (dispatch) {
          dispatch(state.tr.setSelection(new dist$2.AllSelection(state.doc)));
        }
        return true;
      }

      function joinMaybeClear(state, $pos, dispatch) {
        var before = $pos.nodeBefore,
            after = $pos.nodeAfter,
            index = $pos.index();
        if (!before || !after || !before.type.compatibleContent(after.type)) {
          return false;
        }
        if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
          if (dispatch) {
            dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
          }
          return true;
        }
        if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || dist$1.canJoin(state.doc, $pos.pos))) {
          return false;
        }
        if (dispatch) {
          dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
        }
        return true;
      }

      function deleteBarrier(state, $cut, dispatch) {
        var before = $cut.nodeBefore,
            after = $cut.nodeAfter,
            conn,
            match;
        if (before.type.spec.isolating || after.type.spec.isolating) {
          return false;
        }
        if (joinMaybeClear(state, $cut, dispatch)) {
          return true;
        }

        if ($cut.parent.canReplace($cut.index(), $cut.index() + 1) && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
          if (dispatch) {
            var end = $cut.pos + after.nodeSize,
                wrap = dist.Fragment.empty;
            for (var i = conn.length - 1; i >= 0; i--) {
              wrap = dist.Fragment.from(conn[i].create(null, wrap));
            }
            wrap = dist.Fragment.from(before.copy(wrap));
            var tr = state.tr.step(new dist$1.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new dist.Slice(wrap, 1, 0), conn.length, true));
            var joinAt = end + 2 * conn.length;
            if (dist$1.canJoin(tr.doc, joinAt)) {
              tr.join(joinAt);
            }
            dispatch(tr.scrollIntoView());
          }
          return true;
        }

        var selAfter = dist$2.Selection.findFrom($cut, 1);
        var range = selAfter && selAfter.$from.blockRange(selAfter.$to),
            target = range && dist$1.liftTarget(range);
        if (target != null && target >= $cut.depth) {
          if (dispatch) {
            dispatch(state.tr.lift(range, target).scrollIntoView());
          }
          return true;
        }

        return false;
      }

      // Parameterized commands

      // :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
      // Wrap the selection in a node of the given type with the given
      // attributes.
      function wrapIn(nodeType, attrs) {
        return function (state, dispatch) {
          var ref = state.selection;
          var $from = ref.$from;
          var $to = ref.$to;
          var range = $from.blockRange($to),
              wrapping = range && dist$1.findWrapping(range, nodeType, attrs);
          if (!wrapping) {
            return false;
          }
          if (dispatch) {
            dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
          }
          return true;
        };
      }

      // :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
      // Returns a command that tries to set the selected textblocks to the
      // given node type with the given attributes.
      function setBlockType(nodeType, attrs) {
        return function (state, dispatch) {
          var ref = state.selection;
          var from = ref.from;
          var to = ref.to;
          var applicable = false;
          state.doc.nodesBetween(from, to, function (node, pos) {
            if (applicable) {
              return false;
            }
            if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) {
              return;
            }
            if (node.type == nodeType) {
              applicable = true;
            } else {
              var $pos = state.doc.resolve(pos),
                  index = $pos.index();
              applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
            }
          });
          if (!applicable) {
            return false;
          }
          if (dispatch) {
            dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView());
          }
          return true;
        };
      }

      function markApplies(doc, ranges, type) {
        var loop = function loop(i) {
          var ref = ranges[i];
          var $from = ref.$from;
          var $to = ref.$to;
          var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;
          doc.nodesBetween($from.pos, $to.pos, function (node) {
            if (can) {
              return false;
            }
            can = node.inlineContent && node.type.allowsMarkType(type);
          });
          if (can) {
            return { v: true };
          }
        };

        for (var i = 0; i < ranges.length; i++) {
          var returned = loop(i);

          if (returned) return returned.v;
        }
        return false;
      }

      // :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
      // Create a command function that toggles the given mark with the
      // given attributes. Will return `false` when the current selection
      // doesn't support that mark. This will remove the mark if any marks
      // of that type exist in the selection, or add it otherwise. If the
      // selection is empty, this applies to the [stored
      // marks](#state.EditorState.storedMarks) instead of a range of the
      // document.
      function toggleMark(markType, attrs) {
        return function (state, dispatch) {
          var ref = state.selection;
          var empty = ref.empty;
          var $cursor = ref.$cursor;
          var ranges = ref.ranges;
          if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) {
            return false;
          }
          if (dispatch) {
            if ($cursor) {
              if (markType.isInSet(state.storedMarks || $cursor.marks())) {
                dispatch(state.tr.removeStoredMark(markType));
              } else {
                dispatch(state.tr.addStoredMark(markType.create(attrs)));
              }
            } else {
              var has = false,
                  tr = state.tr;
              for (var i = 0; !has && i < ranges.length; i++) {
                var ref$1 = ranges[i];
                var $from = ref$1.$from;
                var $to = ref$1.$to;
                has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
              }
              for (var i$1 = 0; i$1 < ranges.length; i$1++) {
                var ref$2 = ranges[i$1];
                var $from$1 = ref$2.$from;
                var $to$1 = ref$2.$to;
                if (has) {
                  tr.removeMark($from$1.pos, $to$1.pos, markType);
                } else {
                  tr.addMark($from$1.pos, $to$1.pos, markType.create(attrs));
                }
              }
              dispatch(tr.scrollIntoView());
            }
          }
          return true;
        };
      }

      function wrapDispatchForJoin(dispatch, isJoinable) {
        return function (tr) {
          if (!tr.isGeneric) {
            return dispatch(tr);
          }

          var ranges = [];
          for (var i = 0; i < tr.mapping.maps.length; i++) {
            var map = tr.mapping.maps[i];
            for (var j = 0; j < ranges.length; j++) {
              ranges[j] = map.map(ranges[j]);
            }
            map.forEach(function (_s, _e, from, to) {
              return ranges.push(from, to);
            });
          }

          // Figure out which joinable points exist inside those ranges,
          // by checking all node boundaries in their parent nodes.
          var joinable = [];
          for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {
            var from = ranges[i$1],
                to = ranges[i$1 + 1];
            var $from = tr.doc.resolve(from),
                depth = $from.sharedDepth(to),
                parent = $from.node(depth);
            for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {
              var after = parent.maybeChild(index);
              if (!after) {
                break;
              }
              if (index && joinable.indexOf(pos) == -1) {
                var before = parent.child(index - 1);
                if (before.type == after.type && isJoinable(before, after)) {
                  joinable.push(pos);
                }
              }
              pos += after.nodeSize;
            }
          }
          // Join the joinable points
          joinable.sort(function (a, b) {
            return a - b;
          });
          for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {
            if (dist$1.canJoin(tr.doc, joinable[i$2])) {
              tr.join(joinable[i$2]);
            }
          }
          dispatch(tr);
        };
      }

      // :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool
      // Wrap a command so that, when it produces a transform that causes
      // two joinable nodes to end up next to each other, those are joined.
      // Nodes are considered joinable when they are of the same type and
      // when the `isJoinable` predicate returns true for them or, if an
      // array of strings was passed, if their node type name is in that
      // array.
      function autoJoin(command, isJoinable) {
        if (Array.isArray(isJoinable)) {
          var types = isJoinable;
          isJoinable = function isJoinable(node) {
            return types.indexOf(node.type.name) > -1;
          };
        }
        return function (state, dispatch) {
          return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable));
        };
      }

      // :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool
      // Combine a number of command functions into a single function (which
      // calls them one by one until one returns true).
      function chainCommands() {
        var commands = [],
            len = arguments.length;
        while (len--) commands[len] = arguments[len];

        return function (state, dispatch, view) {
          for (var i = 0; i < commands.length; i++) {
            if (commands[i](state, dispatch, view)) {
              return true;
            }
          }
          return false;
        };
      }

      var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
      var del = chainCommands(deleteSelection, joinForward, selectNodeForward);

      // :: Object
      // A basic keymap containing bindings not specific to any schema.
      // Binds the following keys (when multiple commands are listed, they
      // are chained with [`chainCommands`](#commands.chainCommands)):
      //
      // * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`
      // * **Mod-Enter** to `exitCode`
      // * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`
      // * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
      // * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
      // * **Mod-a** to `selectAll`
      var pcBaseKeymap = {
        "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
        "Mod-Enter": exitCode,
        "Backspace": backspace,
        "Mod-Backspace": backspace,
        "Delete": del,
        "Mod-Delete": del,
        "Mod-a": selectAll
      };

      // :: Object
      // A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,
      // **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and
      // **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like
      // Ctrl-Delete.
      var macBaseKeymap = {
        "Ctrl-h": pcBaseKeymap["Backspace"],
        "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
        "Ctrl-d": pcBaseKeymap["Delete"],
        "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
        "Alt-Delete": pcBaseKeymap["Mod-Delete"],
        "Alt-d": pcBaseKeymap["Mod-Delete"]
      };
      for (var key in pcBaseKeymap) {
        macBaseKeymap[key] = pcBaseKeymap[key];
      }

      // declare global: os, navigator
      var mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : typeof os != "undefined" ? os.platform() == "darwin" : false;

      // :: Object
      // Depending on the detected platform, this will hold
      // [`pcBasekeymap`](#commands.pcBaseKeymap) or
      // [`macBaseKeymap`](#commands.macBaseKeymap).
      var baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;

      exports.deleteSelection = deleteSelection;
      exports.joinBackward = joinBackward;
      exports.selectNodeBackward = selectNodeBackward;
      exports.joinForward = joinForward;
      exports.selectNodeForward = selectNodeForward;
      exports.joinUp = joinUp;
      exports.joinDown = joinDown;
      exports.lift = lift;
      exports.newlineInCode = newlineInCode;
      exports.exitCode = exitCode;
      exports.createParagraphNear = createParagraphNear;
      exports.liftEmptyBlock = liftEmptyBlock;
      exports.splitBlock = splitBlock;
      exports.splitBlockKeepMarks = splitBlockKeepMarks;
      exports.selectParentNode = selectParentNode;
      exports.selectAll = selectAll;
      exports.wrapIn = wrapIn;
      exports.setBlockType = setBlockType;
      exports.toggleMark = toggleMark;
      exports.autoJoin = autoJoin;
      exports.chainCommands = chainCommands;
      exports.pcBaseKeymap = pcBaseKeymap;
      exports.macBaseKeymap = macBaseKeymap;
      exports.baseKeymap = baseKeymap;
      
    });

    unwrapExports(commands);
    var commands_1 = commands.deleteSelection;
    var commands_2 = commands.joinBackward;
    var commands_3 = commands.selectNodeBackward;
    var commands_4 = commands.joinForward;
    var commands_5 = commands.selectNodeForward;
    var commands_6 = commands.joinUp;
    var commands_7 = commands.joinDown;
    var commands_8 = commands.lift;
    var commands_9 = commands.newlineInCode;
    var commands_10 = commands.exitCode;
    var commands_11 = commands.createParagraphNear;
    var commands_12 = commands.liftEmptyBlock;
    var commands_13 = commands.splitBlock;
    var commands_14 = commands.splitBlockKeepMarks;
    var commands_15 = commands.selectParentNode;
    var commands_16 = commands.selectAll;
    var commands_17 = commands.wrapIn;
    var commands_18 = commands.setBlockType;
    var commands_19 = commands.toggleMark;
    var commands_20 = commands.autoJoin;
    var commands_21 = commands.chainCommands;
    var commands_22 = commands.pcBaseKeymap;
    var commands_23 = commands.macBaseKeymap;
    var commands_24 = commands.baseKeymap;

    var GOOD_LEAF_SIZE = 200;

    // :: class<T> A rope sequence is a persistent sequence data structure
    // that supports appending, prepending, and slicing without doing a
    // full copy. It is represented as a mostly-balanced tree.
    var RopeSequence = function RopeSequence() {};

    RopeSequence.prototype.append = function append(other) {
      if (!other.length) {
        return this;
      }
      other = RopeSequence.from(other);

      return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
    };

    // :: (union<[T], RopeSequence<T>>) → RopeSequence<T>
    // Prepend an array or other rope to this one, returning a new rope.
    RopeSequence.prototype.prepend = function prepend(other) {
      if (!other.length) {
        return this;
      }
      return RopeSequence.from(other).append(this);
    };

    RopeSequence.prototype.appendInner = function appendInner(other) {
      return new Append(this, other);
    };

    // :: (?number, ?number) → RopeSequence<T>
    // Create a rope repesenting a sub-sequence of this rope.
    RopeSequence.prototype.slice = function slice(from, to) {
      if (from === void 0) from = 0;
      if (to === void 0) to = this.length;

      if (from >= to) {
        return RopeSequence.empty;
      }
      return this.sliceInner(Math.max(0, from), Math.min(this.length, to));
    };

    // :: (number) → T
    // Retrieve the element at the given position from this rope.
    RopeSequence.prototype.get = function get(i) {
      if (i < 0 || i >= this.length) {
        return undefined;
      }
      return this.getInner(i);
    };

    // :: ((element: T, index: number) → ?bool, ?number, ?number)
    // Call the given function for each element between the given
    // indices. This tends to be more efficient than looping over the
    // indices and calling `get`, because it doesn't have to descend the
    // tree for every element.
    RopeSequence.prototype.forEach = function forEach(f, from, to) {
      if (from === void 0) from = 0;
      if (to === void 0) to = this.length;

      if (from <= to) {
        this.forEachInner(f, from, to, 0);
      } else {
        this.forEachInvertedInner(f, from, to, 0);
      }
    };

    // :: ((element: T, index: number) → U, ?number, ?number) → [U]
    // Map the given functions over the elements of the rope, producing
    // a flat array.
    RopeSequence.prototype.map = function map(f, from, to) {
      if (from === void 0) from = 0;
      if (to === void 0) to = this.length;

      var result = [];
      this.forEach(function (elt, i) {
        return result.push(f(elt, i));
      }, from, to);
      return result;
    };

    // :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>
    // Create a rope representing the given array, or return the rope
    // itself if a rope was given.
    RopeSequence.from = function from(values) {
      if (values instanceof RopeSequence) {
        return values;
      }
      return values && values.length ? new Leaf(values) : RopeSequence.empty;
    };

    var Leaf = function (RopeSequence) {
      function Leaf(values) {
        RopeSequence.call(this);
        this.values = values;
      }

      if (RopeSequence) Leaf.__proto__ = RopeSequence;
      Leaf.prototype = Object.create(RopeSequence && RopeSequence.prototype);
      Leaf.prototype.constructor = Leaf;

      var prototypeAccessors = { length: {}, depth: {} };

      Leaf.prototype.flatten = function flatten() {
        return this.values;
      };

      Leaf.prototype.sliceInner = function sliceInner(from, to) {
        if (from == 0 && to == this.length) {
          return this;
        }
        return new Leaf(this.values.slice(from, to));
      };

      Leaf.prototype.getInner = function getInner(i) {
        return this.values[i];
      };

      Leaf.prototype.forEachInner = function forEachInner(f, from, to, start) {
        var this$1 = this;

        for (var i = from; i < to; i++) {
          if (f(this$1.values[i], start + i) === false) {
            return false;
          }
        }
      };

      Leaf.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {
        var this$1 = this;

        for (var i = from - 1; i >= to; i--) {
          if (f(this$1.values[i], start + i) === false) {
            return false;
          }
        }
      };

      Leaf.prototype.leafAppend = function leafAppend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf(this.values.concat(other.flatten()));
        }
      };

      Leaf.prototype.leafPrepend = function leafPrepend(other) {
        if (this.length + other.length <= GOOD_LEAF_SIZE) {
          return new Leaf(other.flatten().concat(this.values));
        }
      };

      prototypeAccessors.length.get = function () {
        return this.values.length;
      };

      prototypeAccessors.depth.get = function () {
        return 0;
      };

      Object.defineProperties(Leaf.prototype, prototypeAccessors);

      return Leaf;
    }(RopeSequence);

    // :: RopeSequence
    // The empty rope sequence.
    RopeSequence.empty = new Leaf([]);

    var Append = function (RopeSequence) {
      function Append(left, right) {
        RopeSequence.call(this);
        this.left = left;
        this.right = right;
        this.length = left.length + right.length;
        this.depth = Math.max(left.depth, right.depth) + 1;
      }

      if (RopeSequence) Append.__proto__ = RopeSequence;
      Append.prototype = Object.create(RopeSequence && RopeSequence.prototype);
      Append.prototype.constructor = Append;

      Append.prototype.flatten = function flatten() {
        return this.left.flatten().concat(this.right.flatten());
      };

      Append.prototype.getInner = function getInner(i) {
        return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
      };

      Append.prototype.forEachInner = function forEachInner(f, from, to, start) {
        var leftLen = this.left.length;
        if (from < leftLen && this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false) {
          return false;
        }
        if (to > leftLen && this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
          return false;
        }
      };

      Append.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {
        var leftLen = this.left.length;
        if (from > leftLen && this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
          return false;
        }
        if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false) {
          return false;
        }
      };

      Append.prototype.sliceInner = function sliceInner(from, to) {
        if (from == 0 && to == this.length) {
          return this;
        }
        var leftLen = this.left.length;
        if (to <= leftLen) {
          return this.left.slice(from, to);
        }
        if (from >= leftLen) {
          return this.right.slice(from - leftLen, to - leftLen);
        }
        return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen));
      };

      Append.prototype.leafAppend = function leafAppend(other) {
        var inner = this.right.leafAppend(other);
        if (inner) {
          return new Append(this.left, inner);
        }
      };

      Append.prototype.leafPrepend = function leafPrepend(other) {
        var inner = this.left.leafPrepend(other);
        if (inner) {
          return new Append(inner, this.right);
        }
      };

      Append.prototype.appendInner = function appendInner(other) {
        if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
          return new Append(this.left, new Append(this.right, other));
        }
        return new Append(this, other);
      };

      return Append;
    }(RopeSequence);

    var dist$3 = RopeSequence;

    var history_1 = createCommonjsModule(function (module, exports) {

      Object.defineProperty(exports, '__esModule', { value: true });

      function _interopDefault(ex) {
        return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
      }

      var RopeSequence = _interopDefault(dist$3);

      // ProseMirror's history isn't simply a way to roll back to a previous
      // state, because ProseMirror supports applying changes without adding
      // them to the history (for example during collaboration).
      //
      // To this end, each 'Branch' (one for the undo history and one for
      // the redo history) keeps an array of 'Items', which can optionally
      // hold a step (an actual undoable change), and always hold a position
      // map (which is needed to move changes below them to apply to the
      // current document).
      //
      // An item that has both a step and a selection bookmark is the start
      // of an 'event' — a group of changes that will be undone or redone at
      // once. (It stores only the bookmark, since that way we don't have to
      // provide a document until the selection is actually applied, which
      // is useful when compressing.)

      // Used to schedule history compression
      var max_empty_items = 500;

      var Branch = function Branch(items, eventCount) {
        this.items = items;
        this.eventCount = eventCount;
      };

      // : (EditorState, bool) → ?{transform: Transform, selection: ?SelectionBookmark, remaining: Branch}
      // Pop the latest event off the branch's history and apply it
      // to a document transform.
      Branch.prototype.popEvent = function popEvent(state, preserveItems) {
        var this$1 = this;

        if (this.eventCount == 0) {
          return null;
        }

        var end = this.items.length;
        for (;; end--) {
          var next = this$1.items.get(end - 1);
          if (next.selection) {
            --end;break;
          }
        }

        var remap, mapFrom;
        if (preserveItems) {
          remap = this.remapping(end, this.items.length);
          mapFrom = remap.maps.length;
        }
        var transform = state.tr;
        var selection, remaining;
        var addAfter = [],
            addBefore = [];

        this.items.forEach(function (item, i) {
          if (!item.step) {
            if (!remap) {
              remap = this$1.remapping(end, i + 1);
              mapFrom = remap.maps.length;
            }
            mapFrom--;
            addBefore.push(item);
            return;
          }

          if (remap) {
            addBefore.push(new Item(item.map));
            var step = item.step.map(remap.slice(mapFrom)),
                map;

            if (step && transform.maybeStep(step).doc) {
              map = transform.mapping.maps[transform.mapping.maps.length - 1];
              addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length));
            }
            mapFrom--;
            if (map) {
              remap.appendMap(map, mapFrom);
            }
          } else {
            transform.maybeStep(item.step);
          }

          if (item.selection) {
            selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
            remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1);
            return false;
          }
        }, this.items.length, 0);

        return { remaining: remaining, transform: transform, selection: selection };
      };

      // : (Transform, ?SelectionBookmark, Object) → Branch
      // Create a new branch with the given transform added.
      Branch.prototype.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {
        var newItems = [],
            eventCount = this.eventCount;
        var oldItems = this.items,
            lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;

        for (var i = 0; i < transform.steps.length; i++) {
          var step = transform.steps[i].invert(transform.docs[i]);
          var item = new Item(transform.mapping.maps[i], step, selection),
              merged = void 0;
          if (merged = lastItem && lastItem.merge(item)) {
            item = merged;
            if (i) {
              newItems.pop();
            } else {
              oldItems = oldItems.slice(0, oldItems.length - 1);
            }
          }
          newItems.push(item);
          if (selection) {
            eventCount++;
            selection = null;
          }
          if (!preserveItems) {
            lastItem = item;
          }
        }
        var overflow = eventCount - histOptions.depth;
        if (overflow > DEPTH_OVERFLOW) {
          oldItems = cutOffEvents(oldItems, overflow);
          eventCount -= overflow;
        }
        return new Branch(oldItems.append(newItems), eventCount);
      };

      Branch.prototype.remapping = function remapping(from, to) {
        var maps = new dist$1.Mapping();
        this.items.forEach(function (item, i) {
          var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? mirrorPos = maps.maps.length - item.mirrorOffset : null;
          maps.appendMap(item.map, mirrorPos);
        }, from, to);
        return maps;
      };

      Branch.prototype.addMaps = function addMaps(array) {
        if (this.eventCount == 0) {
          return this;
        }
        return new Branch(this.items.append(array.map(function (map) {
          return new Item(map);
        })), this.eventCount);
      };

      // : (Transform, number)
      // When the collab module receives remote changes, the history has
      // to know about those, so that it can adjust the steps that were
      // rebased on top of the remote changes, and include the position
      // maps for the remote changes in its array of items.
      Branch.prototype.rebased = function rebased(rebasedTransform, rebasedCount) {
        if (!this.eventCount) {
          return this;
        }

        var rebasedItems = [],
            start = Math.max(0, this.items.length - rebasedCount);

        var mapping = rebasedTransform.mapping;
        var newUntil = rebasedTransform.steps.length;
        var eventCount = this.eventCount;
        this.items.forEach(function (item) {
          if (item.selection) {
            eventCount--;
          }
        }, start);

        var iRebased = rebasedCount;
        this.items.forEach(function (item) {
          var pos = mapping.getMirror(--iRebased);
          if (pos == null) {
            return;
          }
          newUntil = Math.min(newUntil, pos);
          var map = mapping.maps[pos];
          if (item.step) {
            var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
            var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
            if (selection) {
              eventCount++;
            }
            rebasedItems.push(new Item(map, step, selection));
          } else {
            rebasedItems.push(new Item(map));
          }
        }, start);

        var newMaps = [];
        for (var i = rebasedCount; i < newUntil; i++) {
          newMaps.push(new Item(mapping.maps[i]));
        }
        var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
        var branch = new Branch(items, eventCount);

        if (branch.emptyItemCount() > max_empty_items) {
          branch = branch.compress(this.items.length - rebasedItems.length);
        }
        return branch;
      };

      Branch.prototype.emptyItemCount = function emptyItemCount() {
        var count = 0;
        this.items.forEach(function (item) {
          if (!item.step) {
            count++;
          }
        });
        return count;
      };

      // Compressing a branch means rewriting it to push the air (map-only
      // items) out. During collaboration, these naturally accumulate
      // because each remote change adds one. The `upto` argument is used
      // to ensure that only the items below a given level are compressed,
      // because `rebased` relies on a clean, untouched set of items in
      // order to associate old items with rebased steps.
      Branch.prototype.compress = function compress(upto) {
        if (upto === void 0) upto = this.items.length;

        var remap = this.remapping(0, upto),
            mapFrom = remap.maps.length;
        var items = [],
            events = 0;
        this.items.forEach(function (item, i) {
          if (i >= upto) {
            items.push(item);
            if (item.selection) {
              events++;
            }
          } else if (item.step) {
            var step = item.step.map(remap.slice(mapFrom)),
                map = step && step.getMap();
            mapFrom--;
            if (map) {
              remap.appendMap(map, mapFrom);
            }
            if (step) {
              var selection = item.selection && item.selection.map(remap.slice(mapFrom));
              if (selection) {
                events++;
              }
              var newItem = new Item(map.invert(), step, selection),
                  merged,
                  last = items.length - 1;
              if (merged = items.length && items[last].merge(newItem)) {
                items[last] = merged;
              } else {
                items.push(newItem);
              }
            }
          } else if (item.map) {
            mapFrom--;
          }
        }, this.items.length, 0);
        return new Branch(RopeSequence.from(items.reverse()), events);
      };

      Branch.empty = new Branch(RopeSequence.empty, 0);

      function cutOffEvents(items, n) {
        var cutPoint;
        items.forEach(function (item, i) {
          if (item.selection && n-- == 0) {
            cutPoint = i;
            return false;
          }
        });
        return items.slice(cutPoint);
      }

      var Item = function Item(map, step, selection, mirrorOffset) {
        this.map = map;
        this.step = step;
        this.selection = selection;
        this.mirrorOffset = mirrorOffset;
      };

      Item.prototype.merge = function merge(other) {
        if (this.step && other.step && !other.selection) {
          var step = other.step.merge(this.step);
          if (step) {
            return new Item(step.getMap().invert(), step, this.selection);
          }
        }
      };

      // The value of the state field that tracks undo/redo history for that
      // state. Will be stored in the plugin state when the history plugin
      // is active.
      var HistoryState = function HistoryState(done, undone, prevRanges, prevTime) {
        this.done = done;
        this.undone = undone;
        this.prevRanges = prevRanges;
        this.prevTime = prevTime;
      };

      var DEPTH_OVERFLOW = 20;

      // : (HistoryState, EditorState, Transaction, Object)
      // Record a transformation in undo history.
      function applyTransaction(history, state, tr, options) {
        var historyTr = tr.getMeta(historyKey),
            rebased;
        if (historyTr) {
          return historyTr.historyState;
        }

        if (tr.getMeta(closeHistoryKey)) {
          history = new HistoryState(history.done, history.undone, null, 0);
        }

        var appended = tr.getMeta("appendedTransaction");

        if (tr.steps.length == 0) {
          return history;
        } else if (appended && appended.getMeta(historyKey)) {
          if (appended.getMeta(historyKey).redo) {
            return new HistoryState(history.done.addTransform(tr, null, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime);
          } else {
            return new HistoryState(history.done, history.undone.addTransform(tr, null, options, mustPreserveItems(state)), null, history.prevTime);
          }
        } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
          // Group transforms that occur in quick succession into one event.
          var newGroup = history.prevTime < (tr.time || 0) - options.newGroupDelay || !appended && !isAdjacentTo(tr, history.prevRanges);
          var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
          return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : null, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);
        } else if (rebased = tr.getMeta("rebased")) {
          // Used by the collab module to tell the history that some of its
          // content has been rebased.
          return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime);
        } else {
          return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime);
        }
      }

      function isAdjacentTo(transform, prevRanges) {
        if (!prevRanges) {
          return false;
        }
        if (!transform.docChanged) {
          return true;
        }
        var adjacent = false;
        transform.mapping.maps[0].forEach(function (start, end) {
          for (var i = 0; i < prevRanges.length; i += 2) {
            if (start <= prevRanges[i + 1] && end >= prevRanges[i]) {
              adjacent = true;
            }
          }
        });
        return adjacent;
      }

      function rangesFor(map) {
        var result = [];
        map.forEach(function (_from, _to, from, to) {
          return result.push(from, to);
        });
        return result;
      }

      function mapRanges(ranges, mapping) {
        if (!ranges) {
          return null;
        }
        var result = [];
        for (var i = 0; i < ranges.length; i += 2) {
          var from = mapping.map(ranges[i], 1),
              to = mapping.map(ranges[i + 1], -1);
          if (from <= to) {
            result.push(from, to);
          }
        }
        return result;
      }

      // : (HistoryState, EditorState, (tr: Transaction), bool)
      // Apply the latest event from one branch to the document and shift the event
      // onto the other branch.
      function histTransaction(history, state, dispatch, redo) {
        var preserveItems = mustPreserveItems(state),
            histOptions = historyKey.get(state).spec.config;
        var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);
        if (!pop) {
          return;
        }

        var selection = pop.selection.resolve(pop.transform.doc);
        var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);

        var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0);
        dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo, historyState: newHist }).scrollIntoView());
      }

      var cachedPreserveItems = false;
      var cachedPreserveItemsPlugins = null;
      // Check whether any plugin in the given state has a
      // `historyPreserveItems` property in its spec, in which case we must
      // preserve steps exactly as they came in, so that they can be
      // rebased.
      function mustPreserveItems(state) {
        var plugins = state.plugins;
        if (cachedPreserveItemsPlugins != plugins) {
          cachedPreserveItems = false;
          cachedPreserveItemsPlugins = plugins;
          for (var i = 0; i < plugins.length; i++) {
            if (plugins[i].spec.historyPreserveItems) {
              cachedPreserveItems = true;
              break;
            }
          }
        }
        return cachedPreserveItems;
      }

      // :: (Transaction) → Transaction
      // Set a flag on the given transaction that will prevent further steps
      // from being appended to an existing history event (so that they
      // require a separate undo command to undo).
      function closeHistory(tr) {
        return tr.setMeta(closeHistoryKey, true);
      }

      var historyKey = new dist$2.PluginKey("history");
      var closeHistoryKey = new dist$2.PluginKey("closeHistory");

      // :: (?Object) → Plugin
      // Returns a plugin that enables the undo history for an editor. The
      // plugin will track undo and redo stacks, which can be used with the
      // [`undo`](#history.undo) and [`redo`](#history.redo) commands.
      //
      // You can set an `"addToHistory"` [metadata
      // property](#state.Transaction.setMeta) of `false` on a transaction
      // to prevent it from being rolled back by undo.
      //
      //   config::-
      //   Supports the following configuration options:
      //
      //     depth:: ?number
      //     The amount of history events that are collected before the
      //     oldest events are discarded. Defaults to 100.
      //
      //     newGroupDelay:: ?number
      //     The delay between changes after which a new group should be
      //     started. Defaults to 500 (milliseconds). Note that when changes
      //     aren't adjacent, a new group is always started.
      function history(config) {
        config = { depth: config && config.depth || 100,
          newGroupDelay: config && config.newGroupDelay || 500 };
        return new dist$2.Plugin({
          key: historyKey,

          state: {
            init: function init() {
              return new HistoryState(Branch.empty, Branch.empty, null, 0);
            },
            apply: function apply(tr, hist, state) {
              return applyTransaction(hist, state, tr, config);
            }
          },

          config: config
        });
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // A command function that undoes the last change, if any.
      function undo(state, dispatch) {
        var hist = historyKey.getState(state);
        if (!hist || hist.done.eventCount == 0) {
          return false;
        }
        if (dispatch) {
          histTransaction(hist, state, dispatch, false);
        }
        return true;
      }

      // :: (EditorState, ?(tr: Transaction)) → bool
      // A command function that redoes the last undone change, if any.
      function redo(state, dispatch) {
        var hist = historyKey.getState(state);
        if (!hist || hist.undone.eventCount == 0) {
          return false;
        }
        if (dispatch) {
          histTransaction(hist, state, dispatch, true);
        }
        return true;
      }

      // :: (EditorState) → number
      // The amount of undoable events available in a given state.
      function undoDepth(state) {
        var hist = historyKey.getState(state);
        return hist ? hist.done.eventCount : 0;
      }

      // :: (EditorState) → number
      // The amount of redoable events available in a given editor state.
      function redoDepth(state) {
        var hist = historyKey.getState(state);
        return hist ? hist.undone.eventCount : 0;
      }

      exports.HistoryState = HistoryState;
      exports.closeHistory = closeHistory;
      exports.history = history;
      exports.undo = undo;
      exports.redo = redo;
      exports.undoDepth = undoDepth;
      exports.redoDepth = redoDepth;
      
    });

    unwrapExports(history_1);
    var history_2 = history_1.HistoryState;
    var history_3 = history_1.closeHistory;
    var history_4 = history_1.history;
    var history_5 = history_1.undo;
    var history_6 = history_1.redo;
    var history_7 = history_1.undoDepth;
    var history_8 = history_1.redoDepth;

    var base = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'",
      229: "q"
    };
    var shift = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ";",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: "\"",
      229: "Q"
    };

    var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
    var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
    var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
    var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac;

    // Fill in the digit keys
    for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

    // The function keys
    for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;

    // And the alphabetic keys
    for (var i = 65; i <= 90; i++) {
      base[i] = String.fromCharCode(i + 32);
      shift[i] = String.fromCharCode(i);
    }

    // For each code that doesn't have a shift-equivalent, copy the base name
    for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

    function keyName(event) {
      // Don't trust event.key in Chrome when there are modifiers until
      // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838
      var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || safari && event.shiftKey && event.key && event.key.length == 1;
      var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
      // Edge sometimes produces wrong names (Issue #3)
      if (name == "Esc") name = "Escape";
      if (name == "Del") name = "Delete";
      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
      if (name == "Left") name = "ArrowLeft";
      if (name == "Up") name = "ArrowUp";
      if (name == "Right") name = "ArrowRight";
      if (name == "Down") name = "ArrowDown";
      return name;
    }

    var w3cKeyname = keyName;
    keyName.base = base;
    keyName.shift = shift;

    var keymap_1 = createCommonjsModule(function (module, exports) {

      Object.defineProperty(exports, '__esModule', { value: true });

      function _interopDefault(ex) {
        return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
      }

      var keyName = _interopDefault(w3cKeyname);

      // declare global: navigator

      var mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;

      function normalizeKeyName(name) {
        var parts = name.split(/-(?!$)/),
            result = parts[parts.length - 1];
        if (result == "Space") {
          result = " ";
        }
        var alt, ctrl, shift, meta;
        for (var i = 0; i < parts.length - 1; i++) {
          var mod = parts[i];
          if (/^(cmd|meta|m)$/i.test(mod)) {
            meta = true;
          } else if (/^a(lt)?$/i.test(mod)) {
            alt = true;
          } else if (/^(c|ctrl|control)$/i.test(mod)) {
            ctrl = true;
          } else if (/^s(hift)?$/i.test(mod)) {
            shift = true;
          } else if (/^mod$/i.test(mod)) {
            if (mac) {
              meta = true;
            } else {
              ctrl = true;
            }
          } else {
            throw new Error("Unrecognized modifier name: " + mod);
          }
        }
        if (alt) {
          result = "Alt-" + result;
        }
        if (ctrl) {
          result = "Ctrl-" + result;
        }
        if (meta) {
          result = "Meta-" + result;
        }
        if (shift) {
          result = "Shift-" + result;
        }
        return result;
      }

      function normalize(map) {
        var copy = Object.create(null);
        for (var prop in map) {
          copy[normalizeKeyName(prop)] = map[prop];
        }
        return copy;
      }

      function modifiers(name, event, shift) {
        if (event.altKey) {
          name = "Alt-" + name;
        }
        if (event.ctrlKey) {
          name = "Ctrl-" + name;
        }
        if (event.metaKey) {
          name = "Meta-" + name;
        }
        if (shift !== false && event.shiftKey) {
          name = "Shift-" + name;
        }
        return name;
      }

      // :: (Object) → Plugin
      // Create a keymap plugin for the given set of bindings.
      //
      // Bindings should map key names to [command](#commands)-style
      // functions, which will be called with `(EditorState, dispatch,
      // EditorView)` arguments, and should return true when they've handled
      // the key. Note that the view argument isn't part of the command
      // protocol, but can be used as an escape hatch if a binding needs to
      // directly interact with the UI.
      //
      // Key names may be strings like `"Shift-Ctrl-Enter"`—a key
      // identifier prefixed with zero or more modifiers. Key identifiers
      // are based on the strings that can appear in
      // [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
      // Use lowercase letters to refer to letter keys (or uppercase letters
      // if you want shift to be held). You may use `"Space"` as an alias
      // for the `" "` name.
      //
      // Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
      // `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
      // `Meta-`) are recognized. For characters that are created by holding
      // shift, the `Shift-` prefix is implied, and should not be added
      // explicitly.
      //
      // You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
      // other platforms.
      //
      // You can add multiple keymap plugins to an editor. The order in
      // which they appear determines their precedence (the ones early in
      // the array get to dispatch first).
      function keymap(bindings) {
        return new dist$2.Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
      }

      // :: (Object) → (view: EditorView, event: dom.Event) → bool
      // Given a set of bindings (using the same format as
      // [`keymap`](#keymap.keymap), return a [keydown
      // handler](#view.EditorProps.handleKeyDown) handles them.
      function keydownHandler(bindings) {
        var map = normalize(bindings);
        return function (view, event) {
          var name = keyName(event),
              isChar = name.length == 1 && name != " ",
              baseName;
          var direct = map[modifiers(name, event, !isChar)];
          if (direct && direct(view.state, view.dispatch, view)) {
            return true;
          }
          if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = keyName.base[event.keyCode]) && baseName != name) {
            var fromCode = map[modifiers(baseName, event, true)];
            if (fromCode && fromCode(view.state, view.dispatch, view)) {
              return true;
            }
          }
          return false;
        };
      }

      exports.keymap = keymap;
      exports.keydownHandler = keydownHandler;
      
    });

    unwrapExports(keymap_1);
    var keymap_2 = keymap_1.keymap;
    var keymap_3 = keymap_1.keydownHandler;

    var dist$4 = createCommonjsModule(function (module, exports) {

      Object.defineProperty(exports, '__esModule', { value: true });

      var result = {};
      if (typeof navigator != "undefined" && typeof document != "undefined") {
        var ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
        var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
        var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

        result.mac = /Mac/.test(navigator.platform);
        var ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
        result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
        result.gecko = !ie && /gecko\/(\d+)/i.test(navigator.userAgent);
        result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
        var chrome = !ie && /Chrome\/(\d+)/.exec(navigator.userAgent);
        result.chrome = !!chrome;
        result.chrome_version = chrome && +chrome[1];
        result.ios = !ie && /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
        result.android = /Android \d/.test(navigator.userAgent);
        result.webkit = !ie && 'WebkitAppearance' in document.documentElement.style;
        result.safari = /Apple Computer/.test(navigator.vendor);
        result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
      }

      var domIndex = function domIndex(node) {
        for (var index = 0;; index++) {
          node = node.previousSibling;
          if (!node) {
            return index;
          }
        }
      };

      var parentNode = function parentNode(node) {
        var parent = node.parentNode;
        return parent && parent.nodeType == 11 ? parent.host : parent;
      };

      var textRange = function textRange(node, from, to) {
        var range = document.createRange();
        range.setEnd(node, to == null ? node.nodeValue.length : to);
        range.setStart(node, from || 0);
        return range;
      };

      // Scans forward and backward through DOM positions equivalent to the
      // given one to see if the two are in the same place (i.e. after a
      // text node vs at the end of that text node)
      var isEquivalentPosition = function isEquivalentPosition(node, off, targetNode, targetOff) {
        return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
      };

      var atomElements = /^(img|br|input|textarea|hr)$/i;

      function scanFor(node, off, targetNode, targetOff, dir) {
        for (;;) {
          if (node == targetNode && off == targetOff) {
            return true;
          }
          if (off == (dir < 0 ? 0 : nodeSize(node)) || node.nodeType == 3 && node.nodeValue == "\ufeff") {
            var parent = node.parentNode;
            if (parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false") {
              return false;
            }
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
          } else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            off = dir < 0 ? nodeSize(node) : 0;
          } else {
            return false;
          }
        }
      }

      function nodeSize(node) {
        return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
      }

      function hasBlockDesc(dom) {
        var desc = dom.pmViewDesc;
        return desc && desc.node && desc.node.isBlock;
      }

      // Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
      // (isCollapsed inappropriately returns true in shadow dom)
      var selectionCollapsed = function selectionCollapsed(domSel) {
        var collapsed = domSel.isCollapsed;
        if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
          collapsed = false;
        }
        return collapsed;
      };

      function keyEvent(keyCode, key) {
        var event = document.createEvent("Event");
        event.initEvent("keydown", true, true);
        event.keyCode = keyCode;
        event.key = event.code = key;
        return event;
      }

      function windowRect(win) {
        return { left: 0, right: win.innerWidth,
          top: 0, bottom: win.innerHeight };
      }

      function getSide(value, side) {
        return typeof value == "number" ? value : value[side];
      }

      function scrollRectIntoView(view, rect, startDOM) {
        var scrollThreshold = view.someProp("scrollThreshold") || 0,
            scrollMargin = view.someProp("scrollMargin") || 5;
        var doc = view.dom.ownerDocument,
            win = doc.defaultView;
        for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {
          if (!parent) {
            break;
          }
          if (parent.nodeType != 1) {
            continue;
          }
          var atTop = parent == doc.body || parent.nodeType != 1;
          var bounding = atTop ? windowRect(win) : parent.getBoundingClientRect();
          var moveX = 0,
              moveY = 0;
          if (rect.top < bounding.top + getSide(scrollThreshold, "top")) {
            moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
          } else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) {
            moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
          }
          if (rect.left < bounding.left + getSide(scrollThreshold, "left")) {
            moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
          } else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) {
            moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
          }
          if (moveX || moveY) {
            if (atTop) {
              win.scrollBy(moveX, moveY);
            } else {
              if (moveY) {
                parent.scrollTop += moveY;
              }
              if (moveX) {
                parent.scrollLeft += moveX;
              }
            }
          }
          if (atTop) {
            break;
          }
        }
      }

      // Store the scroll position of the editor's parent nodes, along with
      // the top position of an element near the top of the editor, which
      // will be used to make sure the visible viewport remains stable even
      // when the size of the content above changes.
      function storeScrollPos(view) {
        var rect = view.dom.getBoundingClientRect(),
            startY = Math.max(0, rect.top);
        var doc = view.dom.ownerDocument;
        var refDOM, refTop;
        for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
          var dom = view.root.elementFromPoint(x, y);
          if (dom == view.dom || !view.dom.contains(dom)) {
            continue;
          }
          var localRect = dom.getBoundingClientRect();
          if (localRect.top >= startY - 20) {
            refDOM = dom;
            refTop = localRect.top;
            break;
          }
        }
        var stack = [];
        for (var dom$1 = view.dom; dom$1; dom$1 = parentNode(dom$1)) {
          stack.push({ dom: dom$1, top: dom$1.scrollTop, left: dom$1.scrollLeft });
          if (dom$1 == doc.body) {
            break;
          }
        }
        return { refDOM: refDOM, refTop: refTop, stack: stack };
      }

      // Reset the scroll position of the editor's parent nodes to that what
      // it was before, when storeScrollPos was called.
      function resetScrollPos(ref) {
        var refDOM = ref.refDOM;
        var refTop = ref.refTop;
        var stack = ref.stack;

        var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
        var dTop = newRefTop == 0 ? 0 : newRefTop - refTop;
        for (var i = 0; i < stack.length; i++) {
          var ref$1 = stack[i];
          var dom = ref$1.dom;
          var top = ref$1.top;
          var left = ref$1.left;
          if (dom.scrollTop != top + dTop) {
            dom.scrollTop = top + dTop;
          }
          if (dom.scrollLeft != left) {
            dom.scrollLeft = left;
          }
        }
      }

      function findOffsetInNode(node, coords) {
        var closest,
            dxClosest = 2e8,
            coordsClosest,
            offset = 0;
        var rowBot = coords.top,
            rowTop = coords.top;
        for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
          var rects = void 0;
          if (child.nodeType == 1) {
            rects = child.getClientRects();
          } else if (child.nodeType == 3) {
            rects = textRange(child).getClientRects();
          } else {
            continue;
          }

          for (var i = 0; i < rects.length; i++) {
            var rect = rects[i];
            if (rect.top <= rowBot && rect.bottom >= rowTop) {
              rowBot = Math.max(rect.bottom, rowBot);
              rowTop = Math.min(rect.top, rowTop);
              var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
              if (dx < dxClosest) {
                closest = child;
                dxClosest = dx;
                coordsClosest = dx && closest.nodeType == 3 ? { left: rect.right < coords.left ? rect.right : rect.left, top: coords.top } : coords;
                if (child.nodeType == 1 && dx) {
                  offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
                }
                continue;
              }
            }
            if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) {
              offset = childIndex + 1;
            }
          }
        }
        if (closest && closest.nodeType == 3) {
          return findOffsetInText(closest, coordsClosest);
        }
        if (!closest || dxClosest && closest.nodeType == 1) {
          return { node: node, offset: offset };
        }
        return findOffsetInNode(closest, coordsClosest);
      }

      function findOffsetInText(node, coords) {
        var len = node.nodeValue.length;
        var range = document.createRange();
        for (var i = 0; i < len; i++) {
          range.setEnd(node, i + 1);
          range.setStart(node, i);
          var rect = singleRect(range, 1);
          if (rect.top == rect.bottom) {
            continue;
          }
          if (inRect(coords, rect)) {
            return { node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
          }
        }
        return { node: node, offset: 0 };
      }

      function inRect(coords, rect) {
        return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
      }

      function targetKludge(dom, coords) {
        var parent = dom.parentNode;
        if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
          return parent;
        }
        return dom;
      }

      function posFromElement(view, elt, coords) {
        var ref = findOffsetInNode(elt, coords);
        var node = ref.node;
        var offset = ref.offset;
        var bias = -1;
        if (node.nodeType == 1 && !node.firstChild) {
          var rect = node.getBoundingClientRect();
          bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
        }
        return view.docView.posFromDOM(node, offset, bias);
      }

      function posFromCaret(view, node, offset, coords) {
        // Browser (in caretPosition/RangeFromPoint) will agressively
        // normalize towards nearby inline nodes. Since we are interested in
        // positions between block nodes too, we first walk up the hierarchy
        // of nodes to see if there are block nodes that the coordinates
        // fall outside of. If so, we take the position before/after that
        // block. If not, we call `posFromDOM` on the raw node/offset.
        var outside = -1;
        for (var cur = node;;) {
          if (cur == view.dom) {
            break;
          }
          var desc = view.docView.nearestDesc(cur, true);
          if (!desc) {
            return null;
          }
          if (desc.node.isBlock && desc.parent) {
            var rect = desc.dom.getBoundingClientRect();
            if (rect.left > coords.left || rect.top > coords.top) {
              outside = desc.posBefore;
            } else if (rect.right < coords.left || rect.bottom < coords.top) {
              outside = desc.posAfter;
            } else {
              break;
            }
          }
          cur = desc.dom.parentNode;
        }
        return outside > -1 ? outside : view.docView.posFromDOM(node, offset);
      }

      function elementFromPoint(element, coords, box) {
        var len = element.childNodes.length;
        if (len && box.top < box.bottom) {
          for (var startI = Math.max(0, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2), i = startI;;) {
            var child = element.childNodes[i];
            if (child.nodeType == 1) {
              var rects = child.getClientRects();
              for (var j = 0; j < rects.length; j++) {
                var rect = rects[j];
                if (inRect(coords, rect)) {
                  return elementFromPoint(child, coords, rect);
                }
              }
            }
            if ((i = (i + 1) % len) == startI) {
              break;
            }
          }
        }
        return element;
      }

      // Given an x,y position on the editor, get the position in the document.
      function posAtCoords(view, coords) {
        var root = view.root,
            node,
            offset;
        if (root.caretPositionFromPoint) {
          var pos$1 = root.caretPositionFromPoint(coords.left, coords.top);
          if (pos$1) {
            var assign;
            assign = pos$1, node = assign.offsetNode, offset = assign.offset;
          }
        }
        if (!node && root.caretRangeFromPoint) {
          var range = root.caretRangeFromPoint(coords.left, coords.top);
          if (range) {
            var assign$1;
            assign$1 = range, node = assign$1.startContainer, offset = assign$1.startOffset;
          }
        }

        var elt = root.elementFromPoint(coords.left, coords.top + 1),
            pos;
        if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
          var box = view.dom.getBoundingClientRect();
          if (!inRect(coords, box)) {
            return null;
          }
          elt = elementFromPoint(view.dom, coords, box);
          if (!elt) {
            return null;
          }
        }
        elt = targetKludge(elt, coords);
        if (node) {
          // Suspiciously specific kludge to work around caret*FromPoint
          // never returning a position at the end of the document
          if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) {
            pos = view.state.doc.content.size;
          }
          // Ignore positions directly after a BR, since caret*FromPoint
          // 'round up' positions that would be more accurately placed
          // before the BR node.
          else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR") {
              pos = posFromCaret(view, node, offset, coords);
            }
        }
        if (pos == null) {
          pos = posFromElement(view, elt, coords);
        }

        var desc = view.docView.nearestDesc(elt, true);
        return { pos: pos, inside: desc ? desc.posAtStart - desc.border : -1 };
      }

      function singleRect(object, bias) {
        var rects = object.getClientRects();
        return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
      }

      // : (EditorView, number) → {left: number, top: number, right: number, bottom: number}
      // Given a position in the document model, get a bounding box of the
      // character at that position, relative to the window.
      function coordsAtPos(view, pos) {
        var ref = view.docView.domFromPos(pos);
        var node = ref.node;
        var offset = ref.offset;

        // These browsers support querying empty text ranges
        if (node.nodeType == 3 && (result.chrome || result.gecko)) {
          var rect = singleRect(textRange(node, offset, offset), 0);
          // Firefox returns bad results (the position before the space)
          // when querying a position directly after line-broken
          // whitespace. Detect this situation and and kludge around it
          if (result.gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
            var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
            if (Math.abs(rectBefore.left - rect.left) < 1 && rectBefore.top == rect.top) {
              var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
              return flattenV(rectAfter, rectAfter.left < rectBefore.left);
            }
          }
          return rect;
        }

        if (node.nodeType == 1 && !view.state.doc.resolve(pos).parent.inlineContent) {
          // Return a horizontal line in block context
          var top = true,
              rect$1;
          if (offset < node.childNodes.length) {
            var after = node.childNodes[offset];
            if (after.nodeType == 1) {
              rect$1 = after.getBoundingClientRect();
            }
          }
          if (!rect$1 && offset) {
            var before = node.childNodes[offset - 1];
            if (before.nodeType == 1) {
              rect$1 = before.getBoundingClientRect();top = false;
            }
          }
          return flattenH(rect$1 || parent.getBoundingClientRect(), top);
        }

        // Not Firefox/Chrome, or not in a text node, so we have to use
        // actual element/character rectangles to get a solution (this part
        // is not very bidi-safe)
        //
        // Try the left side first, fall back to the right one if that
        // doesn't work.
        for (var dir = -1; dir < 2; dir += 2) {
          if (dir < 0 && offset) {
            var prev = void 0,
                target = node.nodeType == 3 ? textRange(node, offset - 1, offset) : (prev = node.childNodes[offset - 1]).nodeType == 3 ? textRange(prev) : prev.nodeType == 1 && prev.nodeName != "BR" ? prev : null; // BR nodes tend to only return the rectangle before them
            if (target) {
              var rect$2 = singleRect(target, 1);
              if (rect$2.top < rect$2.bottom) {
                return flattenV(rect$2, false);
              }
            }
          } else if (dir > 0 && offset < nodeSize(node)) {
            var next = void 0,
                target$1 = node.nodeType == 3 ? textRange(node, offset, offset + 1) : (next = node.childNodes[offset]).nodeType == 3 ? textRange(next) : next.nodeType == 1 ? next : null;
            if (target$1) {
              var rect$3 = singleRect(target$1, -1);
              if (rect$3.top < rect$3.bottom) {
                return flattenV(rect$3, true);
              }
            }
          }
        }
        // All else failed, just try to get a rectangle for the target node
        return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, 0), false);
      }

      function flattenV(rect, left) {
        if (rect.width == 0) {
          return rect;
        }
        var x = left ? rect.left : rect.right;
        return { top: rect.top, bottom: rect.bottom, left: x, right: x };
      }

      function flattenH(rect, top) {
        if (rect.height == 0) {
          return rect;
        }
        var y = top ? rect.top : rect.bottom;
        return { top: y, bottom: y, left: rect.left, right: rect.right };
      }

      function withFlushedState(view, state, f) {
        var viewState = view.state,
            active = view.root.activeElement;
        if (viewState != state || !view.inDOMChange) {
          view.updateState(state);
        }
        if (active != view.dom) {
          view.focus();
        }
        try {
          return f();
        } finally {
          if (viewState != state) {
            view.updateState(viewState);
          }
          if (active != view.dom) {
            active.focus();
          }
        }
      }

      // : (EditorView, number, number)
      // Whether vertical position motion in a given direction
      // from a position would leave a text block.
      function endOfTextblockVertical(view, state, dir) {
        var sel = state.selection;
        var $pos = dir == "up" ? sel.$anchor.min(sel.$head) : sel.$anchor.max(sel.$head);
        return withFlushedState(view, state, function () {
          var ref = view.docView.domFromPos($pos.pos);
          var dom = ref.node;
          for (;;) {
            var nearest = view.docView.nearestDesc(dom, true);
            if (!nearest) {
              break;
            }
            if (nearest.node.isBlock) {
              dom = nearest.dom;break;
            }
            dom = nearest.dom.parentNode;
          }
          var coords = coordsAtPos(view, $pos.pos);
          for (var child = dom.firstChild; child; child = child.nextSibling) {
            var boxes = void 0;
            if (child.nodeType == 1) {
              boxes = child.getClientRects();
            } else if (child.nodeType == 3) {
              boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
            } else {
              continue;
            }
            for (var i = 0; i < boxes.length; i++) {
              var box = boxes[i];
              if (box.bottom > box.top && (dir == "up" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1)) {
                return false;
              }
            }
          }
          return true;
        });
      }

      var maybeRTL = /[\u0590-\u08ac]/;

      function endOfTextblockHorizontal(view, state, dir) {
        var ref = state.selection;
        var $head = ref.$head;
        if (!$head.parent.isTextblock) {
          return false;
        }
        var offset = $head.parentOffset,
            atStart = !offset,
            atEnd = offset == $head.parent.content.size;
        var sel = getSelection();
        // If the textblock is all LTR, or the browser doesn't support
        // Selection.modify (Edge), fall back to a primitive approach
        if (!maybeRTL.test($head.parent.textContent) || !sel.modify) {
          return dir == "left" || dir == "backward" ? atStart : atEnd;
        }

        return withFlushedState(view, state, function () {
          // This is a huge hack, but appears to be the best we can
          // currently do: use `Selection.modify` to move the selection by
          // one character, and see if that moves the cursor out of the
          // textblock (or doesn't move it at all, when at the start/end of
          // the document).
          var oldRange = sel.getRangeAt(0),
              oldNode = sel.focusNode,
              oldOff = sel.focusOffset;
          sel.modify("move", dir, "character");
          var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
          var result$$1 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
          // Restore the previous selection
          sel.removeAllRanges();
          sel.addRange(oldRange);
          return result$$1;
        });
      }

      var cachedState = null;
      var cachedDir = null;
      var cachedResult = false;
      function endOfTextblock(view, state, dir) {
        if (cachedState == state && cachedDir == dir) {
          return cachedResult;
        }
        cachedState = state;cachedDir = dir;
        return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
      }

      // NodeView:: interface
      //
      // By default, document nodes are rendered using the result of the
      // [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed
      // entirely by the editor. For some use cases, such as embedded
      // node-specific editing interfaces, you want more control over
      // the behavior of a node's in-editor representation, and need to
      // [define](#view.EditorProps.nodeViews) a custom node view.
      //
      // Objects returned as node views must conform to this interface.
      //
      //   dom:: ?dom.Node
      //   The outer DOM node that represents the document node. When not
      //   given, the default strategy is used to create a DOM node.
      //
      //   contentDOM:: ?dom.Node
      //   The DOM node that should hold the node's content. Only meaningful
      //   if the node view also defines a `dom` property and if its node
      //   type is not a leaf node type. When this is present, ProseMirror
      //   will take care of rendering the node's children into it. When it
      //   is not present, the node view itself is responsible for rendering
      //   (or deciding not to render) its child nodes.
      //
      //   update:: ?(node: Node, decorations: [Decoration]) → bool
      //   When given, this will be called when the view is updating itself.
      //   It will be given a node (possibly of a different type), and an
      //   array of active decorations (which are automatically drawn, and
      //   the node view may ignore if it isn't interested in them), and
      //   should return true if it was able to update to that node, and
      //   false otherwise. If the node view has a `contentDOM` property (or
      //   no `dom` property), updating its child nodes will be handled by
      //   ProseMirror.
      //
      //   selectNode:: ?()
      //   Can be used to override the way the node's selected status (as a
      //   node selection) is displayed.
      //
      //   deselectNode:: ?()
      //   When defining a `selectNode` method, you should also provide a
      //   `deselectNode` method to remove the effect again.
      //
      //   setSelection:: ?(anchor: number, head: number, root: dom.Document)
      //   This will be called to handle setting the selection inside the
      //   node. The `anchor` and `head` positions are relative to the start
      //   of the node. By default, a DOM selection will be created between
      //   the DOM positions corresponding to those positions, but if you
      //   override it you can do something else.
      //
      //   stopEvent:: ?(event: dom.Event) → bool
      //   Can be used to prevent the editor view from trying to handle some
      //   or all DOM events that bubble up from the node view. Events for
      //   which this returns true are not handled by the editor.
      //
      //   ignoreMutation:: ?(dom.MutationRecord) → bool
      //   Called when a DOM
      //   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
      //   happens within the view. Return false if the editor should
      //   re-parse the range around the mutation, true if it can safely be
      //   ignored.
      //
      //   destroy:: ?()
      //   Called when the node view is removed from the editor or the whole
      //   editor is destroyed.

      // View descriptions are data structures that describe the DOM that is
      // used to represent the editor's content. They are used for:
      //
      // - Incremental redrawing when the document changes
      //
      // - Figuring out what part of the document a given DOM position
      //   corresponds to
      //
      // - Wiring in custom implementations of the editing interface for a
      //   given node
      //
      // They form a doubly-linked mutable tree, starting at `view.docView`.

      var NOT_DIRTY = 0;
      var CHILD_DIRTY = 1;
      var CONTENT_DIRTY = 2;
      var NODE_DIRTY = 3;

      // Superclass for the various kinds of descriptions. Defines their
      // basic structure and shared methods.
      var ViewDesc = function ViewDesc(parent, children, dom, contentDOM) {
        this.parent = parent;
        this.children = children;
        this.dom = dom;
        // An expando property on the DOM node provides a link back to its
        // description.
        dom.pmViewDesc = this;
        // This is the node that holds the child views. It may be null for
        // descs that don't have children.
        this.contentDOM = contentDOM;
        this.dirty = NOT_DIRTY;
      };

      var prototypeAccessors$1 = { beforePosition: {}, size: {}, border: {}, posBefore: {}, posAtStart: {}, posAfter: {}, posAtEnd: {}, contentLost: {} };

      // Used to check whether a given description corresponds to a
      // widget/mark/node.
      ViewDesc.prototype.matchesWidget = function matchesWidget() {
        return false;
      };
      ViewDesc.prototype.matchesMark = function matchesMark() {
        return false;
      };
      ViewDesc.prototype.matchesNode = function matchesNode() {
        return false;
      };
      ViewDesc.prototype.matchesHack = function matchesHack() {
        return false;
      };

      prototypeAccessors$1.beforePosition.get = function () {
        return false;
      };

      // : () → ?ParseRule
      // When parsing in-editor content (in domchange.js), we allow
      // descriptions to determine the parse rules that should be used to
      // parse them.
      ViewDesc.prototype.parseRule = function parseRule() {
        return null;
      };

      // : (dom.Event) → bool
      // Used by the editor's event handler to ignore events that come
      // from certain descs.
      ViewDesc.prototype.stopEvent = function stopEvent() {
        return false;
      };

      // The size of the content represented by this desc.
      prototypeAccessors$1.size.get = function () {
        var this$1 = this;

        var size = 0;
        for (var i = 0; i < this.children.length; i++) {
          size += this$1.children[i].size;
        }
        return size;
      };

      // For block nodes, this represents the space taken up by their
      // start/end tokens.
      prototypeAccessors$1.border.get = function () {
        return 0;
      };

      ViewDesc.prototype.destroy = function destroy() {
        var this$1 = this;

        this.parent = null;
        if (this.dom.pmViewDesc == this) {
          this.dom.pmViewDesc = null;
        }
        for (var i = 0; i < this.children.length; i++) {
          this$1.children[i].destroy();
        }
      };

      ViewDesc.prototype.posBeforeChild = function posBeforeChild(child) {
        var this$1 = this;

        for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
          var cur = this$1.children[i];
          if (cur == child) {
            return pos;
          }
          pos += cur.size;
        }
      };

      prototypeAccessors$1.posBefore.get = function () {
        return this.parent.posBeforeChild(this);
      };

      prototypeAccessors$1.posAtStart.get = function () {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      };

      prototypeAccessors$1.posAfter.get = function () {
        return this.posBefore + this.size;
      };

      prototypeAccessors$1.posAtEnd.get = function () {
        return this.posAtStart + this.size - 2 * this.border;
      };

      // : (dom.Node, number, ?number) → number
      ViewDesc.prototype.localPosFromDOM = function localPosFromDOM(dom, offset, bias) {
        var this$1 = this;

        // If the DOM position is in the content, use the child desc after
        // it to figure out a position.
        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
          if (bias < 0) {
            var domBefore, desc;
            if (dom == this.contentDOM) {
              domBefore = dom.childNodes[offset - 1];
            } else {
              while (dom.parentNode != this.contentDOM) {
                dom = dom.parentNode;
              }
              domBefore = dom.previousSibling;
            }
            while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
              domBefore = domBefore.previousSibling;
            }
            return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
          } else {
            var domAfter, desc$1;
            if (dom == this.contentDOM) {
              domAfter = dom.childNodes[offset];
            } else {
              while (dom.parentNode != this.contentDOM) {
                dom = dom.parentNode;
              }
              domAfter = dom.nextSibling;
            }
            while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
              domAfter = domAfter.nextSibling;
            }
            return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
          }
        }
        // Otherwise, use various heuristics, falling back on the bias
        // parameter, to determine whether to return the position at the
        // start or at the end of this view desc.
        var atEnd;
        if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
          atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
        } else if (this.dom.firstChild) {
          if (offset == 0) {
            for (var search = dom;; search = search.parentNode) {
              if (search == this$1.dom) {
                atEnd = false;break;
              }
              if (search.parentNode.firstChild != search) {
                break;
              }
            }
          }
          if (atEnd == null && offset == dom.childNodes.length) {
            for (var search$1 = dom;; search$1 = search$1.parentNode) {
              if (search$1 == this$1.dom) {
                atEnd = true;break;
              }
              if (search$1.parentNode.lastChild != search$1) {
                break;
              }
            }
          }
        }
        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
      };

      // Scan up the dom finding the first desc that is a descendant of
      // this one.
      ViewDesc.prototype.nearestDesc = function nearestDesc(dom, onlyNodes) {
        var this$1 = this;

        for (var first = true, cur = dom; cur; cur = cur.parentNode) {
          var desc = this$1.getDesc(cur);
          if (desc && (!onlyNodes || desc.node)) {
            // If dom is outside of this desc's nodeDOM, don't count it.
            if (first && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom) : desc.nodeDOM == dom)) {
              first = false;
            } else {
              return desc;
            }
          }
        }
      };

      ViewDesc.prototype.getDesc = function getDesc(dom) {
        var this$1 = this;

        var desc = dom.pmViewDesc;
        for (var cur = desc; cur; cur = cur.parent) {
          if (cur == this$1) {
            return desc;
          }
        }
      };

      ViewDesc.prototype.posFromDOM = function posFromDOM(dom, offset, bias) {
        var this$1 = this;

        for (var scan = dom;; scan = scan.parentNode) {
          var desc = this$1.getDesc(scan);
          if (desc) {
            return desc.localPosFromDOM(dom, offset, bias);
          }
        }
      };

      // : (number) → ?NodeViewDesc
      // Find the desc for the node after the given pos, if any. (When a
      // parent node overrode rendering, there might not be one.)
      ViewDesc.prototype.descAt = function descAt(pos) {
        var this$1 = this;

        for (var i = 0, offset = 0; i < this.children.length; i++) {
          var child = this$1.children[i],
              end = offset + child.size;
          if (offset == pos && end != offset) {
            while (!child.border && child.children.length) {
              child = child.children[0];
            }
            return child;
          }
          if (pos < end) {
            return child.descAt(pos - offset - child.border);
          }
          offset = end;
        }
      };

      // : (number) → {node: dom.Node, offset: number}
      ViewDesc.prototype.domFromPos = function domFromPos(pos) {
        var this$1 = this;

        if (!this.contentDOM) {
          return { node: this.dom, offset: 0 };
        }
        for (var offset = 0, i = 0;; i++) {
          if (offset == pos) {
            while (i < this.children.length && this.children[i].beforePosition) {
              i++;
            }
            return { node: this$1.contentDOM, offset: i };
          }
          if (i == this$1.children.length) {
            throw new Error("Invalid position " + pos);
          }
          var child = this$1.children[i],
              end = offset + child.size;
          if (pos < end) {
            return child.domFromPos(pos - offset - child.border);
          }
          offset = end;
        }
      };

      // Used to find a DOM range in a single parent for a given changed
      // range.
      ViewDesc.prototype.parseRange = function parseRange(from, to, base) {
        var this$1 = this;
        if (base === void 0) base = 0;

        if (this.children.length == 0) {
          return { node: this.contentDOM, from: from, to: to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
        }

        var fromOffset = -1,
            toOffset = -1;
        for (var offset = 0, i = 0;; i++) {
          var child = this$1.children[i],
              end = offset + child.size;
          if (fromOffset == -1 && from <= end) {
            var childBase = offset + child.border;
            // FIXME maybe descend mark views to parse a narrower range?
            if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this$1.contentDOM.contains(child.contentDOM)) {
              return child.parseRange(from - childBase, to - childBase, base + childBase);
            }

            from = base + offset;
            for (var j = i; j > 0; j--) {
              var prev = this$1.children[j - 1];
              if (prev.size && prev.dom.parentNode == this$1.contentDOM && !prev.emptyChildAt(1)) {
                fromOffset = domIndex(prev.dom) + 1;
                break;
              }
              from -= prev.size;
            }
            if (fromOffset == -1) {
              fromOffset = 0;
            }
          }
          if (fromOffset > -1 && to <= end) {
            to = base + end;
            for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
              var next = this$1.children[j$1];
              if (next.size && next.dom.parentNode == this$1.contentDOM && !next.emptyChildAt(-1)) {
                toOffset = domIndex(next.dom);
                break;
              }
              to += next.size;
            }
            if (toOffset == -1) {
              toOffset = this$1.contentDOM.childNodes.length;
            }
            break;
          }
          offset = end;
        }
        return { node: this.contentDOM, from: from, to: to, fromOffset: fromOffset, toOffset: toOffset };
      };

      ViewDesc.prototype.emptyChildAt = function emptyChildAt(side) {
        if (this.border || !this.contentDOM || !this.children.length) {
          return false;
        }
        var child = this.children[side < 0 ? 0 : this.children.length - 1];
        return child.size == 0 || child.emptyChildAt(side);
      };

      // : (number) → dom.Node
      ViewDesc.prototype.domAfterPos = function domAfterPos(pos) {
        var ref = this.domFromPos(pos);
        var node = ref.node;
        var offset = ref.offset;
        if (node.nodeType != 1 || offset == node.childNodes.length) {
          throw new RangeError("No node after pos " + pos);
        }
        return node.childNodes[offset];
      };

      // : (number, number, dom.Document)
      // View descs are responsible for setting any selection that falls
      // entirely inside of them, so that custom implementations can do
      // custom things with the selection. Note that this falls apart when
      // a selection starts in such a node and ends in another, in which
      // case we just use whatever domFromPos produces as a best effort.
      ViewDesc.prototype.setSelection = function setSelection(anchor, head, root, force) {
        var this$1 = this;

        // If the selection falls entirely in a child, give it to that child
        var from = Math.min(anchor, head),
            to = Math.max(anchor, head);
        for (var i = 0, offset = 0; i < this.children.length; i++) {
          var child = this$1.children[i],
              end = offset + child.size;
          if (from > offset && to < end) {
            return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);
          }
          offset = end;
        }

        var anchorDOM = this.domFromPos(anchor),
            headDOM = this.domFromPos(head);
        var domSel = root.getSelection(),
            range = document.createRange();
        if (!force && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
          return;
        }

        // Selection.extend can be used to create an 'inverted' selection
        // (one where the focus is before the anchor), but not all
        // browsers support it yet.
        if (domSel.extend) {
          range.setEnd(anchorDOM.node, anchorDOM.offset);
          range.collapse(false);
        } else {
          if (anchor > head) {
            var tmp = anchorDOM;anchorDOM = headDOM;headDOM = tmp;
          }
          range.setEnd(headDOM.node, headDOM.offset);
          range.setStart(anchorDOM.node, anchorDOM.offset);
        }
        domSel.removeAllRanges();
        domSel.addRange(range);
        if (domSel.extend) {
          domSel.extend(headDOM.node, headDOM.offset);
        }
      };

      // : (dom.MutationRecord) → bool
      ViewDesc.prototype.ignoreMutation = function ignoreMutation(_mutation) {
        return !this.contentDOM;
      };

      prototypeAccessors$1.contentLost.get = function () {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      };

      // Remove a subtree of the element tree that has been touched
      // by a DOM change, so that the next update will redraw it.
      ViewDesc.prototype.markDirty = function markDirty(from, to) {
        var this$1 = this;

        for (var offset = 0, i = 0; i < this.children.length; i++) {
          var child = this$1.children[i],
              end = offset + child.size;
          if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
            var startInside = offset + child.border,
                endInside = end - child.border;
            if (from >= startInside && to <= endInside) {
              this$1.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
              if (from == startInside && to == endInside && child.contentLost) {
                child.dirty = NODE_DIRTY;
              } else {
                child.markDirty(from - startInside, to - startInside);
              }
              return;
            } else {
              child.dirty = NODE_DIRTY;
            }
          }
          offset = end;
        }
        this.dirty = CONTENT_DIRTY;
      };

      Object.defineProperties(ViewDesc.prototype, prototypeAccessors$1);

      // Reused array to avoid allocating fresh arrays for things that will
      // stay empty anyway.
      var nothing = [];

      // A widget desc represents a widget decoration, which is a DOM node
      // drawn between the document nodes.
      var WidgetViewDesc = function (ViewDesc) {
        function WidgetViewDesc(parent, widget, view, pos) {
          var self,
              dom = widget.type.toDOM;
          if (typeof dom == "function") {
            dom = dom(view, function () {
              if (!self) {
                return pos;
              }
              if (self.parent) {
                return self.parent.posBeforeChild(self);
              }
            });
          }
          if (!widget.type.spec.raw) {
            if (dom.nodeType != 1) {
              var wrap = document.createElement("span");
              wrap.appendChild(dom);
              dom = wrap;
            }
            dom.contentEditable = false;
            dom.classList.add("ProseMirror-widget");
          }
          ViewDesc.call(this, parent, nothing, dom, null);
          this.widget = widget;
          self = this;
        }

        if (ViewDesc) WidgetViewDesc.__proto__ = ViewDesc;
        WidgetViewDesc.prototype = Object.create(ViewDesc && ViewDesc.prototype);
        WidgetViewDesc.prototype.constructor = WidgetViewDesc;

        var prototypeAccessors$1 = { beforePosition: {} };

        prototypeAccessors$1.beforePosition.get = function () {
          return this.widget.type.side < 0;
        };

        WidgetViewDesc.prototype.matchesWidget = function matchesWidget(widget) {
          return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
        };

        WidgetViewDesc.prototype.parseRule = function parseRule() {
          return { ignore: true };
        };

        WidgetViewDesc.prototype.stopEvent = function stopEvent(event) {
          var stop = this.widget.spec.stopEvent;
          return stop ? stop(event) : false;
        };

        Object.defineProperties(WidgetViewDesc.prototype, prototypeAccessors$1);

        return WidgetViewDesc;
      }(ViewDesc);

      // A cursor wrapper is used to put the cursor in when newly typed text
      // needs to be styled differently from its surrounding text (for
      // example through storedMarks), so that the style of the text doesn't
      // visually 'pop' between typing it and actually updating the view.
      var CursorWrapperDesc = function (WidgetViewDesc) {
        function CursorWrapperDesc() {
          WidgetViewDesc.apply(this, arguments);
        }

        if (WidgetViewDesc) CursorWrapperDesc.__proto__ = WidgetViewDesc;
        CursorWrapperDesc.prototype = Object.create(WidgetViewDesc && WidgetViewDesc.prototype);
        CursorWrapperDesc.prototype.constructor = CursorWrapperDesc;

        CursorWrapperDesc.prototype.parseRule = function parseRule() {
          var content;
          for (var child = this.dom.firstChild; child; child = child.nextSibling) {
            var add = void 0;
            if (child.nodeType == 3) {
              var text = child.nodeValue.replace(/\ufeff/g, "");
              if (!text) {
                continue;
              }
              add = document.createTextNode(text);
            } else if (child.textContent == "\ufeff") {
              continue;
            } else {
              add = child.cloneNode(true);
            }
            if (!content) {
              content = document.createDocumentFragment();
            }
            content.appendChild(add);
          }
          if (content) {
            return { skip: content };
          } else {
            return WidgetViewDesc.prototype.parseRule.call(this);
          }
        };

        CursorWrapperDesc.prototype.ignoreMutation = function ignoreMutation() {
          return false;
        };

        return CursorWrapperDesc;
      }(WidgetViewDesc);

      // A mark desc represents a mark. May have multiple children,
      // depending on how the mark is split. Note that marks are drawn using
      // a fixed nesting order, for simplicity and predictability, so in
      // some cases they will be split more often than would appear
      // necessary.
      var MarkViewDesc = function (ViewDesc) {
        function MarkViewDesc(parent, mark, dom, contentDOM) {
          ViewDesc.call(this, parent, [], dom, contentDOM);
          this.mark = mark;
        }

        if (ViewDesc) MarkViewDesc.__proto__ = ViewDesc;
        MarkViewDesc.prototype = Object.create(ViewDesc && ViewDesc.prototype);
        MarkViewDesc.prototype.constructor = MarkViewDesc;

        MarkViewDesc.create = function create(parent, mark, inline, view) {
          var custom = view.nodeViews[mark.type.name];
          var spec = custom && custom(mark, view, inline);
          if (!spec || !spec.dom) {
            spec = dist.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
          }
          return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
        };

        MarkViewDesc.prototype.parseRule = function parseRule() {
          return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
        };

        MarkViewDesc.prototype.matchesMark = function matchesMark(mark) {
          return this.dirty != NODE_DIRTY && this.mark.eq(mark);
        };

        MarkViewDesc.prototype.markDirty = function markDirty(from, to) {
          ViewDesc.prototype.markDirty.call(this, from, to);
          // Move dirty info to nearest node view
          if (this.dirty != NOT_DIRTY) {
            var parent = this.parent;
            while (!parent.node) {
              parent = parent.parent;
            }
            if (parent.dirty < this.dirty) {
              parent.dirty = this.dirty;
            }
            this.dirty = NOT_DIRTY;
          }
        };

        return MarkViewDesc;
      }(ViewDesc);

      // Node view descs are the main, most common type of view desc, and
      // correspond to an actual node in the document. Unlike mark descs,
      // they populate their child array themselves.
      var NodeViewDesc = function (ViewDesc) {
        function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
          ViewDesc.call(this, parent, node.isLeaf ? nothing : [], dom, contentDOM);
          this.nodeDOM = nodeDOM;
          this.node = node;
          this.outerDeco = outerDeco;
          this.innerDeco = innerDeco;
          if (contentDOM) {
            this.updateChildren(view, pos);
          }
        }

        if (ViewDesc) NodeViewDesc.__proto__ = ViewDesc;
        NodeViewDesc.prototype = Object.create(ViewDesc && ViewDesc.prototype);
        NodeViewDesc.prototype.constructor = NodeViewDesc;

        var prototypeAccessors$2 = { size: {}, border: {} };

        // By default, a node is rendered using the `toDOM` method from the
        // node type spec. But client code can use the `nodeViews` spec to
        // supply a custom node view, which can influence various aspects of
        // the way the node works.
        //
        // (Using subclassing for this was intentionally decided against,
        // since it'd require exposing a whole slew of finnicky
        // implementation details to the user code that they probably will
        // never need.)
        NodeViewDesc.create = function create(parent, node, outerDeco, innerDeco, view, pos) {
          var custom = view.nodeViews[node.type.name],
              descObj;
          var spec = custom && custom(node, view, function () {
            // (This is a function that allows the custom view to find its
            // own position)
            if (!descObj) {
              return pos;
            }
            if (descObj.parent) {
              return descObj.parent.posBeforeChild(descObj);
            }
          }, outerDeco);

          var dom = spec && spec.dom,
              contentDOM = spec && spec.contentDOM;
          if (node.isText) {
            if (!dom) {
              dom = document.createTextNode(node.text);
            } else if (dom.nodeType != 3) {
              throw new RangeError("Text must be rendered as a DOM text node");
            }
          } else if (!dom) {
            var assign;
            assign = dist.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)), dom = assign.dom, contentDOM = assign.contentDOM;
          }
          if (!contentDOM && !node.isText && dom.nodeName != "BR") {
            // Chrome gets confused by <br contenteditable=false>
            if (!dom.hasAttribute("contenteditable")) {
              dom.contentEditable = false;
            }
            if (node.type.spec.draggable) {
              dom.draggable = true;
            }
          }

          var nodeDOM = dom;
          dom = applyOuterDeco(dom, outerDeco, node);

          if (spec) {
            return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos + 1);
          } else if (node.isText) {
            return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
          } else {
            return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1);
          }
        };

        NodeViewDesc.prototype.parseRule = function parseRule() {
          var this$1 = this;

          // Experimental kludge to allow opt-in re-parsing of nodes
          if (this.node.type.spec.reparseInView) {
            return null;
          }
          // FIXME the assumption that this can always return the current
          // attrs means that if the user somehow manages to change the
          // attrs in the dom, that won't be picked up. Not entirely sure
          // whether this is a problem
          var rule = { node: this.node.type.name, attrs: this.node.attrs };
          if (this.node.type.spec.code) {
            rule.preserveWhitespace = "full";
          }
          if (this.contentDOM && !this.contentLost) {
            rule.contentElement = this.contentDOM;
          } else {
            rule.getContent = function () {
              return this$1.contentDOM ? dist.Fragment.empty : this$1.node.content;
            };
          }
          return rule;
        };

        NodeViewDesc.prototype.matchesNode = function matchesNode(node, outerDeco, innerDeco) {
          return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
        };

        prototypeAccessors$2.size.get = function () {
          return this.node.nodeSize;
        };

        prototypeAccessors$2.border.get = function () {
          return this.node.isLeaf ? 0 : 1;
        };

        // Syncs `this.children` to match `this.node.content` and the local
        // decorations, possibly introducing nesting for marks. Then, in a
        // separate step, syncs the DOM inside `this.contentDOM` to
        // `this.children`.
        NodeViewDesc.prototype.updateChildren = function updateChildren(view, pos) {
          var this$1 = this;

          var updater = new ViewTreeUpdater(this),
              inline = this.node.inlineContent;
          iterDeco(this.node, this.innerDeco, function (widget, i) {
            if (widget.spec.marks) {
              updater.syncToMarks(widget.spec.marks, inline, view);
            } else if (widget.type.side >= 0) {
              updater.syncToMarks(i == this$1.node.childCount ? dist.Mark.none : this$1.node.child(i).marks, inline, view);
            }
            // If the next node is a desc matching this widget, reuse it,
            // otherwise insert the widget as a new view desc.
            updater.placeWidget(widget, view, pos);
          }, function (child, outerDeco, innerDeco, i) {
            // Make sure the wrapping mark descs match the node's marks.
            updater.syncToMarks(child.marks, inline, view);
            // Either find an existing desc that exactly matches this node,
            // and drop the descs before it.
            updater.findNodeMatch(child, outerDeco, innerDeco, i) ||
            // Or try updating the next desc to reflect this node.
            updater.updateNextNode(child, outerDeco, innerDeco, view, i) ||
            // Or just add it as a new desc.
            updater.addNode(child, outerDeco, innerDeco, view, pos);
            pos += child.nodeSize;
          });
          // Drop all remaining descs after the current position.
          updater.syncToMarks(nothing, inline, view);
          if (this.node.isTextblock) {
            updater.addTextblockHacks();
          }
          updater.destroyRest();

          // Sync the DOM if anything changed
          if (updater.changed || this.dirty == CONTENT_DIRTY) {
            this.renderChildren();
          }
        };

        NodeViewDesc.prototype.renderChildren = function renderChildren() {
          renderDescs(this.contentDOM, this.children, NodeViewDesc.is);
          if (result.ios) {
            iosHacks(this.dom);
          }
        };

        // : (Node, [Decoration], DecorationSet, EditorView) → bool
        // If this desc be updated to match the given node decoration,
        // do so and return true.
        NodeViewDesc.prototype.update = function update(node, outerDeco, innerDeco, view) {
          if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) {
            return false;
          }
          this.updateInner(node, outerDeco, innerDeco, view);
          return true;
        };

        NodeViewDesc.prototype.updateInner = function updateInner(node, outerDeco, innerDeco, view) {
          this.updateOuterDeco(outerDeco);
          this.node = node;
          this.innerDeco = innerDeco;
          if (this.contentDOM) {
            this.updateChildren(view, this.posAtStart);
          }
          this.dirty = NOT_DIRTY;
        };

        NodeViewDesc.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
          if (sameOuterDeco(outerDeco, this.outerDeco)) {
            return;
          }
          var needsWrap = this.nodeDOM.nodeType != 1;
          var oldDOM = this.dom;
          this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
          if (this.dom != oldDOM) {
            oldDOM.pmViewDesc = null;
            this.dom.pmViewDesc = this;
          }
          this.outerDeco = outerDeco;
        };

        // Mark this node as being the selected node.
        NodeViewDesc.prototype.selectNode = function selectNode() {
          this.nodeDOM.classList.add("ProseMirror-selectednode");
          if (this.contentDOM || !this.node.type.spec.draggable) {
            this.dom.draggable = true;
          }
        };

        // Remove selected node marking from this node.
        NodeViewDesc.prototype.deselectNode = function deselectNode() {
          this.nodeDOM.classList.remove("ProseMirror-selectednode");
          if (this.contentDOM || !this.node.type.spec.draggable) {
            this.dom.draggable = false;
          }
        };

        Object.defineProperties(NodeViewDesc.prototype, prototypeAccessors$2);

        return NodeViewDesc;
      }(ViewDesc);

      // Create a view desc for the top-level document node, to be exported
      // and used by the view class.
      function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
        applyOuterDeco(dom, outerDeco, doc);
        return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);
      }

      var TextViewDesc = function (NodeViewDesc) {
        function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
          NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view);
        }

        if (NodeViewDesc) TextViewDesc.__proto__ = NodeViewDesc;
        TextViewDesc.prototype = Object.create(NodeViewDesc && NodeViewDesc.prototype);
        TextViewDesc.prototype.constructor = TextViewDesc;

        TextViewDesc.prototype.parseRule = function parseRule() {
          var parent = this.nodeDOM.parentNode;
          return parent ? { skip: parent } : { ignore: true };
        };

        TextViewDesc.prototype.update = function update(node, outerDeco) {
          if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) {
            return false;
          }
          this.updateOuterDeco(outerDeco);
          if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
            this.nodeDOM.nodeValue = node.text;
          }
          this.node = node;
          this.dirty = NOT_DIRTY;
          return true;
        };

        TextViewDesc.prototype.inParent = function inParent() {
          var parentDOM = this.parent.contentDOM;
          for (var n = this.nodeDOM; n; n = n.parentNode) {
            if (n == parentDOM) {
              return true;
            }
          }
          return false;
        };

        TextViewDesc.prototype.domFromPos = function domFromPos(pos) {
          return { node: this.nodeDOM, offset: pos };
        };

        TextViewDesc.prototype.localPosFromDOM = function localPosFromDOM(dom, offset, bias) {
          if (dom == this.nodeDOM) {
            return this.posAtStart + Math.min(offset, this.node.text.length);
          }
          return NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset, bias);
        };

        TextViewDesc.prototype.ignoreMutation = function ignoreMutation(mutation) {
          return mutation.type != "characterData";
        };

        return TextViewDesc;
      }(NodeViewDesc);

      // A dummy desc used to tag trailing BR or span nodes created to work
      // around contentEditable terribleness.
      var BRHackViewDesc = function (ViewDesc) {
        function BRHackViewDesc() {
          ViewDesc.apply(this, arguments);
        }

        if (ViewDesc) BRHackViewDesc.__proto__ = ViewDesc;
        BRHackViewDesc.prototype = Object.create(ViewDesc && ViewDesc.prototype);
        BRHackViewDesc.prototype.constructor = BRHackViewDesc;

        BRHackViewDesc.prototype.parseRule = function parseRule() {
          return { ignore: true };
        };
        BRHackViewDesc.prototype.matchesHack = function matchesHack() {
          return this.dirty == NOT_DIRTY;
        };

        return BRHackViewDesc;
      }(ViewDesc);

      // A separate subclass is used for customized node views, so that the
      // extra checks only have to be made for nodes that are actually
      // customized.
      var CustomNodeViewDesc = function (NodeViewDesc) {
        function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
          NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
          this.spec = spec;
        }

        if (NodeViewDesc) CustomNodeViewDesc.__proto__ = NodeViewDesc;
        CustomNodeViewDesc.prototype = Object.create(NodeViewDesc && NodeViewDesc.prototype);
        CustomNodeViewDesc.prototype.constructor = CustomNodeViewDesc;

        // A custom `update` method gets to decide whether the update goes
        // through. If it does, and there's a `contentDOM` node, our logic
        // updates the children.
        CustomNodeViewDesc.prototype.update = function update(node, outerDeco, innerDeco, view) {
          if (this.dirty == NODE_DIRTY) {
            return false;
          }
          if (this.spec.update) {
            var result$$1 = this.spec.update(node, outerDeco);
            if (result$$1) {
              this.updateInner(node, outerDeco, innerDeco, view);
            }
            return result$$1;
          } else if (!this.contentDOM && !node.isLeaf) {
            return false;
          } else {
            return NodeViewDesc.prototype.update.call(this, node, outerDeco, innerDeco, view);
          }
        };

        CustomNodeViewDesc.prototype.selectNode = function selectNode() {
          this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc.prototype.selectNode.call(this);
        };

        CustomNodeViewDesc.prototype.deselectNode = function deselectNode() {
          this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc.prototype.deselectNode.call(this);
        };

        CustomNodeViewDesc.prototype.setSelection = function setSelection(anchor, head, root, force) {
          this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : NodeViewDesc.prototype.setSelection.call(this, anchor, head, root, force);
        };

        CustomNodeViewDesc.prototype.destroy = function destroy() {
          if (this.spec.destroy) {
            this.spec.destroy();
          }
          NodeViewDesc.prototype.destroy.call(this);
        };

        CustomNodeViewDesc.prototype.stopEvent = function stopEvent(event) {
          return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
        };

        CustomNodeViewDesc.prototype.ignoreMutation = function ignoreMutation(mutation) {
          return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc.prototype.ignoreMutation.call(this, mutation);
        };

        return CustomNodeViewDesc;
      }(NodeViewDesc);

      // : (dom.Node, [ViewDesc])
      // Sync the content of the given DOM node with the nodes associated
      // with the given array of view descs, recursing into mark descs
      // because this should sync the subtree for a whole node at a time.
      function renderDescs(parentDOM, descs) {
        var dom = parentDOM.firstChild;
        for (var i = 0; i < descs.length; i++) {
          var desc = descs[i],
              childDOM = desc.dom;
          if (childDOM.parentNode == parentDOM) {
            while (childDOM != dom) {
              dom = rm(dom);
            }
            dom = dom.nextSibling;
          } else {
            parentDOM.insertBefore(childDOM, dom);
          }
          if (desc instanceof MarkViewDesc) {
            var pos = dom ? dom.previousSibling : parentDOM.lastChild;
            renderDescs(desc.contentDOM, desc.children);
            dom = pos ? pos.nextSibling : parentDOM.firstChild;
          }
        }
        while (dom) {
          dom = rm(dom);
        }
      }

      function OuterDecoLevel(nodeName) {
        if (nodeName) {
          this.nodeName = nodeName;
        }
      }
      OuterDecoLevel.prototype = Object.create(null);

      var noDeco = [new OuterDecoLevel()];

      function computeOuterDeco(outerDeco, node, needsWrap) {
        if (outerDeco.length == 0) {
          return noDeco;
        }

        var top = needsWrap ? noDeco[0] : new OuterDecoLevel(),
            result$$1 = [top];

        for (var i = 0; i < outerDeco.length; i++) {
          var attrs = outerDeco[i].type.attrs,
              cur = top;
          if (!attrs) {
            continue;
          }
          if (attrs.nodeName) {
            result$$1.push(cur = new OuterDecoLevel(attrs.nodeName));
          }

          for (var name in attrs) {
            var val = attrs[name];
            if (val == null) {
              continue;
            }
            if (needsWrap && result$$1.length == 1) {
              result$$1.push(cur = top = new OuterDecoLevel(node.isInline ? "span" : "div"));
            }
            if (name == "class") {
              cur.class = (cur.class ? cur.class + " " : "") + val;
            } else if (name == "style") {
              cur.style = (cur.style ? cur.style + ";" : "") + val;
            } else if (name != "nodeName") {
              cur[name] = val;
            }
          }
        }

        return result$$1;
      }

      function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
        // Shortcut for trivial case
        if (prevComputed == noDeco && curComputed == noDeco) {
          return nodeDOM;
        }

        var curDOM = nodeDOM;
        for (var i = 0; i < curComputed.length; i++) {
          var deco = curComputed[i],
              prev = prevComputed[i];
          if (i) {
            var parent = void 0;
            if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = nodeDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
              curDOM = parent;
            } else {
              parent = document.createElement(deco.nodeName);
              parent.appendChild(curDOM);
              curDOM = parent;
            }
          }
          patchAttributes(curDOM, prev || noDeco[0], deco);
        }
        return curDOM;
      }

      function patchAttributes(dom, prev, cur) {
        for (var name in prev) {
          if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
            dom.removeAttribute(name);
          }
        }
        for (var name$1 in cur) {
          if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1]) {
            dom.setAttribute(name$1, cur[name$1]);
          }
        }
        if (prev.class != cur.class) {
          var prevList = prev.class ? prev.class.split(" ") : nothing;
          var curList = cur.class ? cur.class.split(" ") : nothing;
          for (var i = 0; i < prevList.length; i++) {
            if (curList.indexOf(prevList[i]) == -1) {
              dom.classList.remove(prevList[i]);
            }
          }
          for (var i$1 = 0; i$1 < curList.length; i$1++) {
            if (prevList.indexOf(curList[i$1]) == -1) {
              dom.classList.add(curList[i$1]);
            }
          }
        }
        if (prev.style != cur.style) {
          if (prev.style) {
            var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
                m;
            while (m = prop.exec(prev.style)) {
              dom.style[m[1].toLowerCase()] = "";
            }
          }
          if (cur.style) {
            dom.style.cssText += cur.style;
          }
        }
      }

      function applyOuterDeco(dom, deco, node) {
        return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
      }

      // : ([Decoration], [Decoration]) → bool
      function sameOuterDeco(a, b) {
        if (a.length != b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (!a[i].type.eq(b[i].type)) {
            return false;
          }
        }
        return true;
      }

      // Remove a DOM node and return its next sibling.
      function rm(dom) {
        var next = dom.nextSibling;
        dom.parentNode.removeChild(dom);
        return next;
      }

      // Helper class for incrementally updating a tree of mark descs and
      // the widget and node descs inside of them.
      var ViewTreeUpdater = function ViewTreeUpdater(top) {
        this.top = top;
        // Index into `this.top`'s child array, represents the current
        // update position.
        this.index = 0;
        // When entering a mark, the current top and index are pushed
        // onto this.
        this.stack = [];
        // Tracks whether anything was changed
        this.changed = false;

        var pre = preMatch(top.node.content, top.children);
        this.preMatched = pre.nodes;
        this.preMatchOffset = pre.offset;
      };

      ViewTreeUpdater.prototype.getPreMatch = function getPreMatch(index) {
        return index >= this.preMatchOffset ? this.preMatched[index - this.preMatchOffset] : null;
      };

      // Destroy and remove the children between the given indices in
      // `this.top`.
      ViewTreeUpdater.prototype.destroyBetween = function destroyBetween(start, end) {
        var this$1 = this;

        if (start == end) {
          return;
        }
        for (var i = start; i < end; i++) {
          this$1.top.children[i].destroy();
        }
        this.top.children.splice(start, end - start);
        this.changed = true;
      };

      // Destroy all remaining children in `this.top`.
      ViewTreeUpdater.prototype.destroyRest = function destroyRest() {
        this.destroyBetween(this.index, this.top.children.length);
      };

      // : ([Mark], EditorView)
      // Sync the current stack of mark descs with the given array of
      // marks, reusing existing mark descs when possible.
      ViewTreeUpdater.prototype.syncToMarks = function syncToMarks(marks, inline, view) {
        var this$1 = this;

        var keep = 0,
            depth = this.stack.length >> 1;
        var maxKeep = Math.min(depth, marks.length);
        while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false) {
          keep++;
        }

        while (keep < depth) {
          this$1.destroyRest();
          this$1.top.dirty = NOT_DIRTY;
          this$1.index = this$1.stack.pop();
          this$1.top = this$1.stack.pop();
          depth--;
        }
        while (depth < marks.length) {
          this$1.stack.push(this$1.top, this$1.index + 1);
          var found = -1;
          for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
            if (this$1.top.children[i].matchesMark(marks[depth])) {
              found = i;break;
            }
          }
          if (found > -1) {
            if (found > this$1.index) {
              this$1.changed = true;
              this$1.top.children.splice(this$1.index, found - this$1.index);
            }
            this$1.top = this$1.top.children[this$1.index];
          } else {
            var markDesc = MarkViewDesc.create(this$1.top, marks[depth], inline, view);
            this$1.top.children.splice(this$1.index, 0, markDesc);
            this$1.top = markDesc;
            this$1.changed = true;
          }
          this$1.index = 0;
          depth++;
        }
      };

      // : (Node, [Decoration], DecorationSet) → bool
      // Try to find a node desc matching the given data. Skip over it and
      // return true when successful.
      ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch(node, outerDeco, innerDeco, index) {
        var this$1 = this;

        var found = -1,
            preMatch = index < 0 ? undefined : this.getPreMatch(index),
            children = this.top.children;
        if (preMatch && preMatch.matchesNode(node, outerDeco, innerDeco)) {
          found = children.indexOf(preMatch);
        } else {
          for (var i = this.index, e = Math.min(children.length, i + 5); i < e; i++) {
            var child = children[i];
            if (child.matchesNode(node, outerDeco, innerDeco) && this$1.preMatched.indexOf(child) < 0) {
              found = i;
              break;
            }
          }
        }
        if (found < 0) {
          return false;
        }
        this.destroyBetween(this.index, found);
        this.index++;
        return true;
      };

      // : (Node, [Decoration], DecorationSet, EditorView, Fragment, number) → bool
      // Try to update the next node, if any, to the given data. Checks
      // pre-matches to avoid overwriting nodes that could still be used.
      ViewTreeUpdater.prototype.updateNextNode = function updateNextNode(node, outerDeco, innerDeco, view, index) {
        if (this.index == this.top.children.length) {
          return false;
        }
        var next = this.top.children[this.index];
        if (next instanceof NodeViewDesc) {
          var preMatch = this.preMatched.indexOf(next);
          if (preMatch > -1 && preMatch + this.preMatchOffset != index) {
            return false;
          }
          var nextDOM = next.dom;
          if (next.update(node, outerDeco, innerDeco, view)) {
            if (next.dom != nextDOM) {
              this.changed = true;
            }
            this.index++;
            return true;
          }
        }
        return false;
      };

      // : (Node, [Decoration], DecorationSet, EditorView)
      // Insert the node as a newly created node desc.
      ViewTreeUpdater.prototype.addNode = function addNode(node, outerDeco, innerDeco, view, pos) {
        this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
        this.changed = true;
      };

      ViewTreeUpdater.prototype.placeWidget = function placeWidget(widget, view, pos) {
        if (this.index < this.top.children.length && this.top.children[this.index].matchesWidget(widget)) {
          this.index++;
        } else {
          var desc = new (widget.spec.isCursorWrapper ? CursorWrapperDesc : WidgetViewDesc)(this.top, widget, view, pos);
          this.top.children.splice(this.index++, 0, desc);
          this.changed = true;
        }
      };

      // Make sure a textblock looks and behaves correctly in
      // contentEditable.
      ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks() {
        var lastChild = this.top.children[this.index - 1];
        while (lastChild instanceof MarkViewDesc) {
          lastChild = lastChild.children[lastChild.children.length - 1];
        }

        if (!lastChild || // Empty textblock
        !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
          if (this.index < this.top.children.length && this.top.children[this.index].matchesHack()) {
            this.index++;
          } else {
            var dom = document.createElement("br");
            this.top.children.splice(this.index++, 0, new BRHackViewDesc(this.top, nothing, dom, null));
            this.changed = true;
          }
        }
      };

      // : (Fragment, [ViewDesc]) → [ViewDesc]
      // Iterate from the end of the fragment and array of descs to find
      // directly matching ones, in order to avoid overeagerly reusing
      // those for other nodes. Returns an array whose positions correspond
      // to node positions in the fragment, and whose elements are either
      // descs matched to the child at that index, or empty.
      function preMatch(frag, descs) {
        var result$$1 = [],
            end = frag.childCount;
        for (var i = descs.length - 1; end > 0 && i >= 0; i--) {
          var desc = descs[i],
              node = desc.node;
          if (!node) {
            continue;
          }
          if (node != frag.child(end - 1)) {
            break;
          }
          result$$1.push(desc);
          --end;
        }
        return { nodes: result$$1.reverse(), offset: end };
      }

      function compareSide(a, b) {
        return a.type.side - b.type.side;
      }

      // : (ViewDesc, DecorationSet, (Decoration), (Node, [Decoration], DecorationSet, number))
      // This function abstracts iterating over the nodes and decorations in
      // a fragment. Calls `onNode` for each node, with its local and child
      // decorations. Splits text nodes when there is a decoration starting
      // or ending inside of them. Calls `onWidget` for each widget.
      function iterDeco(parent, deco, onWidget, onNode) {
        var locals = deco.locals(parent),
            offset = 0;
        // Simple, cheap variant for when there are no local decorations
        if (locals.length == 0) {
          for (var i = 0; i < parent.childCount; i++) {
            var child = parent.child(i);
            onNode(child, locals, deco.forChild(offset, child), i);
            offset += child.nodeSize;
          }
          return;
        }

        var decoIndex = 0,
            active = [],
            restNode = null;
        for (var parentIndex = 0;;) {
          if (decoIndex < locals.length && locals[decoIndex].to == offset) {
            var widget = locals[decoIndex++],
                widgets = void 0;
            while (decoIndex < locals.length && locals[decoIndex].to == offset) {
              (widgets || (widgets = [widget])).push(locals[decoIndex++]);
            }
            if (widgets) {
              widgets.sort(compareSide);
              for (var i$1 = 0; i$1 < widgets.length; i$1++) {
                onWidget(widgets[i$1], parentIndex);
              }
            } else {
              onWidget(widget, parentIndex);
            }
          }

          var child$1 = void 0,
              index = void 0;
          if (restNode) {
            index = -1;
            child$1 = restNode;
            restNode = null;
          } else if (parentIndex < parent.childCount) {
            index = parentIndex;
            child$1 = parent.child(parentIndex++);
          } else {
            break;
          }

          for (var i$2 = 0; i$2 < active.length; i$2++) {
            if (active[i$2].to <= offset) {
              active.splice(i$2--, 1);
            }
          }
          while (decoIndex < locals.length && locals[decoIndex].from == offset) {
            active.push(locals[decoIndex++]);
          }

          var end = offset + child$1.nodeSize;
          if (child$1.isText) {
            var cutAt = end;
            if (decoIndex < locals.length && locals[decoIndex].from < cutAt) {
              cutAt = locals[decoIndex].from;
            }
            for (var i$3 = 0; i$3 < active.length; i$3++) {
              if (active[i$3].to < cutAt) {
                cutAt = active[i$3].to;
              }
            }
            if (cutAt < end) {
              restNode = child$1.cut(cutAt - offset);
              child$1 = child$1.cut(0, cutAt - offset);
              end = cutAt;
              index = -1;
            }
          }

          onNode(child$1, active.length ? active.slice() : nothing, deco.forChild(offset, child$1), index);
          offset = end;
        }
      }

      // List markers in Mobile Safari will mysteriously disappear
      // sometimes. This works around that.
      function iosHacks(dom) {
        if (dom.nodeName == "UL" || dom.nodeName == "OL") {
          var oldCSS = dom.style.cssText;
          dom.style.cssText = oldCSS + "; list-style: square !important";
          window.getComputedStyle(dom).listStyle;
          dom.style.cssText = oldCSS;
        }
      }

      function moveSelectionBlock(state, dir) {
        var ref = state.selection;
        var $anchor = ref.$anchor;
        var $head = ref.$head;
        var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
        var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
        return $start && dist$2.Selection.findFrom($start, dir);
      }

      function apply(view, sel) {
        view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
        return true;
      }

      function selectHorizontally(view, dir, mods) {
        var sel = view.state.selection;
        if (sel instanceof dist$2.TextSelection) {
          if (!sel.empty || mods.indexOf("s") > -1) {
            return false;
          } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
            var next = moveSelectionBlock(view.state, dir);
            if (next && next instanceof dist$2.NodeSelection) {
              return apply(view, next);
            }
            return false;
          } else {
            var $head = sel.$head,
                node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter,
                desc;
            if (node && dist$2.NodeSelection.isSelectable(node)) {
              var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
              if (node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM) {
                return apply(view, new dist$2.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
              }
            }
            return false;
          }
        } else if (sel instanceof dist$2.NodeSelection && sel.node.isInline) {
          return apply(view, new dist$2.TextSelection(dir > 0 ? sel.$to : sel.$from));
        } else {
          var next$1 = moveSelectionBlock(view.state, dir);
          if (next$1) {
            return apply(view, next$1);
          }
          return false;
        }
      }

      function nodeLen(node) {
        return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
      }

      function isIgnorable(dom) {
        var desc = dom.pmViewDesc;
        return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
      }

      // Make sure the cursor isn't directly after one or more ignored
      // nodes, which will confuse the browser's cursor motion logic.
      function skipIgnoredNodesLeft(view) {
        var sel = view.root.getSelection();
        var node = sel.focusNode,
            offset = sel.focusOffset;
        if (!node) {
          return;
        }
        var moveNode,
            moveOffset,
            force = false;
        // Gecko will do odd things when the selection is directly in front
        // of a non-editable node, so in that case, move it into the next
        // node if possible. Issue prosemirror/prosemirror#832.
        if (result.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) {
          force = true;
        }
        for (;;) {
          if (offset > 0) {
            if (node.nodeType != 1) {
              if (node.nodeType == 3 && node.nodeValue.charAt(offset - 1) == "\ufeff") {
                // IE11's cursor will still be stuck when placed at the
                // beginning of the cursor wrapper text node (#807)
                if (result.ie && result.ie_version <= 11) {
                  force = true;
                }
                moveNode = node;
                moveOffset = --offset;
              } else {
                break;
              }
            } else {
              var before = node.childNodes[offset - 1];
              if (isIgnorable(before)) {
                moveNode = node;
                moveOffset = --offset;
              } else if (before.nodeType == 3) {
                node = before;
                offset = node.nodeValue.length;
              } else {
                break;
              }
            }
          } else if (isBlockNode(node)) {
            break;
          } else {
            var prev = node.previousSibling;
            while (prev && isIgnorable(prev)) {
              moveNode = node.parentNode;
              moveOffset = domIndex(prev);
              prev = prev.previousSibling;
            }
            if (!prev) {
              node = node.parentNode;
              if (node == view.dom) {
                break;
              }
              offset = 0;
            } else {
              node = prev;
              offset = nodeLen(node);
            }
          }
        }
        if (force) {
          setSelFocus(view, sel, node, offset);
        } else if (moveNode) {
          setSelFocus(view, sel, moveNode, moveOffset);
        }
      }

      // Make sure the cursor isn't directly before one or more ignored
      // nodes.
      function skipIgnoredNodesRight(view) {
        var sel = view.root.getSelection();
        var node = sel.focusNode,
            offset = sel.focusOffset;
        if (!node) {
          return;
        }
        var len = nodeLen(node);
        var moveNode, moveOffset;
        for (;;) {
          if (offset < len) {
            if (node.nodeType != 1) {
              break;
            }
            var after = node.childNodes[offset];
            if (isIgnorable(after)) {
              moveNode = node;
              moveOffset = ++offset;
            } else {
              break;
            }
          } else if (isBlockNode(node)) {
            break;
          } else {
            var next = node.nextSibling;
            while (next && isIgnorable(next)) {
              moveNode = next.parentNode;
              moveOffset = domIndex(next) + 1;
              next = next.nextSibling;
            }
            if (!next) {
              node = node.parentNode;
              if (node == view.dom) {
                break;
              }
              offset = len = 0;
            } else {
              node = next;
              offset = 0;
              len = nodeLen(node);
            }
          }
        }
        if (moveNode) {
          setSelFocus(view, sel, moveNode, moveOffset);
        }
      }

      function isBlockNode(dom) {
        var desc = dom.pmViewDesc;
        return desc && desc.node && desc.node.isBlock;
      }

      function setSelFocus(view, sel, node, offset) {
        if (selectionCollapsed(sel)) {
          var range = document.createRange();
          range.setEnd(node, offset);
          range.setStart(node, offset);
          sel.removeAllRanges();
          sel.addRange(range);
        } else if (sel.extend) {
          sel.extend(node, offset);
        }
        view.selectionReader.storeDOMState(view.selection);
      }

      // : (EditorState, number)
      // Check whether vertical selection motion would involve node
      // selections. If so, apply it (if not, the result is left to the
      // browser)
      function selectVertically(view, dir, mods) {
        var sel = view.state.selection;
        if (sel instanceof dist$2.TextSelection && !sel.empty || mods.indexOf("s") > -1) {
          return false;
        }
        var $from = sel.$from;
        var $to = sel.$to;

        if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
          var next = moveSelectionBlock(view.state, dir);
          if (next && next instanceof dist$2.NodeSelection) {
            return apply(view, next);
          }
        }
        if (!$from.parent.inlineContent) {
          var beyond = dist$2.Selection.findFrom(dir < 0 ? $from : $to, dir);
          return beyond ? apply(view, beyond) : true;
        }
        return false;
      }

      function stopNativeHorizontalDelete(view, dir) {
        if (!(view.state.selection instanceof dist$2.TextSelection)) {
          return true;
        }
        var ref = view.state.selection;
        var $head = ref.$head;
        var $anchor = ref.$anchor;
        var empty = ref.empty;
        if (!$head.sameParent($anchor)) {
          return true;
        }
        if (!empty) {
          return false;
        }
        if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
          return true;
        }
        var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
        if (nextNode && !nextNode.isText) {
          var tr = view.state.tr;
          if (dir < 0) {
            tr.delete($head.pos - nextNode.nodeSize, $head.pos);
          } else {
            tr.delete($head.pos, $head.pos + nextNode.nodeSize);
          }
          view.dispatch(tr);
          return true;
        }
        return false;
      }

      function switchEditable(view, node, state) {
        view.domObserver.stop();
        node.contentEditable = state;
        view.domObserver.start();
      }

      // Issue #867 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
      // In which Chrome does really wrong things when the down arrow is
      // pressed when the cursor is directly at the start of a textblock and
      // has an uneditable node after it
      function chromeDownArrowBug(view) {
        if (!result.chrome || view.state.selection.$head.parentOffset > 0) {
          return;
        }
        var ref = view.root.getSelection();
        var focusNode = ref.focusNode;
        var focusOffset = ref.focusOffset;
        if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
          var child = focusNode.firstChild;
          switchEditable(view, child, true);
          setTimeout(function () {
            return switchEditable(view, child, false);
          }, 20);
        }
      }

      // A backdrop key mapping used to make sure we always suppress keys
      // that have a dangerous default effect, even if the commands they are
      // bound to return false, and to make sure that cursor-motion keys
      // find a cursor (as opposed to a node selection) when pressed. For
      // cursor-motion keys, the code in the handlers also takes care of
      // block selections.

      function getMods(event) {
        var result$$1 = "";
        if (event.ctrlKey) {
          result$$1 += "c";
        }
        if (event.metaKey) {
          result$$1 += "m";
        }
        if (event.altKey) {
          result$$1 += "a";
        }
        if (event.shiftKey) {
          result$$1 += "s";
        }
        return result$$1;
      }

      function captureKeyDown(view, event) {
        var code = event.keyCode,
            mods = getMods(event);
        if (code == 8 || result.mac && code == 72 && mods == "c") {
          // Backspace, Ctrl-h on Mac
          return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
        } else if (code == 46 || result.mac && code == 68 && mods == "c") {
          // Delete, Ctrl-d on Mac
          return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
        } else if (code == 13 || code == 27) {
          // Enter, Esc
          return true;
        } else if (code == 37) {
          // Left arrow
          return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
        } else if (code == 39) {
          // Right arrow
          return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
        } else if (code == 38) {
          // Up arrow
          return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
        } else if (code == 40) {
          // Down arrow
          return chromeDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
        } else if (mods == (result.mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
          // Mod-[biyz]
          return true;
        }
        return false;
      }

      var TrackedRecord = function TrackedRecord(prev, mapping, state) {
        this.prev = prev;
        this.mapping = mapping;
        this.state = state;
      };

      var TrackMappings = function TrackMappings(state) {
        this.seen = [new TrackedRecord(null, null, state)];
        // Kludge to listen to state changes globally in order to be able
        // to find mappings from a given state to another.
        dist$2.EditorState.addApplyListener(this.track = this.track.bind(this));
      };

      TrackMappings.prototype.destroy = function destroy() {
        dist$2.EditorState.removeApplyListener(this.track);
      };

      TrackMappings.prototype.find = function find(state) {
        var this$1 = this;

        for (var i = this.seen.length - 1; i >= 0; i--) {
          var record = this$1.seen[i];
          if (record.state == state) {
            return record;
          }
        }
      };

      TrackMappings.prototype.track = function track(old, tr, state) {
        var found = this.seen.length < 200 ? this.find(old) : null;
        if (found) {
          this.seen.push(new TrackedRecord(found, tr.docChanged ? tr.mapping : null, state));
        }
      };

      TrackMappings.prototype.getMapping = function getMapping(state, appendTo) {
        var found = this.find(state);
        if (!found) {
          return null;
        }
        var mappings = [];
        for (var rec = found; rec; rec = rec.prev) {
          if (rec.mapping) {
            mappings.push(rec.mapping);
          }
        }
        var result = appendTo || new dist$1.Mapping();
        for (var i = mappings.length - 1; i >= 0; i--) {
          result.appendMapping(mappings[i]);
        }
        return result;
      };

      // Track the state of the DOM selection, creating transactions to
      // update the selection state when necessary.
      var SelectionReader = function SelectionReader(view) {
        var this$1 = this;

        this.view = view;

        // Track the state of the DOM selection.
        this.lastAnchorNode = this.lastHeadNode = this.lastAnchorOffset = this.lastHeadOffset = null;
        this.lastSelection = view.state.selection;
        this.ignoreUpdates = false;
        this.suppressUpdates = false;
        this.poller = poller(this);

        this.focusFunc = function () {
          return this$1.poller.start(hasFocusAndSelection(this$1.view));
        }.bind(this);
        this.blurFunc = this.poller.stop;

        view.dom.addEventListener("focus", this.focusFunc);
        view.dom.addEventListener("blur", this.blurFunc);

        if (!view.editable) {
          this.poller.start(false);
        }
      };

      SelectionReader.prototype.destroy = function destroy() {
        this.view.dom.removeEventListener("focus", this.focusFunc);
        this.view.dom.removeEventListener("blur", this.blurFunc);
        this.poller.stop();
      };

      SelectionReader.prototype.poll = function poll(origin) {
        this.poller.poll(origin);
      };

      SelectionReader.prototype.editableChanged = function editableChanged() {
        if (!this.view.editable) {
          this.poller.start();
        } else if (!hasFocusAndSelection(this.view)) {
          this.poller.stop();
        }
      };

      // : () → bool
      // Whether the DOM selection has changed from the last known state.
      SelectionReader.prototype.domChanged = function domChanged() {
        var sel = this.view.root.getSelection();
        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastHeadNode || sel.focusOffset != this.lastHeadOffset;
      };

      // Store the current state of the DOM selection.
      SelectionReader.prototype.storeDOMState = function storeDOMState(selection) {
        var sel = this.view.root.getSelection();
        this.lastAnchorNode = sel.anchorNode;this.lastAnchorOffset = sel.anchorOffset;
        this.lastHeadNode = sel.focusNode;this.lastHeadOffset = sel.focusOffset;
        this.lastSelection = selection;
      };

      SelectionReader.prototype.clearDOMState = function clearDOMState() {
        this.lastAnchorNode = this.lastSelection = null;
      };

      // : (?string)
      // When the DOM selection changes in a notable manner, modify the
      // current selection state to match.
      SelectionReader.prototype.readFromDOM = function readFromDOM(origin) {
        if (this.ignoreUpdates || !this.domChanged() || !hasFocusAndSelection(this.view)) {
          return;
        }
        if (this.suppressUpdates) {
          return selectionToDOM(this.view);
        }
        if (!this.view.inDOMChange) {
          this.view.domObserver.flush();
        }
        if (this.view.inDOMChange) {
          return;
        }

        var domSel = this.view.root.getSelection(),
            doc = this.view.state.doc;
        var nearestDesc = this.view.docView.nearestDesc(domSel.focusNode),
            inWidget = nearestDesc && nearestDesc.size == 0;
        var head = this.view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
        var $head = doc.resolve(head),
            $anchor,
            selection;
        if (selectionCollapsed(domSel)) {
          $anchor = $head;
          while (nearestDesc && !nearestDesc.node) {
            nearestDesc = nearestDesc.parent;
          }
          if (nearestDesc && nearestDesc.node.isAtom && dist$2.NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent) {
            var pos = nearestDesc.posBefore;
            selection = new dist$2.NodeSelection(head == pos ? $head : doc.resolve(pos));
          }
        } else {
          $anchor = doc.resolve(this.view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset));
        }

        if (!selection) {
          var bias = origin == "pointer" || this.view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
          selection = selectionBetween(this.view, $anchor, $head, bias);
        }
        if (!this.view.state.selection.eq(selection)) {
          var tr = this.view.state.tr.setSelection(selection);
          if (origin == "pointer") {
            tr.setMeta("pointer", true);
          } else if (origin == "key") {
            tr.scrollIntoView();
          }
          this.view.dispatch(tr);
        } else {
          selectionToDOM(this.view);
        }
      };

      // There's two polling models. On browsers that support the
      // selectionchange event (everything except Firefox < 52, basically), we
      // register a listener for that whenever the editor is focused.
      var SelectionChangePoller = function SelectionChangePoller(reader) {
        var this$1 = this;

        this.listening = false;
        this.curOrigin = null;
        this.originTime = 0;
        this.reader = reader;

        this.readFunc = function () {
          return reader.readFromDOM(this$1.originTime > Date.now() - 50 ? this$1.curOrigin : null);
        };
      };

      SelectionChangePoller.prototype.poll = function poll(origin) {
        this.curOrigin = origin;
        this.originTime = Date.now();
      };

      SelectionChangePoller.prototype.start = function start(andRead) {
        if (!this.listening) {
          var doc = this.reader.view.dom.ownerDocument;
          doc.addEventListener("selectionchange", this.readFunc);
          this.listening = true;
          if (andRead) {
            this.readFunc();
          }
        }
      };

      SelectionChangePoller.prototype.stop = function stop() {
        if (this.listening) {
          var doc = this.reader.view.dom.ownerDocument;
          doc.removeEventListener("selectionchange", this.readFunc);
          this.listening = false;
        }
      };

      // On Browsers that don't support the selectionchange event,
      // we use timeout-based polling.
      var TimeoutPoller = function TimeoutPoller(reader) {
        // The timeout ID for the poller when active.
        this.polling = null;
        this.reader = reader;
        this.pollFunc = this.doPoll.bind(this, null);
      };

      TimeoutPoller.prototype.doPoll = function doPoll(origin) {
        var view = this.reader.view;
        if (view.focused || !view.editable) {
          this.reader.readFromDOM(origin);
          this.polling = setTimeout(this.pollFunc, 100);
        } else {
          this.polling = null;
        }
      };

      TimeoutPoller.prototype.poll = function poll(origin) {
        clearTimeout(this.polling);
        this.polling = setTimeout(origin ? this.doPoll.bind(this, origin) : this.pollFunc, 0);
      };

      TimeoutPoller.prototype.start = function start() {
        if (this.polling == null) {
          this.poll();
        }
      };

      TimeoutPoller.prototype.stop = function stop() {
        clearTimeout(this.polling);
        this.polling = null;
      };

      function poller(reader) {
        return new ("onselectionchange" in document ? SelectionChangePoller : TimeoutPoller)(reader);
      }

      function selectionToDOM(view, takeFocus, force) {
        var sel = view.state.selection;
        syncNodeSelection(view, sel);

        if (view.editable && !view.hasFocus()) {
          if (!takeFocus) {
            return;
          }
          // See https://bugzilla.mozilla.org/show_bug.cgi?id=921444
          if (result.gecko && result.gecko_version <= 55) {
            view.selectionReader.ignoreUpdates = true;
            view.dom.focus();
            view.selectionReader.ignoreUpdates = false;
          }
        } else if (!view.editable && !hasSelection(view) && !takeFocus) {
          return;
        }

        var reader = view.selectionReader;
        if (reader.lastSelection && reader.lastSelection.eq(sel) && !reader.domChanged()) {
          return;
        }

        reader.ignoreUpdates = true;

        if (view.cursorWrapper) {
          selectCursorWrapper(view);
        } else {
          var anchor = sel.anchor;
          var head = sel.head;
          var resetEditableFrom, resetEditableTo;
          if (brokenSelectBetweenUneditable && !(sel instanceof dist$2.TextSelection)) {
            if (!sel.$from.parent.inlineContent) {
              resetEditableFrom = temporarilyEditableNear(view, sel.from);
            }
            if (!sel.empty && !sel.$from.parent.inlineContent) {
              resetEditableTo = temporarilyEditableNear(view, sel.to);
            }
          }
          view.docView.setSelection(anchor, head, view.root, force);
          if (brokenSelectBetweenUneditable) {
            if (resetEditableFrom) {
              resetEditableFrom.contentEditable = "false";
            }
            if (resetEditableTo) {
              resetEditableTo.contentEditable = "false";
            }
          }
          if (sel.visible) {
            view.dom.classList.remove("ProseMirror-hideselection");
          } else if (anchor != head) {
            view.dom.classList.add("ProseMirror-hideselection");
            if ("onselectionchange" in document) {
              removeClassOnSelectionChange(view);
            }
          }
        }

        reader.storeDOMState(sel);
        reader.ignoreUpdates = false;
      }

      // Kludge to work around Webkit not allowing a selection to start/end
      // between non-editable block nodes. We briefly make something
      // editable, set the selection, then set it uneditable again.

      var brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;

      function temporarilyEditableNear(view, pos) {
        var ref = view.docView.domFromPos(pos);
        var node = ref.node;
        var offset = ref.offset;
        var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
        var before = offset ? node.childNodes[offset - 1] : null;
        if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
          if (after) {
            after.contentEditable = "true";
            return after;
          } else if (before) {
            before.contentEditable = "true";
            return before;
          }
        }
      }

      function removeClassOnSelectionChange(view) {
        var doc = view.dom.ownerDocument;
        doc.removeEventListener("selectionchange", view.hideSelectionGuard);
        var domSel = view.root.getSelection();
        var node = domSel.anchorNode,
            offset = domSel.anchorOffset;
        doc.addEventListener("selectionchange", view.hideSelectionGuard = function () {
          if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
            doc.removeEventListener("selectionchange", view.hideSelectionGuard);
            view.dom.classList.remove("ProseMirror-hideselection");
          }
        });
      }

      function selectCursorWrapper(view) {
        var domSel = view.root.getSelection(),
            range = document.createRange();
        var node = view.cursorWrapper.dom;
        range.setEnd(node, node.childNodes.length);
        range.collapse(false);
        domSel.removeAllRanges();
        domSel.addRange(range);
        // Kludge to kill 'control selection' in IE11 when selecting an
        // invisible cursor wrapper, since that would result in those weird
        // resize handles and a selection that considers the absolutely
        // positioned wrapper, rather than the root editable node, the
        // focused element.
        if (!view.state.selection.visible && result.ie && result.ie_version <= 11) {
          node.disabled = true;
          node.disabled = false;
        }
      }

      function syncNodeSelection(view, sel) {
        if (sel instanceof dist$2.NodeSelection) {
          var desc = view.docView.descAt(sel.from);
          if (desc != view.lastSelectedViewDesc) {
            clearNodeSelection(view);
            if (desc) {
              desc.selectNode();
            }
            view.lastSelectedViewDesc = desc;
          }
        } else {
          clearNodeSelection(view);
        }
      }

      // Clear all DOM statefulness of the last node selection.
      function clearNodeSelection(view) {
        if (view.lastSelectedViewDesc) {
          if (view.lastSelectedViewDesc.parent) {
            view.lastSelectedViewDesc.deselectNode();
          }
          view.lastSelectedViewDesc = null;
        }
      }

      function selectionBetween(view, $anchor, $head, bias) {
        return view.someProp("createSelectionBetween", function (f) {
          return f(view, $anchor, $head);
        }) || dist$2.TextSelection.between($anchor, $head, bias);
      }

      function hasFocusAndSelection(view) {
        if (view.editable && view.root.activeElement != view.dom) {
          return false;
        }
        return hasSelection(view);
      }

      function hasSelection(view) {
        var sel = view.root.getSelection();
        if (!sel.anchorNode) {
          return false;
        }
        try {
          // Firefox will raise 'permission denied' errors when accessing
          // properties of `sel.anchorNode` when it's in a generated CSS
          // element.
          return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
        } catch (_) {
          return false;
        }
      }

      function nonInclusiveMark(mark) {
        return mark.type.spec.inclusive === false;
      }

      function needsCursorWrapper(state) {
        var ref = state.selection;
        var $head = ref.$head;
        var $anchor = ref.$anchor;
        var visible = ref.visible;
        var $pos = $head.pos == $anchor.pos && (!visible || $head.parent.inlineContent) ? $head : null;
        if ($pos && (!visible || state.storedMarks || $pos.parent.content.length == 0 || $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.some(nonInclusiveMark))) {
          return $pos;
        } else {
          return null;
        }
      }

      function anchorInRightPlace(view) {
        var anchorDOM = view.docView.domFromPos(view.state.selection.anchor);
        var domSel = view.root.getSelection();
        return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
      }

      var DOMChange = function DOMChange(view, composing) {
        var this$1 = this;

        this.view = view;
        this.state = view.state;
        this.composing = composing;
        this.compositionEndedAt = null;
        this.from = this.to = null;
        this.typeOver = false;
        this.timeout = composing ? null : setTimeout(function () {
          return this$1.finish();
        }, DOMChange.commitTimeout);
        this.trackMappings = new TrackMappings(view.state);

        // If there have been changes since this DOM update started, we must
        // map our start and end positions, as well as the new selection
        // positions, through them. This tracks that mapping.
        this.mapping = new dist$1.Mapping();
        this.mappingTo = view.state;
      };

      DOMChange.prototype.addRange = function addRange(from, to) {
        if (this.from == null) {
          this.from = from;
          this.to = to;
        } else {
          this.from = Math.min(from, this.from);
          this.to = Math.max(to, this.to);
        }
      };

      DOMChange.prototype.changedRange = function changedRange() {
        if (this.from == null) {
          return rangeAroundSelection(this.state.selection);
        }
        var $from = this.state.doc.resolve(Math.min(this.from, this.state.selection.from)),
            $to = this.state.doc.resolve(this.to);
        var shared = $from.sharedDepth(this.to);
        return { from: $from.before(shared + 1), to: $to.after(shared + 1) };
      };

      DOMChange.prototype.markDirty = function markDirty(range) {
        if (this.from == null) {
          this.view.docView.markDirty((range = range || this.changedRange()).from, range.to);
        } else {
          this.view.docView.markDirty(this.from, this.to);
        }
      };

      DOMChange.prototype.stateUpdated = function stateUpdated(state) {
        if (this.trackMappings.getMapping(state, this.mapping)) {
          this.trackMappings.destroy();
          this.trackMappings = new TrackMappings(state);
          this.mappingTo = state;
          return true;
        } else {
          this.markDirty();
          this.destroy();
          return false;
        }
      };

      DOMChange.prototype.finish = function finish(force) {
        clearTimeout(this.timeout);
        if (this.composing && !force) {
          return;
        }
        this.view.domObserver.flush();
        var range = this.changedRange();
        this.markDirty(range);

        this.destroy();
        var sel = this.state.selection,
            allowTypeOver = this.typeOver && sel instanceof dist$2.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor);
        readDOMChange(this.view, this.mapping, this.state, range, allowTypeOver);

        // If the reading didn't result in a view update, force one by
        // resetting the view to its current state.
        if (this.view.docView.dirty) {
          this.view.updateState(this.view.state);
        }
      };

      DOMChange.prototype.destroy = function destroy() {
        clearTimeout(this.timeout);
        this.trackMappings.destroy();
        this.view.inDOMChange = null;
      };

      DOMChange.prototype.compositionEnd = function compositionEnd(event) {
        var this$1 = this;

        if (this.composing) {
          this.composing = false;
          if (event) {
            this.compositionEndedAt = event.timeStamp;
          }
          this.timeout = setTimeout(function () {
            return this$1.finish();
          }, 50);
        }
      };

      DOMChange.prototype.ignoreKeyDownOnCompositionEnd = function ignoreKeyDownOnCompositionEnd(event) {
        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
        // On Japanese input method editors (IMEs), the Enter key is used to confirm character
        // selection. On Safari, when Enter is pressed, compositionend and keydown events are
        // emitted. The keydown event triggers newline insertion, which we don't want.
        // This method returns true if the keydown event should be ignored.
        // We only ignore it once, as pressing Enter a second time *should* insert a newline.
        // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
        // This guards against the case where compositionend is triggered without the keyboard
        // (e.g. character confirmation may be done with the mouse), and keydown is triggered
        // afterwards- we wouldn't want to ignore the keydown event in this case.
        if (result.safari && this.compositionEndedAt !== null && Math.abs(event.timeStamp - this.compositionEndedAt) < 500) {
          this.compositionEndedAt = null;
          return true;
        }
        return false;
      };

      DOMChange.start = function start(view, composing) {
        if (view.inDOMChange) {
          if (composing) {
            clearTimeout(view.inDOMChange.timeout);
            view.inDOMChange.composing = true;
            view.inDOMChange.compositionEndedAt = null;
          }
        } else {
          view.inDOMChange = new DOMChange(view, composing);
        }
        return view.inDOMChange;
      };
      DOMChange.commitTimeout = 20;

      // Note that all referencing and parsing is done with the
      // start-of-operation selection and document, since that's the one
      // that the DOM represents. If any changes came in in the meantime,
      // the modification is mapped over those before it is applied, in
      // readDOMChange.

      function parseBetween(view, oldState, range) {
        var ref = view.docView.parseRange(range.from, range.to);
        var parent = ref.node;
        var fromOffset = ref.fromOffset;
        var toOffset = ref.toOffset;
        var from = ref.from;
        var to = ref.to;

        var domSel = view.root.getSelection(),
            find = null,
            anchor = domSel.anchorNode;
        if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
          find = [{ node: anchor, offset: domSel.anchorOffset }];
          if (!selectionCollapsed(domSel)) {
            find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
          }
        }
        // Work around issue in Chrome where backspacing sometimes replaces
        // the deleted content with a random BR node (issues #799, #831)
        if (result.chrome && view.lastKeyCode === 8) {
          for (var off = toOffset; off > fromOffset; off--) {
            var node = parent.childNodes[off - 1],
                desc = node.pmViewDesc;
            if (node.nodeType == "BR" && !desc) {
              toOffset = off;break;
            }
            if (!desc || desc.size) {
              break;
            }
          }
        }
        var startDoc = oldState.doc;
        var parser = view.someProp("domParser") || dist.DOMParser.fromSchema(view.state.schema);
        var $from = startDoc.resolve(from);
        var sel = null,
            doc = parser.parse(parent, {
          topNode: $from.parent,
          topMatch: $from.parent.contentMatchAt($from.index()),
          topOpen: true,
          from: fromOffset,
          to: toOffset,
          preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
          editableContent: true,
          findPositions: find,
          ruleFromNode: ruleFromNode(parser, $from),
          context: $from
        });
        if (find && find[0].pos != null) {
          var anchor$1 = find[0].pos,
              head = find[1] && find[1].pos;
          if (head == null) {
            head = anchor$1;
          }
          sel = { anchor: anchor$1 + from, head: head + from };
        }
        return { doc: doc, sel: sel, from: from, to: to };
      }

      function ruleFromNode(parser, context) {
        return function (dom) {
          var desc = dom.pmViewDesc;
          if (desc) {
            return desc.parseRule();
          } else if (dom.nodeName == "BR" && dom.parentNode) {
            // Safari replaces the list item or table cell with a BR
            // directly in the list node (?!) if you delete the last
            // character in a list item or table cell (#708, #862)
            if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
              return parser.matchTag(document.createElement("li"), context);
            } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
              return { ignore: true };
            }
          }
        };
      }

      function isAtEnd($pos, depth) {
        for (var i = depth || 0; i < $pos.depth; i++) {
          if ($pos.index(i) + 1 < $pos.node(i).childCount) {
            return false;
          }
        }
        return $pos.parentOffset == $pos.parent.content.size;
      }
      function isAtStart($pos, depth) {
        for (var i = depth || 0; i < $pos.depth; i++) {
          if ($pos.index(0) > 0) {
            return false;
          }
        }
        return $pos.parentOffset == 0;
      }

      function rangeAroundSelection(selection) {
        // Intentionally uses $head/$anchor because those will correspond to the DOM selection
        var $from = selection.$anchor.min(selection.$head),
            $to = selection.$anchor.max(selection.$head);

        if ($from.sameParent($to) && $from.parent.inlineContent && $from.parentOffset && $to.parentOffset < $to.parent.content.size) {
          var startOff = Math.max(0, $from.parentOffset);
          var size = $from.parent.content.size;
          var endOff = Math.min(size, $to.parentOffset);

          if (startOff > 0) {
            startOff = $from.parent.childBefore(startOff).offset;
          }
          if (endOff < size) {
            var after = $from.parent.childAfter(endOff);
            endOff = after.offset + after.node.nodeSize;
          }
          var nodeStart = $from.start();
          return { from: nodeStart + startOff, to: nodeStart + endOff };
        } else {
          for (var depth = 0;; depth++) {
            var fromStart = isAtStart($from, depth + 1),
                toEnd = isAtEnd($to, depth + 1);
            if (fromStart || toEnd || $from.index(depth) != $to.index(depth) || $to.node(depth).isTextblock) {
              var from = $from.before(depth + 1),
                  to = $to.after(depth + 1);
              if (fromStart && $from.index(depth) > 0) {
                from -= $from.node(depth).child($from.index(depth) - 1).nodeSize;
              }
              if (toEnd && $to.index(depth) + 1 < $to.node(depth).childCount) {
                to += $to.node(depth).child($to.index(depth) + 1).nodeSize;
              }
              return { from: from, to: to };
            }
          }
        }
      }

      function readDOMChange(view, mapping, oldState, range, allowTypeOver) {
        var parse = parseBetween(view, oldState, range);

        var doc = oldState.doc,
            compare = doc.slice(parse.from, parse.to);
        var preferredPos, preferredSide;
        // Prefer anchoring to end when Backspace is pressed
        if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
          preferredPos = oldState.selection.to;
          preferredSide = "end";
        } else {
          preferredPos = oldState.selection.from;
          preferredSide = "start";
        }
        view.lastKeyCode = null;

        var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
        if (!change) {
          if (allowTypeOver) {
            var state = view.state,
                sel = state.selection;
            view.dispatch(state.tr.replaceSelectionWith(state.schema.text(state.doc.textBetween(sel.from, sel.to)), true).scrollIntoView());
          } else if (parse.sel) {
            var sel$1 = resolveSelection(view, view.state.doc, mapping, parse.sel);
            if (sel$1 && !sel$1.eq(view.state.selection)) {
              view.dispatch(view.state.tr.setSelection(sel$1));
            }
          }
          return;
        }
        view.domChangeCount++;
        // Handle the case where overwriting a selection by typing matches
        // the start or end of the selected content, creating a change
        // that's smaller than what was actually overwritten.
        if (oldState.selection.from < oldState.selection.to && change.start == change.endB && oldState.selection instanceof dist$2.TextSelection) {
          if (change.start > oldState.selection.from && change.start <= oldState.selection.from + 2) {
            change.start = oldState.selection.from;
          } else if (change.endA < oldState.selection.to && change.endA >= oldState.selection.to - 2) {
            change.endB += oldState.selection.to - change.endA;
            change.endA = oldState.selection.to;
          }
        }

        var $from = parse.doc.resolveNoCache(change.start - parse.from);
        var $to = parse.doc.resolveNoCache(change.endB - parse.from);
        var nextSel;
        // If this looks like the effect of pressing Enter, just dispatch an
        // Enter key instead.
        if (!$from.sameParent($to) && $from.pos < parse.doc.content.size && (nextSel = dist$2.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos && view.someProp("handleKeyDown", function (f) {
          return f(view, keyEvent(13, "Enter"));
        })) {
          return;
        }
        // Same for backspace
        if (oldState.selection.anchor > change.start && looksLikeJoin(doc, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function (f) {
          return f(view, keyEvent(8, "Backspace"));
        })) {
          if (result.android && result.chrome) {
            // #820
            view.selectionReader.suppressUpdates = true;
            setTimeout(function () {
              return view.selectionReader.suppressUpdates = false;
            }, 50);
          }
          return;
        }

        var from = mapping.map(change.start),
            to = Math.max(from, mapping.map(change.endA, -1));

        var tr, storedMarks, markChange, $from1;
        if ($from.sameParent($to) && $from.parent.inlineContent) {
          if ($from.pos == $to.pos) {
            // Deletion
            tr = view.state.tr.delete(from, to);
            storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
          } else if ( // Adding or removing a mark
          change.endA == change.endB && ($from1 = doc.resolve(change.start)) && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))) {
            tr = view.state.tr;
            if (markChange.type == "add") {
              tr.addMark(from, to, markChange.mark);
            } else {
              tr.removeMark(from, to, markChange.mark);
            }
          } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
            // Both positions in the same text node -- simply insert text
            var text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
            if (view.someProp("handleTextInput", function (f) {
              return f(view, from, to, text);
            })) {
              return;
            }
            tr = view.state.tr.insertText(text, from, to);
          }
        }

        if (!tr) {
          tr = view.state.tr.replace(from, to, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
        }
        if (parse.sel) {
          var sel$2 = resolveSelection(view, tr.doc, mapping, parse.sel);
          if (sel$2) {
            tr.setSelection(sel$2);
          }
        }
        if (storedMarks) {
          tr.ensureMarks(storedMarks);
        }
        view.dispatch(tr.scrollIntoView());
      }

      function resolveSelection(view, doc, mapping, parsedSel) {
        if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) {
          return null;
        }
        return selectionBetween(view, doc.resolve(mapping.map(parsedSel.anchor)), doc.resolve(mapping.map(parsedSel.head)));
      }

      // : (Fragment, Fragment) → ?{mark: Mark, type: string}
      // Given two same-length, non-empty fragments of inline content,
      // determine whether the first could be created from the second by
      // removing or adding a single mark type.
      function isMarkChange(cur, prev) {
        var curMarks = cur.firstChild.marks,
            prevMarks = prev.firstChild.marks;
        var added = curMarks,
            removed = prevMarks,
            type,
            mark,
            update;
        for (var i = 0; i < prevMarks.length; i++) {
          added = prevMarks[i].removeFromSet(added);
        }
        for (var i$1 = 0; i$1 < curMarks.length; i$1++) {
          removed = curMarks[i$1].removeFromSet(removed);
        }
        if (added.length == 1 && removed.length == 0) {
          mark = added[0];
          type = "add";
          update = function update(node) {
            return node.mark(mark.addToSet(node.marks));
          };
        } else if (added.length == 0 && removed.length == 1) {
          mark = removed[0];
          type = "remove";
          update = function update(node) {
            return node.mark(mark.removeFromSet(node.marks));
          };
        } else {
          return null;
        }
        var updated = [];
        for (var i$2 = 0; i$2 < prev.childCount; i$2++) {
          updated.push(update(prev.child(i$2)));
        }
        if (dist.Fragment.from(updated).eq(cur)) {
          return { mark: mark, type: type };
        }
      }

      function looksLikeJoin(old, start, end, $newStart, $newEnd) {
        if (!$newStart.parent.isTextblock ||
        // The content must have shrunk
        end - start <= $newEnd.pos - $newStart.pos ||
        // newEnd must point directly at or after the end of the block that newStart points into
        skipClosingAndOpening($newStart, true, false) < $newEnd.pos) {
          return false;
        }

        var $start = old.resolve(start);
        // Start must be at the end of a block
        if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
          return false;
        }
        var $next = old.resolve(skipClosingAndOpening($start, true, true));
        // The next textblock must start before end and end near it
        if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) {
          return false;
        }

        // The fragments after the join point must match
        return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
      }

      function skipClosingAndOpening($pos, fromEnd, mayOpen) {
        var depth = $pos.depth,
            end = fromEnd ? $pos.end() : $pos.pos;
        while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
          depth--;
          end++;
          fromEnd = false;
        }
        if (mayOpen) {
          var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
          while (next && !next.isLeaf) {
            next = next.firstChild;
            end++;
          }
        }
        return end;
      }

      function findDiff(a, b, pos, preferredPos, preferredSide) {
        var start = a.findDiffStart(b, pos);
        if (start == null) {
          return null;
        }
        var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);
        var endA = ref.a;
        var endB = ref.b;
        if (preferredSide == "end") {
          var adjust = Math.max(0, start - Math.min(endA, endB));
          preferredPos -= endA + adjust - start;
        }
        if (endA < start && a.size < b.size) {
          var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
          start -= move;
          endB = start + (endB - endA);
          endA = start;
        } else if (endB < start) {
          var move$1 = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
          start -= move$1;
          endA = start + (endA - endB);
          endB = start;
        }
        return { start: start, endA: endA, endB: endB };
      }

      function serializeForClipboard(view, slice) {
        var context = [];
        var content = slice.content;
        var openStart = slice.openStart;
        var openEnd = slice.openEnd;
        while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
          openStart--;
          openEnd--;
          var node = content.firstChild;
          context.push(node.type.name, node.type.hasRequiredAttrs() ? node.attrs : null);
          content = node.content;
        }

        var serializer = view.someProp("clipboardSerializer") || dist.DOMSerializer.fromSchema(view.state.schema);
        var wrap = document.createElement("div");
        wrap.appendChild(serializer.serializeFragment(content));

        var firstChild = wrap.firstChild,
            needsWrap;
        while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
          for (var i = needsWrap.length - 1; i >= 0; i--) {
            var wrapper = document.createElement(needsWrap[i]);
            while (wrap.firstChild) {
              wrapper.appendChild(wrap.firstChild);
            }
            wrap.appendChild(wrapper);
          }
          firstChild = wrap.firstChild;
        }

        if (firstChild && firstChild.nodeType == 1) {
          firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context));
        }

        var text = view.someProp("clipboardTextSerializer", function (f) {
          return f(slice);
        }) || slice.content.textBetween(0, slice.content.size, "\n\n");

        return { dom: wrap, text: text };
      }

      // : (EditorView, string, string, ?bool, ResolvedPos) → ?Slice
      // Read a slice of content from the clipboard (or drop data).
      function parseFromClipboard(view, text, html, plainText, $context) {
        var dom,
            inCode = $context.parent.type.spec.code,
            slice;
        if (!html && !text) {
          return null;
        }
        var asText = text && (plainText || inCode || !html);
        if (asText) {
          view.someProp("transformPastedText", function (f) {
            text = f(text);
          });
          if (inCode) {
            return new dist.Slice(dist.Fragment.from(view.state.schema.text(text)), 0, 0);
          }
          var parsed = view.someProp("clipboardTextParser", function (f) {
            return f(text, $context);
          });
          if (parsed) {
            slice = parsed;
          } else {
            dom = document.createElement("div");
            text.trim().split(/(?:\r\n?|\n)+/).forEach(function (block) {
              dom.appendChild(document.createElement("p")).textContent = block;
            });
          }
        } else {
          view.someProp("transformPastedHTML", function (f) {
            html = f(html);
          });
          dom = readHTML(html);
        }

        var contextNode = dom && dom.querySelector("[data-pm-slice]");
        var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
        if (!slice) {
          var parser = view.someProp("clipboardParser") || view.someProp("domParser") || dist.DOMParser.fromSchema(view.state.schema);
          slice = parser.parseSlice(dom, { preserveWhitespace: !!(asText || sliceData), context: $context });
        }
        if (sliceData) {
          slice = addContext(new dist.Slice(slice.content, Math.min(slice.openStart, +sliceData[1]), Math.min(slice.openEnd, +sliceData[2])), sliceData[3]);
        } else // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
          {
            slice = dist.Slice.maxOpen(normalizeSiblings(slice.content, $context), false);
          }
        view.someProp("transformPasted", function (f) {
          slice = f(slice);
        });
        return slice;
      }

      // Takes a slice parsed with parseSlice, which means there hasn't been
      // any content-expression checking done on the top nodes, tries to
      // find a parent node in the current context that might fit the nodes,
      // and if successful, rebuilds the slice so that it fits into that parent.
      //
      // This addresses the problem that Transform.replace expects a
      // coherent slice, and will fail to place a set of siblings that don't
      // fit anywhere in the schema.
      function normalizeSiblings(fragment, $context) {
        if (fragment.childCount < 2) {
          return fragment;
        }
        var loop = function loop(d) {
          var parent = $context.node(d);
          var match = parent.contentMatchAt($context.index(d));
          var lastWrap = void 0,
              result = [];
          fragment.forEach(function (node) {
            if (!result) {
              return;
            }
            var wrap = match.findWrapping(node.type),
                inLast;
            if (!wrap) {
              return result = null;
            }
            if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
              result[result.length - 1] = inLast;
            } else {
              if (result.length) {
                result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
              }
              var wrapped = withWrappers(node, wrap);
              result.push(wrapped);
              match = match.matchType(wrapped.type, wrapped.attrs);
              lastWrap = wrap;
            }
          });
          if (result) {
            return { v: dist.Fragment.from(result) };
          }
        };

        for (var d = $context.depth; d >= 0; d--) {
          var returned = loop(d);

          if (returned) return returned.v;
        }
        return fragment;
      }

      function withWrappers(node, wrap, from) {
        if (from === void 0) from = 0;

        for (var i = wrap.length - 1; i >= from; i--) {
          node = wrap[i].create(null, dist.Fragment.from(node));
        }
        return node;
      }

      // Used to group adjacent nodes wrapped in similar parents by
      // normalizeSiblings into the same parent node
      function addToSibling(wrap, lastWrap, node, sibling, depth) {
        if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
          var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
          if (inner) {
            return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
          }
          var match = sibling.contentMatchAt(sibling.childCount);
          if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) {
            return sibling.copy(sibling.content.append(dist.Fragment.from(withWrappers(node, wrap, depth + 1))));
          }
        }
      }

      function closeRight(node, depth) {
        if (depth == 0) {
          return node;
        }
        var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
        var fill = node.contentMatchAt(node.childCount).fillBefore(dist.Fragment.empty, true);
        return node.copy(fragment.append(fill));
      }

      // Trick from jQuery -- some elements must be wrapped in other
      // elements for innerHTML to work. I.e. if you do `div.innerHTML =
      // "<td>..</td>"` the table cells are ignored.
      var wrapMap = { thead: ["table"], colgroup: ["table"], col: ["table", "colgroup"],
        tr: ["table", "tbody"], td: ["table", "tbody", "tr"], th: ["table", "tbody", "tr"] };
      var detachedDoc = null;
      function readHTML(html) {
        var metas = /(\s*<meta [^>]*>)*/.exec(html);
        if (metas) {
          html = html.slice(metas[0].length);
        }
        var doc = detachedDoc || (detachedDoc = document.implementation.createHTMLDocument("title"));
        var elt = doc.createElement("div");
        var firstTag = /(?:<meta [^>]*>)*<([a-z][^>\s]+)/i.exec(html),
            wrap,
            depth = 0;
        if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {
          html = wrap.map(function (n) {
            return "<" + n + ">";
          }).join("") + html + wrap.map(function (n) {
            return "</" + n + ">";
          }).reverse().join("");
          depth = wrap.length;
        }
        elt.innerHTML = html;
        for (var i = 0; i < depth; i++) {
          elt = elt.firstChild;
        }
        return elt;
      }

      function addContext(slice, context) {
        if (!slice.size) {
          return slice;
        }
        var schema = slice.content.firstChild.type.schema,
            array;
        try {
          array = JSON.parse(context);
        } catch (e) {
          return slice;
        }
        var content = slice.content;
        var openStart = slice.openStart;
        var openEnd = slice.openEnd;
        for (var i = array.length - 2; i >= 0; i -= 2) {
          var type = schema.nodes[array[i]];
          if (!type || type.hasRequiredAttrs()) {
            break;
          }
          content = dist.Fragment.from(type.create(array[i + 1], content));
          openStart++;openEnd++;
        }
        return new dist.Slice(content, openStart, openEnd);
      }

      var observeOptions = { childList: true, characterData: true, attributes: true, subtree: true, characterDataOldValue: true };
      // IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified
      var useCharData = result.ie && result.ie_version <= 11;

      var DOMObserver = function DOMObserver(view) {
        var this$1 = this;

        this.view = view;
        this.observer = window.MutationObserver && new window.MutationObserver(function (mutations) {
          return this$1.registerMutations(mutations);
        });
        if (useCharData) {
          this.onCharData = function (e) {
            return this$1.registerMutation({ target: e.target, type: "characterData", oldValue: e.prevValue });
          };
        }
      };

      DOMObserver.prototype.start = function start() {
        if (this.observer) {
          this.observer.observe(this.view.dom, observeOptions);
        }
        if (useCharData) {
          this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        }
      };

      DOMObserver.prototype.stop = function stop() {
        if (this.observer) {
          this.flush();
          this.observer.disconnect();
        }
        if (useCharData) {
          this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
        }
      };

      DOMObserver.prototype.flush = function flush() {
        if (this.observer) {
          this.registerMutations(this.observer.takeRecords());
        }
      };

      DOMObserver.prototype.registerMutations = function registerMutations(mutations) {
        var this$1 = this;

        for (var i = 0; i < mutations.length; i++) {
          this$1.registerMutation(mutations[i]);
        }
      };

      DOMObserver.prototype.registerMutation = function registerMutation(mut) {
        if (!this.view.editable) {
          return;
        }
        var desc = this.view.docView.nearestDesc(mut.target);
        if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable")) {
          return;
        }
        if (!desc || desc.ignoreMutation(mut)) {
          return;
        }

        var from, to;
        if (mut.type == "childList") {
          var fromOffset = mut.previousSibling && mut.previousSibling.parentNode == mut.target ? domIndex(mut.previousSibling) + 1 : 0;
          if (fromOffset == -1) {
            return;
          }
          from = desc.localPosFromDOM(mut.target, fromOffset, -1);
          var toOffset = mut.nextSibling && mut.nextSibling.parentNode == mut.target ? domIndex(mut.nextSibling) : mut.target.childNodes.length;
          if (toOffset == -1) {
            return;
          }
          to = desc.localPosFromDOM(mut.target, toOffset, 1);
        } else if (mut.type == "attributes") {
          from = desc.posAtStart - desc.border;
          to = desc.posAtEnd + desc.border;
        } else {
          // "characterData"
          from = desc.posAtStart;
          to = desc.posAtEnd;
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          if (mut.target.nodeValue == mut.oldValue) {
            DOMChange.start(this.view).typeOver = true;
          }
        }

        DOMChange.start(this.view).addRange(from, to);
      };

      // A collection of DOM events that occur within the editor, and callback functions
      // to invoke when the event fires.
      var handlers = {};
      var editHandlers = {};

      function initInput(view) {
        view.shiftKey = false;
        view.mouseDown = null;
        view.inDOMChange = null;
        view.lastKeyCode = null;
        view.lastKeyCodeTime = 0;
        view.lastClick = { time: 0, x: 0, y: 0, type: "" };
        view.domObserver = new DOMObserver(view);
        view.domObserver.start();
        // Used by hacks like the beforeinput handler to check whether anything happened in the DOM
        view.domChangeCount = 0;

        view.eventHandlers = Object.create(null);
        var loop = function loop(event) {
          var handler = handlers[event];
          view.dom.addEventListener(event, view.eventHandlers[event] = function (event) {
            if (eventBelongsToView(view, event) && !runCustomHandler(view, event) && (view.editable || !(event.type in editHandlers))) {
              handler(view, event);
            }
          });
        };

        for (var event in handlers) loop(event);
        ensureListeners(view);
      }

      function destroyInput(view) {
        view.domObserver.stop();
        if (view.inDOMChange) {
          view.inDOMChange.destroy();
        }
        for (var type in view.eventHandlers) {
          view.dom.removeEventListener(type, view.eventHandlers[type]);
        }
      }

      function ensureListeners(view) {
        view.someProp("handleDOMEvents", function (currentHandlers) {
          for (var type in currentHandlers) {
            if (!view.eventHandlers[type]) {
              view.dom.addEventListener(type, view.eventHandlers[type] = function (event) {
                return runCustomHandler(view, event);
              });
            }
          }
        });
      }

      function runCustomHandler(view, event) {
        return view.someProp("handleDOMEvents", function (handlers) {
          var handler = handlers[event.type];
          return handler ? handler(view, event) || event.defaultPrevented : false;
        });
      }

      function eventBelongsToView(view, event) {
        if (!event.bubbles) {
          return true;
        }
        if (event.defaultPrevented) {
          return false;
        }
        for (var node = event.target; node != view.dom; node = node.parentNode) {
          if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) {
            return false;
          }
        }
        return true;
      }

      function dispatchEvent(view, event) {
        if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) {
          handlers[event.type](view, event);
        }
      }

      editHandlers.keydown = function (view, event) {
        view.shiftKey = event.keyCode == 16 || event.shiftKey;
        if (view.inDOMChange) {
          if (view.inDOMChange.composing) {
            return;
          }
          if (view.inDOMChange.ignoreKeyDownOnCompositionEnd(event)) {
            return;
          }
          view.inDOMChange.finish();
        }
        view.lastKeyCode = event.keyCode;
        view.lastKeyCodeTime = Date.now();
        if (view.someProp("handleKeyDown", function (f) {
          return f(view, event);
        }) || captureKeyDown(view, event)) {
          event.preventDefault();
        } else {
          view.selectionReader.poll("key");
        }
      };

      editHandlers.keyup = function (view, e) {
        if (e.keyCode == 16) {
          view.shiftKey = false;
        }
      };

      editHandlers.keypress = function (view, event) {
        if (view.inDOMChange || !event.charCode || event.ctrlKey && !event.altKey || result.mac && event.metaKey) {
          return;
        }

        if (view.someProp("handleKeyPress", function (f) {
          return f(view, event);
        })) {
          event.preventDefault();
          return;
        }

        var sel = view.state.selection;
        if (!(sel instanceof dist$2.TextSelection) || !sel.$from.sameParent(sel.$to)) {
          var text = String.fromCharCode(event.charCode);
          if (!view.someProp("handleTextInput", function (f) {
            return f(view, sel.$from.pos, sel.$to.pos, text);
          })) {
            view.dispatch(view.state.tr.insertText(text).scrollIntoView());
          }
          event.preventDefault();
        }
      };

      function eventCoords(event) {
        return { left: event.clientX, top: event.clientY };
      }

      function isNear(event, click) {
        var dx = click.x - event.clientX,
            dy = click.y - event.clientY;
        return dx * dx + dy * dy < 100;
      }

      function runHandlerOnContext(view, propName, pos, inside, event) {
        if (inside == -1) {
          return false;
        }
        var $pos = view.state.doc.resolve(inside);
        var loop = function loop(i) {
          if (view.someProp(propName, function (f) {
            return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false);
          })) {
            return { v: true };
          }
        };

        for (var i = $pos.depth + 1; i > 0; i--) {
          var returned = loop(i);

          if (returned) return returned.v;
        }
        return false;
      }

      function updateSelection(view, selection, origin) {
        if (!view.focused) {
          view.focus();
        }
        var tr = view.state.tr.setSelection(selection);
        if (origin == "pointer") {
          tr.setMeta("pointer", true);
        }
        view.dispatch(tr);
      }

      function selectClickedLeaf(view, inside) {
        if (inside == -1) {
          return false;
        }
        var $pos = view.state.doc.resolve(inside),
            node = $pos.nodeAfter;
        if (node && node.isAtom && dist$2.NodeSelection.isSelectable(node)) {
          updateSelection(view, new dist$2.NodeSelection($pos), "pointer");
          return true;
        }
        return false;
      }

      function selectClickedNode(view, inside) {
        if (inside == -1) {
          return false;
        }
        var sel = view.state.selection,
            selectedNode,
            selectAt;
        if (sel instanceof dist$2.NodeSelection) {
          selectedNode = sel.node;
        }

        var $pos = view.state.doc.resolve(inside);
        for (var i = $pos.depth + 1; i > 0; i--) {
          var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
          if (dist$2.NodeSelection.isSelectable(node)) {
            if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
              selectAt = $pos.before(sel.$from.depth);
            } else {
              selectAt = $pos.before(i);
            }
            break;
          }
        }

        if (selectAt != null) {
          updateSelection(view, dist$2.NodeSelection.create(view.state.doc, selectAt), "pointer");
          return true;
        } else {
          return false;
        }
      }

      function handleSingleClick(view, pos, inside, event, selectNode) {
        return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function (f) {
          return f(view, pos, event);
        }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
      }

      function handleDoubleClick(view, pos, inside, event) {
        return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function (f) {
          return f(view, pos, event);
        });
      }

      function handleTripleClick(view, pos, inside, event) {
        return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function (f) {
          return f(view, pos, event);
        }) || defaultTripleClick(view, inside);
      }

      function defaultTripleClick(view, inside) {
        var doc = view.state.doc;
        if (inside == -1) {
          if (doc.inlineContent) {
            updateSelection(view, dist$2.TextSelection.create(doc, 0, doc.content.size), "pointer");
            return true;
          }
          return false;
        }

        var $pos = doc.resolve(inside);
        for (var i = $pos.depth + 1; i > 0; i--) {
          var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
          var nodePos = $pos.before(i);
          if (node.inlineContent) {
            updateSelection(view, dist$2.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
          } else if (dist$2.NodeSelection.isSelectable(node)) {
            updateSelection(view, dist$2.NodeSelection.create(doc, nodePos), "pointer");
          } else {
            continue;
          }
          return true;
        }
      }

      function forceDOMFlush(view) {
        if (!view.inDOMChange) {
          return false;
        }
        view.inDOMChange.finish(true);
        return true;
      }

      var selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";

      handlers.mousedown = function (view, event) {
        view.shiftKey = event.shiftKey;
        var flushed = forceDOMFlush(view);
        var now = Date.now(),
            type = "singleClick";
        if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
          if (view.lastClick.type == "singleClick") {
            type = "doubleClick";
          } else if (view.lastClick.type == "doubleClick") {
            type = "tripleClick";
          }
        }
        view.lastClick = { time: now, x: event.clientX, y: event.clientY, type: type };

        var pos = view.posAtCoords(eventCoords(event));
        if (!pos) {
          return;
        }

        if (type == "singleClick") {
          view.mouseDown = new MouseDown(view, pos, event, flushed);
        } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
          event.preventDefault();
        } else {
          view.selectionReader.poll("pointer");
        }
      };

      var MouseDown = function MouseDown(view, pos, event, flushed) {
        var this$1 = this;

        this.view = view;
        this.pos = pos;
        this.event = event;
        this.flushed = flushed;
        this.selectNode = event[selectNodeModifier];
        this.allowDefault = event.shiftKey;

        var targetNode, targetPos;
        if (pos.inside > -1) {
          targetNode = view.state.doc.nodeAt(pos.inside);
          targetPos = pos.inside;
        } else {
          var $pos = view.state.doc.resolve(pos.pos);
          targetNode = $pos.parent;
          targetPos = $pos.depth ? $pos.before() : 0;
        }

        this.mightDrag = null;

        var target = flushed ? null : event.target;
        var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
        this.target = targetDesc ? targetDesc.dom : null;

        if (targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || view.state.selection instanceof dist$2.NodeSelection && targetPos == view.state.selection.from) {
          this.mightDrag = { node: targetNode,
            pos: targetPos,
            addAttr: this.target && !this.target.draggable,
            setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable") };
        }

        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr) {
            this.target.draggable = true;
          }
          if (this.mightDrag.setUneditable) {
            setTimeout(function () {
              return this$1.target.setAttribute("contentEditable", "false");
            }, 20);
          }
          this.view.domObserver.start();
        }

        view.root.addEventListener("mouseup", this.up = this.up.bind(this));
        view.root.addEventListener("mousemove", this.move = this.move.bind(this));
        view.selectionReader.poll("pointer");
      };

      MouseDown.prototype.done = function done() {
        this.view.root.removeEventListener("mouseup", this.up);
        this.view.root.removeEventListener("mousemove", this.move);
        if (this.mightDrag && this.target) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr) {
            this.target.draggable = false;
          }
          if (this.mightDrag.setUneditable) {
            this.target.removeAttribute("contentEditable");
          }
          this.view.domObserver.start();
        }
        this.view.mouseDown = null;
      };

      MouseDown.prototype.up = function up(event) {
        this.done();

        if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
          return;
        }

        if (this.allowDefault) {
          // Force a cursor wrapper redraw if this was suppressed (to avoid an issue with IE drag-selection)
          if (result.ie && needsCursorWrapper(this.view.state)) {
            this.view.updateState(this.view.state);
          }
          this.view.selectionReader.poll("pointer");
        } else if (handleSingleClick(this.view, this.pos.pos, this.pos.inside, event, this.selectNode)) {
          event.preventDefault();
        } else if (this.flushed ||
        // Chrome will sometimes treat a node selection as a
        // cursor, but still report that the node is selected
        // when asked through getSelection. You'll then get a
        // situation where clicking at the point where that
        // (hidden) cursor is doesn't change the selection, and
        // thus doesn't get a reaction from ProseMirror. This
        // works around that.
        result.chrome && !(this.view.state.selection instanceof dist$2.TextSelection) && (this.pos.pos == this.view.state.selection.from || this.pos.pos == this.view.state.selection.to)) {
          updateSelection(this.view, dist$2.Selection.near(this.view.state.doc.resolve(this.pos.pos)), "pointer");
          event.preventDefault();
        } else {
          this.view.selectionReader.poll("pointer");
        }
      };

      MouseDown.prototype.move = function move(event) {
        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
          this.allowDefault = true;
        }
        this.view.selectionReader.poll("pointer");
      };

      handlers.touchdown = function (view) {
        forceDOMFlush(view);
        view.selectionReader.poll("pointer");
      };

      handlers.contextmenu = function (view) {
        return forceDOMFlush(view);
      };

      // Input compositions are hard. Mostly because the events fired by
      // browsers are A) very unpredictable and inconsistent, and B) not
      // cancelable.
      //
      // ProseMirror has the problem that it must not update the DOM during
      // a composition, or the browser will cancel it. What it does is keep
      // long-running operations (delayed DOM updates) when a composition is
      // active.
      //
      // We _do not_ trust the information in the composition events which,
      // apart from being very uninformative to begin with, is often just
      // plain wrong. Instead, when a composition ends, we parse the dom
      // around the original selection, and derive an update from that.

      editHandlers.compositionstart = editHandlers.compositionupdate = function (view) {
        DOMChange.start(view, true);
      };

      editHandlers.compositionend = function (view, e) {
        if (!view.inDOMChange) {
          // We received a compositionend without having seen any previous
          // events for the composition. If there's data in the event
          // object, we assume that it's a real change, and start a
          // composition. Otherwise, we just ignore it.
          if (e.data) {
            DOMChange.start(view, true);
          } else {
            return;
          }
        }

        view.inDOMChange.compositionEnd(e);
      };

      editHandlers.input = function (view) {
        var change = DOMChange.start(view);
        if (!change.composing) {
          change.finish();
        }
      };

      function captureCopy(view, dom) {
        // The extra wrapper is somehow necessary on IE/Edge to prevent the
        // content from being mangled when it is put onto the clipboard
        var doc = dom.ownerDocument;
        var wrap = doc.body.appendChild(doc.createElement("div"));
        wrap.appendChild(dom);
        wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
        var sel = getSelection(),
            range = doc.createRange();
        range.selectNodeContents(dom);
        // Done because IE will fire a selectionchange moving the selection
        // to its start when removeAllRanges is called and the editor still
        // has focus (which will mess up the editor's selection state).
        view.dom.blur();
        sel.removeAllRanges();
        sel.addRange(range);
        setTimeout(function () {
          doc.body.removeChild(wrap);
          view.focus();
        }, 50);
      }

      // This is very crude, but unfortunately both these browsers _pretend_
      // that they have a clipboard API—all the objects and methods are
      // there, they just don't work, and they are hard to test.
      var brokenClipboardAPI = result.ie && result.ie_version < 15 || result.ios && result.webkit_version < 604;

      handlers.copy = editHandlers.cut = function (view, e) {
        var sel = view.state.selection,
            cut = e.type == "cut";
        if (sel.empty) {
          return;
        }

        // IE and Edge's clipboard interface is completely broken
        var data = brokenClipboardAPI ? null : e.clipboardData;
        var slice = sel.content();
        var ref = serializeForClipboard(view, slice);
        var dom = ref.dom;
        var text = ref.text;
        if (data) {
          e.preventDefault();
          data.clearData();
          data.setData("text/html", dom.innerHTML);
          data.setData("text/plain", text);
        } else {
          captureCopy(view, dom);
        }
        if (cut) {
          view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
        }
      };

      function sliceSingleNode(slice) {
        return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
      }

      function capturePaste(view, e) {
        var doc = view.dom.ownerDocument;
        var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
        var target = doc.body.appendChild(doc.createElement(plainText ? "textarea" : "div"));
        if (!plainText) {
          target.contentEditable = "true";
        }
        target.style.cssText = "position: fixed; left: -10000px; top: 10px";
        target.focus();
        setTimeout(function () {
          view.focus();
          doc.body.removeChild(target);
          if (plainText) {
            doPaste(view, target.value, null, e);
          } else {
            doPaste(view, target.textContent, target.innerHTML, e);
          }
        }, 50);
      }

      function doPaste(view, text, html, e) {
        var slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from);
        if (view.someProp("handlePaste", function (f) {
          return f(view, e, slice || dist.Slice.empty);
        }) || !slice) {
          return true;
        }

        var singleNode = sliceSingleNode(slice);
        var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice);
        view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
        return true;
      }

      editHandlers.paste = function (view, e) {
        var data = brokenClipboardAPI ? null : e.clipboardData;
        if (data && (doPaste(view, data.getData("text/plain"), data.getData("text/html"), e) || data.files.length > 0)) {
          e.preventDefault();
        } else {
          capturePaste(view, e);
        }
      };

      var Dragging = function Dragging(slice, move) {
        this.slice = slice;
        this.move = move;
      };

      var dragCopyModifier = result.mac ? "altKey" : "ctrlKey";

      handlers.dragstart = function (view, e) {
        var mouseDown = view.mouseDown;
        if (mouseDown) {
          mouseDown.done();
        }
        if (!e.dataTransfer) {
          return;
        }

        var sel = view.state.selection;
        var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));
        if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof dist$2.NodeSelection ? sel.to - 1 : sel.to)) {
          // In selection
        } else if (mouseDown && mouseDown.mightDrag) {
          view.dispatch(view.state.tr.setSelection(dist$2.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
        } else if (e.target && e.target.nodeType == 1) {
          var desc = view.docView.nearestDesc(e.target, true);
          if (!desc || !desc.node.type.spec.draggable || desc == view.docView) {
            return;
          }
          view.dispatch(view.state.tr.setSelection(dist$2.NodeSelection.create(view.state.doc, desc.posBefore)));
        }
        var slice = view.state.selection.content();
        var ref = serializeForClipboard(view, slice);
        var dom = ref.dom;
        var text = ref.text;
        e.dataTransfer.clearData();
        e.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
        if (!brokenClipboardAPI) {
          e.dataTransfer.setData("text/plain", text);
        }
        view.dragging = new Dragging(slice, !e[dragCopyModifier]);
      };

      handlers.dragend = function (view) {
        window.setTimeout(function () {
          return view.dragging = null;
        }, 50);
      };

      editHandlers.dragover = editHandlers.dragenter = function (_, e) {
        return e.preventDefault();
      };

      editHandlers.drop = function (view, e) {
        var dragging = view.dragging;
        view.dragging = null;

        if (!e.dataTransfer) {
          return;
        }

        var eventPos = view.posAtCoords(eventCoords(e));
        if (!eventPos) {
          return;
        }
        var $mouse = view.state.doc.resolve(eventPos.pos);
        if (!$mouse) {
          return;
        }
        var slice = dragging && dragging.slice || parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : e.dataTransfer.getData("text/html"), false, $mouse);
        if (!slice) {
          return;
        }

        e.preventDefault();
        if (view.someProp("handleDrop", function (f) {
          return f(view, e, slice, dragging && dragging.move);
        })) {
          return;
        }
        var insertPos = slice ? dist$1.dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
        if (insertPos == null) {
          insertPos = $mouse.pos;
        }

        var tr = view.state.tr;
        if (dragging && dragging.move) {
          tr.deleteSelection();
        }

        var pos = tr.mapping.map(insertPos);
        var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
        var beforeInsert = tr.doc;
        if (isNode) {
          tr.replaceRangeWith(pos, pos, slice.content.firstChild);
        } else {
          tr.replaceRange(pos, pos, slice);
        }
        if (tr.doc.eq(beforeInsert)) {
          return;
        }

        var $pos = tr.doc.resolve(pos);
        if (isNode && dist$2.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
          tr.setSelection(new dist$2.NodeSelection($pos));
        } else {
          tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(tr.mapping.map(insertPos))));
        }
        view.focus();
        view.dispatch(tr.setMeta("uiEvent", "drop"));
      };

      handlers.focus = function (view) {
        if (!view.focused) {
          view.dom.classList.add("ProseMirror-focused");
          view.focused = true;
        }
      };

      handlers.blur = function (view) {
        if (view.focused) {
          view.dom.classList.remove("ProseMirror-focused");
          view.focused = false;
        }
      };

      handlers.beforeinput = function (view, event) {
        // We should probably do more with beforeinput events, but support
        // is so spotty that I'm still waiting to see where they are going.

        // Very specific hack to deal with backspace sometimes failing on
        // Chrome Android when after an uneditable node.
        if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
          var domChangeCount = view.domChangeCount;
          setTimeout(function () {
            if (view.domChangeCount != domChangeCount) {
              return;
            } // Event already had some effect
            // This bug tends to close the virtual keyboard, so we refocus
            view.dom.blur();
            view.focus();
            if (view.someProp("handleKeyDown", function (f) {
              return f(view, keyEvent(8, "Backspace"));
            })) {
              return;
            }
            var ref = view.state.selection;
            var $cursor = ref.$cursor;
            // Crude approximation of backspace behavior when no command handled it
            if ($cursor && $cursor.pos > 0) {
              view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
            }
          }, 50);
        }
      };

      // Make sure all handlers get registered
      for (var prop in editHandlers) {
        handlers[prop] = editHandlers[prop];
      }

      function compareObjs(a, b) {
        if (a == b) {
          return true;
        }
        for (var p in a) {
          if (a[p] !== b[p]) {
            return false;
          }
        }
        for (var p$1 in b) {
          if (!(p$1 in a)) {
            return false;
          }
        }
        return true;
      }

      var WidgetType = function WidgetType(toDOM, spec) {
        this.spec = spec || noSpec;
        this.side = this.spec.side || 0;
        this.toDOM = toDOM;
      };

      WidgetType.prototype.map = function map(mapping, span, offset, oldOffset) {
        var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
        var pos = ref.pos;
        var deleted = ref.deleted;
        return deleted ? null : new Decoration(pos - offset, pos - offset, this);
      };

      WidgetType.prototype.valid = function valid() {
        return true;
      };

      WidgetType.prototype.eq = function eq(other) {
        return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
      };

      var InlineType = function InlineType(attrs, spec) {
        this.spec = spec || noSpec;
        this.attrs = attrs;
      };

      InlineType.prototype.map = function map(mapping, span, offset, oldOffset) {
        var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
        var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
        return from >= to ? null : new Decoration(from, to, this);
      };

      InlineType.prototype.valid = function valid(_, span) {
        return span.from < span.to;
      };

      InlineType.prototype.eq = function eq(other) {
        return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
      };

      InlineType.is = function is(span) {
        return span.type instanceof InlineType;
      };

      var NodeType = function NodeType(attrs, spec) {
        this.spec = spec || noSpec;
        this.attrs = attrs;
      };

      NodeType.prototype.map = function map(mapping, span, offset, oldOffset) {
        var from = mapping.mapResult(span.from + oldOffset, 1);
        if (from.deleted) {
          return null;
        }
        var to = mapping.mapResult(span.to + oldOffset, -1);
        if (to.deleted || to.pos <= from.pos) {
          return null;
        }
        return new Decoration(from.pos - offset, to.pos - offset, this);
      };

      NodeType.prototype.valid = function valid(node, span) {
        var ref = node.content.findIndex(span.from);
        var index = ref.index;
        var offset = ref.offset;
        return offset == span.from && offset + node.child(index).nodeSize == span.to;
      };

      NodeType.prototype.eq = function eq(other) {
        return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
      };

      // ::- Decoration objects can be provided to the view through the
      // [`decorations` prop](#view.EditorProps.decorations). They come in
      // several variants—see the static members of this class for details.
      var Decoration = function Decoration(from, to, type) {
        // :: number
        // The start position of the decoration.
        this.from = from;
        // :: number
        // The end position. Will be the same as `from` for [widget
        // decorations](#view.Decoration^widget).
        this.to = to;
        this.type = type;
      };

      var prototypeAccessors$2 = { spec: {} };

      Decoration.prototype.copy = function copy(from, to) {
        return new Decoration(from, to, this.type);
      };

      Decoration.prototype.eq = function eq(other) {
        return this.type.eq(other.type) && this.from == other.from && this.to == other.to;
      };

      Decoration.prototype.map = function map(mapping, offset, oldOffset) {
        return this.type.map(mapping, this, offset, oldOffset);
      };

      // :: (number, union<(view: EditorView, getPos: () → number) → dom.Node, dom.Node>, ?Object) → Decoration
      // Creates a widget decoration, which is a DOM node that's shown in
      // the document at the given position. It is recommended that you
      // delay rendering the widget by passing a function that will be
      // called when the widget is actually drawn in a view, but you can
      // also directly pass a DOM node. `getPos` can be used to find the
      // widget's current document position.
      //
      // spec::- These options are supported:
      //
      //   side:: ?number
      //   Controls which side of the document position this widget is
      //   associated with. When negative, it is drawn before a cursor
      //   at its position, and content inserted at that position ends
      //   up after the widget. When zero (the default) or positive, the
      //   widget is drawn after the cursor and content inserted there
      //   ends up before the widget.
      //
      //   When there are multiple widgets at a given position, their
      //   `side` values determine the order in which they appear. Those
      //   with lower values appear first. The ordering of widgets with
      //   the same `side` value is unspecified.
      //
      //   When `marks` is null, `side` also determines the marks that
      //   the widget is wrapped in—those of the node before when
      //   negative, those of the node after when positive.
      //
      //   marks:: ?[Mark]
      //   The precise set of marks to draw around the widget.
      //
      //   stopEvent:: ?(event: dom.Event) → bool
      //   Can be used to control which DOM events, when they bubble out
      //   of this widget, the editor view should ignore.
      //
      //   key:: ?string
      //   When comparing decorations of this type (in order to decide
      //   whether it needs to be redrawn), ProseMirror will by default
      //   compare the widget DOM node by identity. If you pass a key,
      //   that key will be compared instead, which can be useful when
      //   you generate decorations on the fly and don't want to store
      //   and reuse DOM nodes. Make sure that any widgets with the same
      //   key are interchangeable—if widgets differ in, for example,
      //   the behavior of some event handler, they should get
      //   different keys.
      Decoration.widget = function widget(pos, toDOM, spec) {
        return new Decoration(pos, pos, new WidgetType(toDOM, spec));
      };

      // :: (number, number, DecorationAttrs, ?Object) → Decoration
      // Creates an inline decoration, which adds the given attributes to
      // each inline node between `from` and `to`.
      //
      // spec::- These options are recognized:
      //
      //   inclusiveStart:: ?bool
      //   Determines how the left side of the decoration is
      //   [mapped](#transform.Position_Mapping) when content is
      //   inserted directly at that position. By default, the decoration
      //   won't include the new content, but you can set this to `true`
      //   to make it inclusive.
      //
      //   inclusiveEnd:: ?bool
      //   Determines how the right side of the decoration is mapped.
      //   See
      //   [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).
      Decoration.inline = function inline(from, to, attrs, spec) {
        return new Decoration(from, to, new InlineType(attrs, spec));
      };

      // :: (number, number, DecorationAttrs, ?Object) → Decoration
      // Creates a node decoration. `from` and `to` should point precisely
      // before and after a node in the document. That node, and only that
      // node, will receive the given attributes.
      Decoration.node = function node(from, to, attrs, spec) {
        return new Decoration(from, to, new NodeType(attrs, spec));
      };

      // :: Object
      // The spec provided when creating this decoration. Can be useful
      // if you've stored extra information in that object.
      prototypeAccessors$2.spec.get = function () {
        return this.type.spec;
      };

      Object.defineProperties(Decoration.prototype, prototypeAccessors$2);

      // DecorationAttrs:: interface
      // A set of attributes to add to a decorated node. Most properties
      // simply directly correspond to DOM attributes of the same name,
      // which will be set to the property's value. These are exceptions:
      //
      //   class:: ?string
      //   A CSS class name or a space-separated set of class names to be
      //   _added_ to the classes that the node already had.
      //
      //   style:: ?string
      //   A string of CSS to be _added_ to the node's existing `style` property.
      //
      //   nodeName:: ?string
      //   When non-null, the target node is wrapped in a DOM element of
      //   this type (and the other attributes are applied to this element).

      var none = [];
      var noSpec = {};

      // ::- A collection of [decorations](#view.Decoration), organized in
      // such a way that the drawing algorithm can efficiently use and
      // compare them. This is a persistent data structure—it is not
      // modified, updates create a new value.
      var DecorationSet = function DecorationSet(local, children) {
        this.local = local && local.length ? local : none;
        this.children = children && children.length ? children : none;
      };

      // :: (Node, [Decoration]) → DecorationSet
      // Create a set of decorations, using the structure of the given
      // document.
      DecorationSet.create = function create(doc, decorations) {
        return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;
      };

      // :: (?number, ?number, ?(spec: Object) → bool) → [Decoration]
      // Find all decorations in this set which touch the given range
      // (including decorations that start or end directly at the
      // boundaries) and match the given predicate on their spec. When
      // `start` and `end` are omitted, all decorations in the set are
      // considered. When `predicate` isn't given, all decorations are
      // asssumed to match.
      DecorationSet.prototype.find = function find(start, end, predicate) {
        var result = [];
        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
        return result;
      };

      DecorationSet.prototype.findInner = function findInner(start, end, result, offset, predicate) {
        var this$1 = this;

        for (var i = 0; i < this.local.length; i++) {
          var span = this$1.local[i];
          if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) {
            result.push(span.copy(span.from + offset, span.to + offset));
          }
        }
        for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
          if (this$1.children[i$1] < end && this$1.children[i$1 + 1] > start) {
            var childOff = this$1.children[i$1] + 1;
            this$1.children[i$1 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
          }
        }
      };

      // :: (Mapping, Node, ?Object) → DecorationSet
      // Map the set of decorations in response to a change in the
      // document.
      //
      // options::- An optional set of options.
      //
      //   onRemove:: ?(decorationSpec: Object)
      //   When given, this function will be called for each decoration
      //   that gets dropped as a result of the mapping, passing the
      //   spec of that decoration.
      DecorationSet.prototype.map = function map(mapping, doc, options) {
        if (this == empty || mapping.maps.length == 0) {
          return this;
        }
        return this.mapInner(mapping, doc, 0, 0, options || noSpec);
      };

      DecorationSet.prototype.mapInner = function mapInner(mapping, node, offset, oldOffset, options) {
        var this$1 = this;

        var newLocal;
        for (var i = 0; i < this.local.length; i++) {
          var mapped = this$1.local[i].map(mapping, offset, oldOffset);
          if (mapped && mapped.type.valid(node, mapped)) {
            (newLocal || (newLocal = [])).push(mapped);
          } else if (options.onRemove) {
            options.onRemove(this$1.local[i].spec);
          }
        }

        if (this.children.length) {
          return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options);
        } else {
          return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty;
        }
      };

      // :: (Node, [Decoration]) → DecorationSet
      // Add the given array of decorations to the ones in the set,
      // producing a new set. Needs access to the current document to
      // create the appropriate tree structure.
      DecorationSet.prototype.add = function add(doc, decorations) {
        if (!decorations.length) {
          return this;
        }
        if (this == empty) {
          return DecorationSet.create(doc, decorations);
        }
        return this.addInner(doc, decorations, 0);
      };

      DecorationSet.prototype.addInner = function addInner(doc, decorations, offset) {
        var this$1 = this;

        var children,
            childIndex = 0;
        doc.forEach(function (childNode, childOffset) {
          var baseOffset = childOffset + offset,
              found;
          if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) {
            return;
          }

          if (!children) {
            children = this$1.children.slice();
          }
          while (childIndex < children.length && children[childIndex] < childOffset) {
            childIndex += 3;
          }
          if (children[childIndex] == childOffset) {
            children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);
          } else {
            children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
          }
          childIndex += 3;
        });

        var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
      };

      // :: ([Decoration]) → DecorationSet
      // Create a new set that contains the decorations in this set, minus
      // the ones in the given array.
      DecorationSet.prototype.remove = function remove(decorations) {
        if (decorations.length == 0 || this == empty) {
          return this;
        }
        return this.removeInner(decorations, 0);
      };

      DecorationSet.prototype.removeInner = function removeInner(decorations, offset) {
        var this$1 = this;

        var children = this.children,
            local = this.local;
        for (var i = 0; i < children.length; i += 3) {
          var found = void 0,
              from = children[i] + offset,
              to = children[i + 1] + offset;
          for (var j = 0, span = void 0; j < decorations.length; j++) {
            if (span = decorations[j]) {
              if (span.from > from && span.to < to) {
                decorations[j] = null;(found || (found = [])).push(span);
              }
            }
          }
          if (!found) {
            continue;
          }
          if (children == this$1.children) {
            children = this$1.children.slice();
          }
          var removed = children[i + 2].removeInner(found, from + 1);
          if (removed != empty) {
            children[i + 2] = removed;
          } else {
            children.splice(i, 3);
            i -= 3;
          }
        }
        if (local.length) {
          for (var i$1 = 0, span$1 = void 0; i$1 < decorations.length; i$1++) {
            if (span$1 = decorations[i$1]) {
              for (var j$1 = 0; j$1 < local.length; j$1++) {
                if (local[j$1].type.eq(span$1.type)) {
                  if (local == this$1.local) {
                    local = this$1.local.slice();
                  }
                  local.splice(j$1--, 1);
                }
              }
            }
          }
        }
        if (children == this.children && local == this.local) {
          return this;
        }
        return local.length || children.length ? new DecorationSet(local, children) : empty;
      };

      DecorationSet.prototype.forChild = function forChild(offset, node) {
        var this$1 = this;

        if (this == empty) {
          return this;
        }
        if (node.isLeaf) {
          return DecorationSet.empty;
        }

        var child, local;
        for (var i = 0; i < this.children.length; i += 3) {
          if (this$1.children[i] >= offset) {
            if (this$1.children[i] == offset) {
              child = this$1.children[i + 2];
            }
            break;
          }
        }
        var start = offset + 1,
            end = start + node.content.size;
        for (var i$1 = 0; i$1 < this.local.length; i$1++) {
          var dec = this$1.local[i$1];
          if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
            var from = Math.max(start, dec.from) - start,
                to = Math.min(end, dec.to) - start;
            if (from < to) {
              (local || (local = [])).push(dec.copy(from, to));
            }
          }
        }
        if (local) {
          var localSet = new DecorationSet(local.sort(byPos));
          return child ? new DecorationGroup([localSet, child]) : localSet;
        }
        return child || empty;
      };

      DecorationSet.prototype.eq = function eq(other) {
        var this$1 = this;

        if (this == other) {
          return true;
        }
        if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) {
          return false;
        }
        for (var i = 0; i < this.local.length; i++) {
          if (!this$1.local[i].eq(other.local[i])) {
            return false;
          }
        }
        for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
          if (this$1.children[i$1] != other.children[i$1] || this$1.children[i$1 + 1] != other.children[i$1 + 1] || !this$1.children[i$1 + 2].eq(other.children[i$1 + 2])) {
            return false;
          }
        }
        return false;
      };

      DecorationSet.prototype.locals = function locals(node) {
        return removeOverlap(this.localsInner(node));
      };

      DecorationSet.prototype.localsInner = function localsInner(node) {
        var this$1 = this;

        if (this == empty) {
          return none;
        }
        if (node.inlineContent || !this.local.some(InlineType.is)) {
          return this.local;
        }
        var result = [];
        for (var i = 0; i < this.local.length; i++) {
          if (!(this$1.local[i].type instanceof InlineType)) {
            result.push(this$1.local[i]);
          }
        }
        return result;
      };

      var empty = new DecorationSet();

      // :: DecorationSet
      // The empty set of decorations.
      DecorationSet.empty = empty;

      DecorationSet.removeOverlap = removeOverlap;

      // :- An abstraction that allows the code dealing with decorations to
      // treat multiple DecorationSet objects as if it were a single object
      // with (a subset of) the same interface.
      var DecorationGroup = function DecorationGroup(members) {
        this.members = members;
      };

      DecorationGroup.prototype.forChild = function forChild(offset, child) {
        var this$1 = this;

        if (child.isLeaf) {
          return DecorationSet.empty;
        }
        var found = [];
        for (var i = 0; i < this.members.length; i++) {
          var result = this$1.members[i].forChild(offset, child);
          if (result == empty) {
            continue;
          }
          if (result instanceof DecorationGroup) {
            found = found.concat(result.members);
          } else {
            found.push(result);
          }
        }
        return DecorationGroup.from(found);
      };

      DecorationGroup.prototype.eq = function eq(other) {
        var this$1 = this;

        if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) {
          return false;
        }
        for (var i = 0; i < this.members.length; i++) {
          if (!this$1.members[i].eq(other.members[i])) {
            return false;
          }
        }
        return true;
      };

      DecorationGroup.prototype.locals = function locals(node) {
        var this$1 = this;

        var result,
            sorted = true;
        for (var i = 0; i < this.members.length; i++) {
          var locals = this$1.members[i].localsInner(node);
          if (!locals.length) {
            continue;
          }
          if (!result) {
            result = locals;
          } else {
            if (sorted) {
              result = result.slice();
              sorted = false;
            }
            for (var j = 0; j < locals.length; j++) {
              result.push(locals[j]);
            }
          }
        }
        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
      };

      // : ([DecorationSet]) → union<DecorationSet, DecorationGroup>
      // Create a group for the given array of decoration sets, or return
      // a single set when possible.
      DecorationGroup.from = function from(members) {
        switch (members.length) {
          case 0:
            return empty;
          case 1:
            return members[0];
          default:
            return new DecorationGroup(members);
        }
      };

      function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
        var children = oldChildren.slice();

        // Mark the children that are directly touched by changes, and
        // move those that are after the changes.
        var shift = function shift(oldStart, oldEnd, newStart, newEnd) {
          for (var i = 0; i < children.length; i += 3) {
            var end = children[i + 1],
                dSize = void 0;
            if (end == -1 || oldStart > end + oldOffset) {
              continue;
            }
            if (oldEnd >= children[i] + oldOffset) {
              children[i + 1] = -1;
            } else if (dSize = newEnd - newStart - (oldEnd - oldStart) + (oldOffset - offset)) {
              children[i] += dSize;
              children[i + 1] += dSize;
            }
          }
        };
        for (var i = 0; i < mapping.maps.length; i++) {
          mapping.maps[i].forEach(shift);
        }

        // Find the child nodes that still correspond to a single node,
        // recursively call mapInner on them and update their positions.
        var mustRebuild = false;
        for (var i$1 = 0; i$1 < children.length; i$1 += 3) {
          if (children[i$1 + 1] == -1) {
            // Touched nodes
            var from = mapping.map(children[i$1] + oldOffset),
                fromLocal = from - offset;
            if (fromLocal < 0 || fromLocal >= node.content.size) {
              mustRebuild = true;
              continue;
            }
            // Must read oldChildren because children was tagged with -1
            var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1),
                toLocal = to - offset;
            var ref = node.content.findIndex(fromLocal);
            var index = ref.index;
            var childOffset = ref.offset;
            var childNode = node.maybeChild(index);
            if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
              var mapped = children[i$1 + 2].mapInner(mapping, childNode, from + 1, children[i$1] + oldOffset + 1, options);
              if (mapped != empty) {
                children[i$1] = fromLocal;
                children[i$1 + 1] = toLocal;
                children[i$1 + 2] = mapped;
              } else {
                children[i$1 + 1] = -2;
                mustRebuild = true;
              }
            } else {
              mustRebuild = true;
            }
          }
        }

        // Remaining children must be collected and rebuilt into the appropriate structure
        if (mustRebuild) {
          var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping, offset, oldOffset, options);
          var built = buildTree(decorations, node, 0, options);
          newLocal = built.local;
          for (var i$2 = 0; i$2 < children.length; i$2 += 3) {
            if (children[i$2 + 1] < 0) {
              children.splice(i$2, 3);
              i$2 -= 3;
            }
          }
          for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
            var from$1 = built.children[i$3];
            while (j < children.length && children[j] < from$1) {
              j += 3;
            }
            children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
          }
        }

        return new DecorationSet(newLocal && newLocal.sort(byPos), children);
      }

      function moveSpans(spans, offset) {
        if (!offset || !spans.length) {
          return spans;
        }
        var result = [];
        for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          result.push(new Decoration(span.from + offset, span.to + offset, span.type));
        }
        return result;
      }

      function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
        // Gather all decorations from the remaining marked children
        function gather(set, oldOffset) {
          for (var i = 0; i < set.local.length; i++) {
            var mapped = set.local[i].map(mapping, offset, oldOffset);
            if (mapped) {
              decorations.push(mapped);
            } else if (options.onRemove) {
              options.onRemove(set.local[i].spec);
            }
          }
          for (var i$1 = 0; i$1 < set.children.length; i$1 += 3) {
            gather(set.children[i$1 + 2], set.children[i$1] + oldOffset + 1);
          }
        }
        for (var i = 0; i < children.length; i += 3) {
          if (children[i + 1] == -1) {
            gather(children[i + 2], oldChildren[i] + oldOffset + 1);
          }
        }

        return decorations;
      }

      function takeSpansForNode(spans, node, offset) {
        if (node.isLeaf) {
          return null;
        }
        var end = offset + node.nodeSize,
            found = null;
        for (var i = 0, span = void 0; i < spans.length; i++) {
          if ((span = spans[i]) && span.from > offset && span.to < end) {
            (found || (found = [])).push(span);
            spans[i] = null;
          }
        }
        return found;
      }

      function withoutNulls(array) {
        var result = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i] != null) {
            result.push(array[i]);
          }
        }
        return result;
      }

      // : ([Decoration], Node, number) → DecorationSet
      // Build up a tree that corresponds to a set of decorations. `offset`
      // is a base offset that should be subtractet from the `from` and `to`
      // positions in the spans (so that we don't have to allocate new spans
      // for recursive calls).
      function buildTree(spans, node, offset, options) {
        var children = [],
            hasNulls = false;
        node.forEach(function (childNode, localStart) {
          var found = takeSpansForNode(spans, childNode, localStart + offset);
          if (found) {
            hasNulls = true;
            var subtree = buildTree(found, childNode, offset + localStart + 1, options);
            if (subtree != empty) {
              children.push(localStart, localStart + childNode.nodeSize, subtree);
            }
          }
        });
        var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
        for (var i = 0; i < locals.length; i++) {
          if (!locals[i].type.valid(node, locals[i])) {
            if (options.onRemove) {
              options.onRemove(locals[i].spec);
            }
            locals.splice(i--, 1);
          }
        }
        return locals.length || children.length ? new DecorationSet(locals, children) : empty;
      }

      // : (Decoration, Decoration) → number
      // Used to sort decorations so that ones with a low start position
      // come first, and within a set with the same start position, those
      // with an smaller end position come first.
      function byPos(a, b) {
        return a.from - b.from || a.to - b.to;
      }

      // : ([Decoration]) → [Decoration]
      // Scan a sorted array of decorations for partially overlapping spans,
      // and split those so that only fully overlapping spans are left (to
      // make subsequent rendering easier). Will return the input array if
      // no partially overlapping spans are found (the common case).
      function removeOverlap(spans) {
        var working = spans;
        for (var i = 0; i < working.length - 1; i++) {
          var span = working[i];
          if (span.from != span.to) {
            for (var j = i + 1; j < working.length; j++) {
              var next = working[j];
              if (next.from == span.from) {
                if (next.to != span.to) {
                  if (working == spans) {
                    working = spans.slice();
                  }
                  // Followed by a partially overlapping larger span. Split that
                  // span.
                  working[j] = next.copy(next.from, span.to);
                  insertAhead(working, j + 1, next.copy(span.to, next.to));
                }
                continue;
              } else {
                if (next.from < span.to) {
                  if (working == spans) {
                    working = spans.slice();
                  }
                  // The end of this one overlaps with a subsequent span. Split
                  // this one.
                  working[i] = span.copy(span.from, next.from);
                  insertAhead(working, j, span.copy(next.from, span.to));
                }
                break;
              }
            }
          }
        }
        return working;
      }

      function insertAhead(array, i, deco) {
        while (i < array.length && byPos(deco, array[i]) > 0) {
          i++;
        }
        array.splice(i, 0, deco);
      }

      // : (EditorView) → union<DecorationSet, DecorationGroup>
      // Get the decorations associated with the current props of a view.
      function viewDecorations(view) {
        var found = [];
        view.someProp("decorations", function (f) {
          var result = f(view.state);
          if (result && result != empty) {
            found.push(result);
          }
        });
        if (view.cursorWrapper) {
          found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
        }
        return DecorationGroup.from(found);
      }

      // ::- An editor view manages the DOM structure that represents an
      // editable document. Its state and behavior are determined by its
      // [props](#view.DirectEditorProps).
      var EditorView = function EditorView(place, props) {
        this._props = props;
        // :: EditorState
        // The view's current [state](#state.EditorState).
        this.state = props.state;

        this.dispatch = this.dispatch.bind(this);

        this._root = null;
        this.focused = false;

        // :: dom.Element
        // An editable DOM node containing the document. (You probably
        // should not directly interfere with its content.)
        this.dom = place && place.mount || document.createElement("div");
        if (place) {
          if (place.appendChild) {
            place.appendChild(this.dom);
          } else if (place.apply) {
            place(this.dom);
          } else if (place.mount) {
            this.mounted = true;
          }
        }

        this.editable = getEditable(this);
        this.cursorWrapper = null;
        updateCursorWrapper(this);
        this.nodeViews = buildNodeViews(this);
        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);

        this.lastSelectedViewDesc = null;
        // :: ?{slice: Slice, move: bool}
        // When editor content is being dragged, this object contains
        // information about the dragged slice and whether it is being
        // copied or moved. At any other time, it is null.
        this.dragging = null;
        initInput(this); // Must be done before creating a SelectionReader

        this.selectionReader = new SelectionReader(this);

        this.pluginViews = [];
        this.updatePluginViews();
      };

      var prototypeAccessors = { props: {}, root: {} };

      // :: DirectEditorProps
      // The view's current [props](#view.EditorProps).
      prototypeAccessors.props.get = function () {
        var this$1 = this;

        if (this._props.state != this.state) {
          var prev = this._props;
          this._props = {};
          for (var name in prev) {
            this$1._props[name] = prev[name];
          }
          this._props.state = this.state;
        }
        return this._props;
      };

      // :: (DirectEditorProps)
      // Update the view's props. Will immediately cause an update to
      // the DOM.
      EditorView.prototype.update = function update(props) {
        if (props.handleDOMEvents != this._props.handleDOMEvents) {
          ensureListeners(this);
        }
        this._props = props;
        this.updateStateInner(props.state, true);
      };

      // :: (DirectEditorProps)
      // Update the view by updating existing props object with the object
      // given as argument. Equivalent to `view.update(Object.assign({},
      // view.props, props))`.
      EditorView.prototype.setProps = function setProps(props) {
        var this$1 = this;

        var updated = {};
        for (var name in this$1._props) {
          updated[name] = this$1._props[name];
        }
        updated.state = this.state;
        for (var name$1 in props) {
          updated[name$1] = props[name$1];
        }
        this.update(updated);
      };

      // :: (EditorState)
      // Update the editor's `state` prop, without touching any of the
      // other props.
      EditorView.prototype.updateState = function updateState(state) {
        this.updateStateInner(state, this.state.plugins != state.plugins);
      };

      EditorView.prototype.updateStateInner = function updateStateInner(state, reconfigured) {
        var this$1 = this;

        var prev = this.state,
            redraw = false;
        this.state = state;
        if (reconfigured) {
          var nodeViews = buildNodeViews(this);
          if (changedNodeViews(nodeViews, this.nodeViews)) {
            this.nodeViews = nodeViews;
            redraw = true;
          }
          ensureListeners(this);
        }

        this.domObserver.flush();
        if (this.inDOMChange && this.inDOMChange.stateUpdated(state)) {
          return;
        }

        var prevEditable = this.editable;
        this.editable = getEditable(this);
        updateCursorWrapper(this);
        var innerDeco = viewDecorations(this),
            outerDeco = computeDocDeco(this);

        var scroll = reconfigured ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
        var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
        var updateSel = updateDoc || !state.selection.eq(prev.selection) || this.selectionReader.domChanged();
        var oldScrollPos = scroll == "preserve" && updateSel && storeScrollPos(this);

        if (updateSel) {
          this.domObserver.stop();
          var forceSelUpdate = false;
          if (updateDoc) {
            // Work around an issue in Chrome where changing the DOM
            // around the active selection puts it into a broken state
            // where the thing the user sees differs from the selection
            // reported by the Selection object (#710)
            var startSelContext = result.chrome && selectionContext(this.root);
            if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
              this.docView.destroy();
              this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
            }
            this.selectionReader.clearDOMState();
            if (startSelContext) {
              forceSelUpdate = needChromeSelectionForce(startSelContext, this.root);
            }
          }
          // Work around for an issue where an update arriving right between
          // a DOM selection change and the "selectionchange" event for it
          // can cause a spurious DOM selection update, disrupting mouse
          // drag selection.
          if (forceSelUpdate || !(this.mouseDown && this.selectionReader.domChanged() && anchorInRightPlace(this))) {
            selectionToDOM(this, false, forceSelUpdate);
          } else {
            syncNodeSelection(this, state.selection);
            this.selectionReader.storeDOMState(state.selection);
          }
          this.domObserver.start();
        }

        if (prevEditable != this.editable) {
          this.selectionReader.editableChanged();
        }
        this.updatePluginViews(reconfigured ? null : prev);

        if (scroll == "reset") {
          this.dom.scrollTop = 0;
        } else if (scroll == "to selection") {
          var startDOM = this.root.getSelection().focusNode;
          if (this.someProp("handleScrollToSelection", function (f) {
            return f(this$1);
          })) {} // Handled
          else if (state.selection instanceof dist$2.NodeSelection) {
              scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM);
            } else {
              scrollRectIntoView(this, this.coordsAtPos(state.selection.head), startDOM);
            }
        } else if (oldScrollPos) {
          resetScrollPos(oldScrollPos);
        }
      };

      EditorView.prototype.destroyPluginViews = function destroyPluginViews() {
        var view;
        while (view = this.pluginViews.pop()) {
          if (view.destroy) {
            view.destroy();
          }
        }
      };

      EditorView.prototype.updatePluginViews = function updatePluginViews(prevState) {
        var this$1 = this;

        if (!prevState) {
          this.destroyPluginViews();
          for (var i = 0; i < this.state.plugins.length; i++) {
            var plugin = this$1.state.plugins[i];
            if (plugin.spec.view) {
              this$1.pluginViews.push(plugin.spec.view(this$1));
            }
          }
        } else {
          for (var i$1 = 0; i$1 < this.pluginViews.length; i$1++) {
            var pluginView = this$1.pluginViews[i$1];
            if (pluginView.update) {
              pluginView.update(this$1, prevState);
            }
          }
        }
      };

      // :: (string, ?(prop: *) → *) → *
      // Goes over the values of a prop, first those provided directly,
      // then those from plugins (in order), and calls `f` every time a
      // non-undefined value is found. When `f` returns a truthy value,
      // that is immediately returned. When `f` isn't provided, it is
      // treated as the identity function (the prop value is returned
      // directly).
      EditorView.prototype.someProp = function someProp(propName, f) {
        var prop = this._props && this._props[propName],
            value;
        if (prop != null && (value = f ? f(prop) : prop)) {
          return value;
        }
        var plugins = this.state.plugins;
        if (plugins) {
          for (var i = 0; i < plugins.length; i++) {
            var prop$1 = plugins[i].props[propName];
            if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) {
              return value;
            }
          }
        }
      };

      // :: () → bool
      // Query whether the view has focus.
      EditorView.prototype.hasFocus = function hasFocus() {
        return this.root.activeElement == this.dom;
      };

      // :: ()
      // Focus the editor.
      EditorView.prototype.focus = function focus() {
        this.domObserver.stop();
        selectionToDOM(this, true);
        this.domObserver.start();
        if (this.editable) {
          this.dom.focus();
        }
      };

      // :: union<dom.Document, dom.DocumentFragment>
      // Get the document root in which the editor exists. This will
      // usually be the top-level `document`, but might be a [shadow
      // DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
      // root if the editor is inside one.
      prototypeAccessors.root.get = function () {
        var this$1 = this;

        var cached = this._root;
        if (cached == null) {
          for (var search = this.dom.parentNode; search; search = search.parentNode) {
            if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
              return this$1._root = search;
            }
          }
        }
        return cached || document;
      };

      // :: ({left: number, top: number}) → ?{pos: number, inside: number}
      // Given a pair of viewport coordinates, return the document
      // position that corresponds to them. May return null if the given
      // coordinates aren't inside of the editor. When an object is
      // returned, its `pos` property is the position nearest to the
      // coordinates, and its `inside` property holds the position of the
      // inner node that the position falls inside of, or -1 if it is at
      // the top level, not in any node.
      EditorView.prototype.posAtCoords = function posAtCoords$1(coords) {
        var pos = posAtCoords(this, coords);
        if (this.inDOMChange && pos) {
          pos.pos = this.inDOMChange.mapping.map(pos.pos);
          if (pos.inside != -1) {
            pos.inside = this.inDOMChange.mapping.map(pos.inside);
          }
        }
        return pos;
      };

      // :: (number) → {left: number, right: number, top: number, bottom: number}
      // Returns the viewport rectangle at a given document position. `left`
      // and `right` will be the same number, as this returns a flat
      // cursor-ish rectangle.
      EditorView.prototype.coordsAtPos = function coordsAtPos$1(pos) {
        if (this.inDOMChange) {
          pos = this.inDOMChange.mapping.invert().map(pos);
        }
        return coordsAtPos(this, pos);
      };

      // :: (number) → {node: dom.Node, offset: number}
      // Find the DOM position that corresponds to the given document
      // position. Note that you should **not** mutate the editor's
      // internal DOM, only inspect it (and even that is usually not
      // necessary).
      EditorView.prototype.domAtPos = function domAtPos(pos) {
        if (this.inDOMChange) {
          pos = this.inDOMChange.mapping.invert().map(pos);
        }
        return this.docView.domFromPos(pos);
      };

      // :: (number) → ?dom.Node
      // Find the DOM node that represents the document node after the
      // given position. May return `null` when the position doesn't point
      // in front of a node or if the node is inside an opaque node view.
      //
      // This is intended to be able to call things like
      // `getBoundingClientRect` on that DOM node. Do **not** mutate the
      // editor DOM directly, or add styling this way, since that will be
      // immediately overriden by the editor as it redraws the node.
      EditorView.prototype.nodeDOM = function nodeDOM(pos) {
        if (this.inDOMChange) {
          pos = this.inDOMChange.mapping.invert().map(pos);
        }
        var desc = this.docView.descAt(pos);
        return desc ? desc.nodeDOM : null;
      };

      // :: (dom.Node, number, ?number) → number
      // Find the document position that corresponds to a given DOM
      // position. (Whenever possible, it is preferable to inspect the
      // document structure directly, rather than poking around in the
      // DOM, but sometimes—for example when interpreting an event
      // target—you don't have a choice.)
      //
      // The `bias` parameter can be used to influence which side of a DOM
      // node to use when the position is inside a leaf node.
      EditorView.prototype.posAtDOM = function posAtDOM(node, offset, bias) {
        if (bias === void 0) bias = -1;

        var pos = this.docView.posFromDOM(node, offset, bias);
        if (pos == null) {
          throw new RangeError("DOM position not inside the editor");
        }
        if (this.inDOMChange) {
          pos = this.inDOMChange.mapping.map(pos);
        }
        return pos;
      };

      // :: (union<"up", "down", "left", "right", "forward", "backward">, ?EditorState) → bool
      // Find out whether the selection is at the end of a textblock when
      // moving in a given direction. When, for example, given `"left"`,
      // it will return true if moving left from the current cursor
      // position would leave that position's parent textblock. Will apply
      // to the view's current state by default, but it is possible to
      // pass a different state.
      EditorView.prototype.endOfTextblock = function endOfTextblock$1(dir, state) {
        return endOfTextblock(this, state || this.state, dir);
      };

      // :: ()
      // Removes the editor from the DOM and destroys all [node
      // views](#view.NodeView).
      EditorView.prototype.destroy = function destroy() {
        if (!this.docView) {
          return;
        }
        destroyInput(this);
        this.destroyPluginViews();
        this.selectionReader.destroy();
        if (this.mounted) {
          this.docView.update(this.state.doc, [], viewDecorations(this), this);
          this.dom.textContent = "";
        } else if (this.dom.parentNode) {
          this.dom.parentNode.removeChild(this.dom);
        }
        this.docView.destroy();
        this.docView = null;
      };

      // Used for testing.
      EditorView.prototype.dispatchEvent = function dispatchEvent$1(event) {
        return dispatchEvent(this, event);
      };

      // :: (Transaction)
      // Dispatch a transaction. Will call
      // [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)
      // when given, and otherwise defaults to applying the transaction to
      // the current state and calling
      // [`updateState`](#view.EditorView.updateState) with the result.
      // This method is bound to the view instance, so that it can be
      // easily passed around.
      EditorView.prototype.dispatch = function dispatch(tr) {
        var dispatchTransaction = this._props.dispatchTransaction;
        if (dispatchTransaction) {
          dispatchTransaction.call(this, tr);
        } else {
          this.updateState(this.state.apply(tr));
        }
      };

      Object.defineProperties(EditorView.prototype, prototypeAccessors);

      function computeDocDeco(view) {
        var attrs = Object.create(null);
        attrs.class = "ProseMirror";
        attrs.contenteditable = String(view.editable);

        view.someProp("attributes", function (value) {
          if (typeof value == "function") {
            value = value(view.state);
          }
          if (value) {
            for (var attr in value) {
              if (attr == "class") {
                attrs.class += " " + value[attr];
              } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
                attrs[attr] = String(value[attr]);
              }
            }
          }
        });

        return [Decoration.node(0, view.state.doc.content.size, attrs)];
      }

      function cursorWrapperDOM(visible) {
        var span = document.createElement("span");
        span.textContent = "\ufeff"; // zero-width non-breaking space
        if (!visible) {
          span.style.position = "absolute";
          span.style.left = "-100000px";
        }
        return span;
      }

      function updateCursorWrapper(view) {
        var $pos = needsCursorWrapper(view.state);
        // On IE/Edge, moving the DOM selection will abort a mouse drag, so
        // there we delay the creation of the wrapper when the mouse is down.
        if ($pos && !(result.ie && view.mouseDown)) {
          var visible = view.state.selection.visible;
          // Needs a cursor wrapper
          var marks = view.state.storedMarks || $pos.marks(),
              dom;
          if (!view.cursorWrapper || !dist.Mark.sameSet(view.cursorWrapper.deco.spec.marks, marks) || view.cursorWrapper.dom.textContent != "\ufeff" || view.cursorWrapper.deco.spec.visible != visible) {
            dom = cursorWrapperDOM(visible);
          } else if (view.cursorWrapper.deco.pos != $pos.pos) {
            dom = view.cursorWrapper.dom;
          }
          if (dom) {
            view.cursorWrapper = { dom: dom, deco: Decoration.widget($pos.pos, dom, { isCursorWrapper: true, marks: marks, raw: true, visible: visible }) };
          }
        } else {
          view.cursorWrapper = null;
        }
      }

      function getEditable(view) {
        return !view.someProp("editable", function (value) {
          return value(view.state) === false;
        });
      }

      function selectionContext(root) {
        var ref = root.getSelection();
        var offset = ref.focusOffset;
        var node = ref.focusNode;
        if (!node || node.nodeType == 3) {
          return null;
        }
        return [node, offset, node.nodeType == 1 ? node.childNodes[offset - 1] : null, node.nodeType == 1 ? node.childNodes[offset] : null];
      }

      function needChromeSelectionForce(context, root) {
        var newContext = selectionContext(root);
        if (!newContext || newContext[0].nodeType == 3) {
          return false;
        }
        for (var i = 0; i < context.length; i++) {
          if (newContext[i] != context[i]) {
            return true;
          }
        }
        return false;
      }

      function buildNodeViews(view) {
        var result$$1 = {};
        view.someProp("nodeViews", function (obj) {
          for (var prop in obj) {
            if (!Object.prototype.hasOwnProperty.call(result$$1, prop)) {
              result$$1[prop] = obj[prop];
            }
          }
        });
        return result$$1;
      }

      function changedNodeViews(a, b) {
        var nA = 0,
            nB = 0;
        for (var prop in a) {
          if (a[prop] != b[prop]) {
            return true;
          }
          nA++;
        }
        for (var _ in b) {
          nB++;
        }
        return nA != nB;
      }

      // EditorProps:: interface
      //
      // Props are configuration values that can be passed to an editor view
      // or included in a plugin. This interface lists the supported props.
      //
      // The various event-handling functions may all return `true` to
      // indicate that they handled the given event. The view will then take
      // care to call `preventDefault` on the event, except with
      // `handleDOMEvents`, where the handler itself is responsible for that.
      //
      // How a prop is resolved depends on the prop. Handler functions are
      // called one at a time, starting with the base props and then
      // searching through the plugins (in order of appearance) until one of
      // them returns true. For some props, the first plugin that yields a
      // value gets precedence.
      //
      //   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>
      //   Can be an object mapping DOM event type names to functions that
      //   handle them. Such functions will be called before any handling
      //   ProseMirror does of events fired on the editable DOM element.
      //   Contrary to the other event handling props, when returning true
      //   from such a function, you are responsible for calling
      //   `preventDefault` yourself (or not, if you want to allow the
      //   default behavior).
      //
      //   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool
      //   Called when the editor receives a `keydown` event.
      //
      //   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool
      //   Handler for `keypress` events.
      //
      //   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool
      //   Whenever the user directly input text, this handler is called
      //   before the input is applied. If it returns `true`, the default
      //   behavior of actually inserting the text is suppressed.
      //
      //   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
      //   Called for each node around a click, from the inside out. The
      //   `direct` flag will be true for the inner node.
      //
      //   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
      //   Called when the editor is clicked, after `handleClickOn` handlers
      //   have been called.
      //
      //   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
      //   Called for each node around a double click.
      //
      //   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
      //   Called when the editor is double-clicked, after `handleDoubleClickOn`.
      //
      //   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
      //   Called for each node around a triple click.
      //
      //   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
      //   Called when the editor is triple-clicked, after `handleTripleClickOn`.
      //
      //   handlePaste:: ?(view: EditorView, event: dom.Event, slice: Slice) → bool
      //   Can be used to override the behavior of pasting. `slice` is the
      //   pasted content parsed by the editor, but you can directly access
      //   the event to get at the raw content.
      //
      //   handleDrop:: ?(view: EditorView, event: dom.Event, slice: Slice, moved: bool) → bool
      //   Called when something is dropped on the editor. `moved` will be
      //   true if this drop moves from the current selection (which should
      //   thus be deleted).
      //
      //   handleScrollToSelection:: ?(view: EditorView) → bool
      //   Called when the view, after updating its state, tries to scroll
      //   the selection into view. A handler function may return false to
      //   indicate that it did not handle the scrolling and further
      //   handlers or the default behavior should be tried.
      //
      //   createSelectionBetween:: ?(view: EditorView, anchor: ResolvedPos, head: ResolvedPos) → ?Selection
      //   Can be used to override the way a selection is created when
      //   reading a DOM selection between the given anchor and head.
      //
      //   domParser:: ?DOMParser
      //   The [parser](#model.DOMParser) to use when reading editor changes
      //   from the DOM. Defaults to calling
      //   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the
      //   editor's schema.
      //
      //   transformPastedHTML:: ?(html: string) → string
      //   Can be used to transform pasted HTML text, _before_ it is parsed,
      //   for example to clean it up.
      //
      //   clipboardParser:: ?DOMParser
      //   The [parser](#model.DOMParser) to use when reading content from
      //   the clipboard. When not given, the value of the
      //   [`domParser`](#view.EditorProps.domParser) prop is used.
      //
      //   transformPastedText:: ?(text: string) → string
      //   Transform pasted plain text.
      //
      //   clipboardTextParser:: ?(text: string, $context: ResolvedPos) → Slice
      //   A function to parse text from the clipboard into a document
      //   slice. Called after
      //   [`transformPastedText`](#view.EditorProps.transformPastedText).
      //   The default behavior is to split the text into lines, wrap them
      //   in `<p>` tags, and call
      //   [`clipboardParser`](#view.EditorProps.clipboardParser) on it.
      //
      //   transformPasted:: ?(Slice) → Slice
      //   Can be used to transform pasted content before it is applied to
      //   the document.
      //
      //   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration]) → NodeView>
      //   Allows you to pass custom rendering and behavior logic for nodes
      //   and marks. Should map node and mark names to constructor
      //   functions that produce a [`NodeView`](#view.NodeView) object
      //   implementing the node's display behavior. For nodes, the third
      //   argument `getPos` is a function that can be called to get the
      //   node's current position, which can be useful when creating
      //   transactions to update it. For marks, the third argument is a
      //   boolean that indicates whether the mark's content is inline.
      //
      //   `decorations` is an array of node or inline decorations that are
      //   active around the node. They are automatically drawn in the
      //   normal way, and you will usually just want to ignore this, but
      //   they can also be used as a way to provide context information to
      //   the node view without adding it to the document itself.
      //
      //   clipboardSerializer:: ?DOMSerializer
      //   The DOM serializer to use when putting content onto the
      //   clipboard. If not given, the result of
      //   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)
      //   will be used.
      //
      //   clipboardTextSerializer:: ?(Slice) → string
      //   A function that will be called to get the text for the current
      //   selection when copying text to the clipboard. By default, the
      //   editor will use [`textBetween`](#model.Node.textBetween) on the
      //   selected range.
      //
      //   decorations:: ?(state: EditorState) → ?DecorationSet
      //   A set of [document decorations](#view.Decoration) to show in the
      //   view.
      //
      //   editable:: ?(state: EditorState) → bool
      //   When this returns false, the content of the view is not directly
      //   editable.
      //
      //   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>
      //   Control the DOM attributes of the editable element. May be either
      //   an object or a function going from an editor state to an object.
      //   By default, the element will get a class `"ProseMirror"`, and
      //   will have its `contentEditable` attribute determined by the
      //   [`editable` prop](#view.EditorProps.editable). Additional classes
      //   provided here will be added to the class. For other attributes,
      //   the value provided first (as in
      //   [`someProp`](#view.EditorView.someProp)) will be used.
      //
      //   scrollThreshold:: ?union<number, {top: number, right: number, bottom: number, left: number}>
      //   Determines the distance (in pixels) between the cursor and the
      //   end of the visible viewport at which point, when scrolling the
      //   cursor into view, scrolling takes place. Defaults to 0.
      //
      //   scrollMargin:: ?union<number, {top: number, right: number, bottom: number, left: number}>
      //   Determines the extra space (in pixels) that is left above or
      //   below the cursor when it is scrolled into view. Defaults to 5.

      // DirectEditorProps:: interface extends EditorProps
      //
      // The props object given directly to the editor view supports two
      // fields that can't be used in plugins:
      //
      //   state:: EditorState
      //   The current state of the editor.
      //
      //   dispatchTransaction:: ?(tr: Transaction)
      //   The callback over which to send transactions (state updates)
      //   produced by the view. If you specify this, you probably want to
      //   make sure this ends up calling the view's
      //   [`updateState`](#view.EditorView.updateState) method with a new
      //   state that has the transaction
      //   [applied](#state.EditorState.apply). The callback will be bound to have
      //   the view instance as its `this` binding.

      exports.EditorView = EditorView;
      exports.Decoration = Decoration;
      exports.DecorationSet = DecorationSet;
      exports.__serializeForClipboard = serializeForClipboard;
      exports.__parseFromClipboard = parseFromClipboard;
      
    });

    unwrapExports(dist$4);
    var dist_1$3 = dist$4.EditorView;
    var dist_2$3 = dist$4.Decoration;
    var dist_3$3 = dist$4.DecorationSet;
    var dist_4$3 = dist$4.__serializeForClipboard;
    var dist_5$3 = dist$4.__parseFromClipboard;

    class SetDocAttr extends dist_3$1 {
        constructor(key, value, stepType = 'SetDocAttr') {
            super();
            this.stepType = stepType;
            this.key = key;
            this.value = value;
        }
        apply(doc) {
            this.prevValue = doc.attrs[this.key];
            doc.attrs[this.key] = this.value;
            return dist_4$1.ok(doc);
        }
        invert() {
            return new SetDocAttr(this.key, this.prevValue, 'revertSetDocAttr');
        }
        map() {
            return null;
        }
        toJSON() {
            return {
                stepType: this.stepType,
                key: this.key,
                value: this.value
            };
        }
        static fromJSON(json) {
            return new SetDocAttr(json.key, json.value, json.stepType);
        }
    }

    var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    /**
     * Adds an item into an array, treating the array as a set. If the item to add is already contained in the array,
     * then nothing is changed.
     */
    function addToSet(set, item) {
        let found = false;
        set.forEach(existing => {
            if (existing === item) {
                found = true;
            }
        });
        if (!found) {
            set.push(item);
        }
    }
    /**
     * Returns a list of active mark names
     */
    function getMarks(state) {
        let selection = state.selection;
        let marks = [];
        if (selection.from === selection.to) {
            // Get marks at the current cursor position
            if (state.doc.nodeAt(selection.from)) {
                state.doc.nodeAt(selection.from).marks.forEach(mark => {
                    addToSet(marks, mark);
                });
            }
            // Add marks from the previous cursor position if they are inclusive
            if (state.doc.nodeAt(selection.from - 1)) {
                state.doc.nodeAt(selection.from - 1).marks.forEach(mark => {
                    if (mark.type.spec.inclusive || mark.type.spec.inclusive === undefined) {
                        addToSet(marks, mark);
                    }
                });
            }
            // Add stored marks
            if (state.storedMarks) {
                state.storedMarks.forEach(mark => {
                    addToSet(marks, mark);
                });
            }
        } else {
            // Add all marks between the selection markers
            state.doc.nodesBetween(selection.from, selection.to, node => {
                node.marks.forEach(mark => {
                    addToSet(marks, mark);
                });
            });
        }
        return marks;
    }
    /**
     * Gets a list of nodes from the current selection.
     */
    function getBlockHierarchy(state) {
        let selection = state.selection;
        let blocks = [];
        for (let idx = 0; idx < selection.$from.path.length; idx++) {
            if (typeof selection.$from.path[idx] === 'object') {
                blocks.push(selection.$from.path[idx]);
            }
        }
        return blocks;
    }
    class ProsemirrorEditor extends Component {
        constructor() {
            super(...arguments);
            this._guid = null;
            this.sourceText = null;
            this.editorView = null;
            this.status = null;
            this.schema = null;
        }
        // Life-cycle handlers
        /**
         * Upon insertion of the component, initialise the Prosemirror instance.
         */
        didInsertElement() {
            this.makeSchema();
            this.sourceText = this.args.text;
            let state = dist_7$2.create({
                schema: this.schema,
                doc: this.sourceText ? this.schema.nodeFromJSON(this.sourceText) : null,
                plugins: [history_4(), keymap_2({
                    'Mod-z': history_5,
                    'Mod-y': history_6
                }), keymap_2(commands_24)]
            });
            let component = this;
            component.editorView = new dist_1$3(document.querySelector('#' + this.prosemirrorId), {
                state,
                dispatchTransaction(transaction) {
                    let newState = component.editorView.state.apply(transaction);
                    component.stateChange(newState);
                    component.editorView.updateState(newState);
                }
            });
        }
        /**
         * Upon updating of the text in the arguments, load the text into the editor.
         */
        didUpdate() {
            if (this.args.text && this.args.text !== this.sourceText) {
                this.sourceText = this.args.text;
                let state = dist_7$2.create({
                    schema: this.schema,
                    doc: this.schema.nodeFromJSON(this.sourceText),
                    plugins: [history_4(), keymap_2({
                        'Mod-z': history_5,
                        'Mod-y': history_6
                    }), keymap_2(commands_24)]
                });
                this.editorView.updateState(state);
            }
        }
        // Computed properties
        /**
         * Generate a unique identifier for the editor.
         */
        get prosemirrorId() {
            return 'tei-editor-prosemirror-' + ensureGuid$3(this);
        }
        // Action handleres
        /**
         * Called when the editor state changes and updates the current blocks and marks.
         */
        stateChange(state) {
            let status = {
                block: null,
                blocks: null,
                marks: {}
            };
            // Determine most specific active block
            let blocks = getBlockHierarchy(state);
            blocks.forEach(node => {
                if (!node.type.isText) {
                    if (status.blocks === null) {
                        status.blocks = {};
                    }
                    status.blocks[node.type.name] = node;
                    status.block = node;
                }
            });
            // Determine all marks
            let marks = getMarks(state);
            marks.forEach(mark => {
                status.marks[mark.type.name] = mark;
            });
            this.status = status;
            if (this.args.update) {
                this.sourceText = state.doc.toJSON();
                this.args.update(this.sourceText);
            }
        }
        /**
         * Handles the actions generated by the right-hand editing sidebar.
         */
        menuAction(action, attribute, value, ev) {
            this.editorView.focus();
            if (value === 'ev.target.value') {
                value = ev.target.value;
            }
            if (action === 'setDocAttribute') {
                let transaction = this.editorView.state.tr;
                transaction.step(new SetDocAttr(attribute, value));
                this.editorView.dispatch(transaction);
            } else if (action === 'setBlockType') {
                if (this.schema.nodes[value].isBlock) {
                    if (attribute.wrapping) {
                        let range = this.editorView.state.selection.$from.blockRange(this.editorView.state.selection.$to);
                        if (this.status.blocks[value]) {
                            this.editorView.dispatch(this.editorView.state.tr.lift(range, dist_10$1(range)));
                        } else {
                            let wrapping = dist_11$1(range, this.schema.nodes[value]);
                            if (wrapping) {
                                this.editorView.dispatch(this.editorView.state.tr.wrap(range, wrapping));
                            }
                        }
                    } else {
                        commands_18(this.schema.nodes[value], {})(this.editorView.state, this.editorView.dispatch);
                    }
                } else {
                    let type = this.schema.nodes[value];
                    var _editorView$state$sel = this.editorView.state.selection;
                    let $from = _editorView$state$sel.$from,
                        $to = _editorView$state$sel.$to;

                    if (this.status.blocks[value]) {
                        let slice = $from.parent.slice($from.parentOffset, $to.parentOffset);
                        this.editorView.dispatch(this.editorView.state.tr.replaceRange($from.pos - 1, $to.pos + 1, slice));
                    } else {
                        if ($from.parent.canReplaceWith($from.index(), $to.index(), type)) {
                            let slice = $from.parent.slice($from.parentOffset, $to.parentOffset);
                            this.editorView.dispatch(this.editorView.state.tr.replaceSelectionWith(type.create({}, slice.content)));
                        }
                    }
                }
            } else if (action === 'setBlockAttribute') {
                let $from = this.editorView.state.selection.$from;

                let transaction = this.editorView.state.tr;
                for (let depth = $from.depth; depth >= 0; depth--) {
                    let node = $from.node(depth);
                    if (node.type.attrs[attribute] !== undefined) {
                        let attrs = Object.assign({}, node.attrs);
                        attrs[attribute] = value;
                        transaction.setNodeMarkup($from.start(depth) - 1, null, attrs);
                    }
                }
                this.editorView.dispatch(transaction);
            } else if (action === 'toggleBlockAttribute') {
                let $from = this.editorView.state.selection.$from;

                let transaction = this.editorView.state.tr;
                for (let depth = $from.depth; depth >= 0; depth--) {
                    let node = $from.node(depth);
                    if (node.type.attrs[attribute] !== undefined) {
                        let attrs = Object.assign({}, node.attrs);
                        attrs[attribute] = !attrs[attribute];
                        transaction.setNodeMarkup($from.start(depth) - 1, null, attrs);
                    }
                }
                this.editorView.dispatch(transaction);
            } else if (action === 'setMarkAttribute') {
                attribute = attribute.split('.');
                let marks = getMarks(this.editorView.state);
                var _editorView$state$sel2 = this.editorView.state.selection;
                let $from = _editorView$state$sel2.$from,
                    $to = _editorView$state$sel2.$to;

                let transaction = this.editorView.state.tr;
                transaction.removeMark($from.pos, $to.pos, this.schema.marks[attribute[0]]);
                if (value && value.trim() !== '') {
                    let attrs = {};
                    attrs[attribute[1]] = value;
                    transaction.addMark($from.pos, $to.pos, this.schema.marks[attribute[0]].create(attrs));
                }
                this.editorView.dispatch(transaction);
            } else if (action === 'toggleMark') {
                commands_19(this.schema.marks[attribute])(this.editorView.state, this.editorView.dispatch);
            }
        }
        // Helper functionality
        makeSchema() {
            // Convert node attributes to DOM attributes
            function attrsNodeToDom(key, node) {
                let attrs = { class: 'tei-editor-' + key };
                if (node.attrs) {
                    Object.entries(node.attrs).forEach(entry => {
                        attrs['data-' + entry[0]] = entry[1];
                    });
                }
                return attrs;
            }
            // Convert DOM attributes to node attributes
            function attrsDomToNode(dom) {
                console.log(dom);
            }
            let schema = deepclone([this.args.schema]);
            Object.entries(schema.nodes).forEach(entry => {
                let key = entry[0];
                let node = entry[1];
                if (key !== 'doc' && key !== 'text') {
                    if (node.inline) {
                        node.toDOM = function (node) {
                            return ['span', attrsNodeToDom(key, node), 0];
                        };
                        node.parseDOM = [{ tag: 'span.tei-editor-' + key, getAttrs: attrsDomToNode }];
                    } else {
                        node.toDOM = function (node) {
                            return ['div', attrsNodeToDom(key, node), 0];
                        };
                        node.parseDOM = [{ tag: 'div.tei-editor-' + key, getAttrs: attrsDomToNode }];
                    }
                }
            });
            Object.entries(schema.marks).forEach(entry => {
                let key = entry[0];
                let mark = entry[1];
                mark.toDOM = function (node) {
                    return ['span', attrsNodeToDom(key, node), 0];
                };
                mark.parseDOM = [{ tag: 'span.tei-editor-' + key, getAttrs: attrsDomToNode }];
            });
            this.schema = new dist_8(schema);
        }
    }
    __decorate$3([tracked], ProsemirrorEditor.prototype, "status", void 0);

    var __ui_components_ProsemirrorEditor_template__ = { "id": "9l/Ix9os", "block": "{\"symbols\":[\"section\",\"entry\",\"value\",\"value\",\"value\",\"entry\",\"@multiTexts\",\"@ui\"],\"statements\":[[0,\"  \"],[6,\"div\"],[10,\"class\",\"tei-editor-prosemirror-editor\"],[8],[0,\"\\n    \"],[6,\"div\"],[11,\"id\",[20,\"prosemirrorId\"],null],[8],[9],[0,\"\\n  \"],[9],[0,\"\\n  \"],[6,\"div\"],[10,\"class\",\"tei-editor-prosemirror-sidebar\"],[8],[0,\"\\n    \"],[6,\"dl\"],[8],[0,\"\\n\"],[4,\"each\",[[21,8,[]]],[[\"key\"],[\"@index\"]],{\"statements\":[[4,\"if\",[[26,\"status-display-entry\",[[22,[\"status\"]],[21,1,[\"context\"]]],null]],null,{\"statements\":[[0,\"          \"],[6,\"dt\"],[8],[1,[21,1,[\"title\"]],false],[9],[0,\"\\n          \"],[6,\"dd\"],[8],[0,\"\\n\"],[4,\"if\",[[26,\"eq\",[[21,1,[\"type\"]],\"block-type\"],null]],null,{\"statements\":[[0,\"              \"],[5,\"AriaMenu\",[],[[\"@label\"],[[21,1,[\"title\"]]]],{\"statements\":[[0,\"\\n\"],[4,\"each\",[[21,1,[\"blocks\"]]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"                  \"],[5,\"AriaMenuAction\",[],[[\"@tabindex\",\"@label\",\"@current\",\"@action\"],[[26,\"aria-menu-item-tabindex\",[[22,[\"index\"]]],null],[21,6,[\"label\"]],[26,\"boolean-str\",[[26,\"get\",[[22,[\"status\",\"blocks\"]],[21,6,[\"type\"]]],null]],null],[26,\"action\",[[22,[\"menuAction\"]],\"setBlockType\",[21,6,[]],[21,6,[\"type\"]]],null]]],{\"statements\":[[1,[21,6,[\"label\"]],false]],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[6]},null],[0,\"              \"]],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[21,1,[\"type\"]],\"toolbar\"],null]],null,{\"statements\":[[0,\"              \"],[5,\"AriaMenu\",[],[[\"@label\",\"@class\"],[[21,1,[\"title\"]],[21,1,[\"class\"]]]],{\"statements\":[[0,\"\\n\"],[4,\"each\",[[21,1,[\"entries\"]]],[[\"key\"],[\"@index\"]],{\"statements\":[[4,\"if\",[[26,\"eq\",[[21,2,[\"type\"]],\"separator\"],null]],null,{\"statements\":[[0,\"                    \"],[6,\"li\"],[10,\"role\",\"separator\"],[8],[9],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[21,2,[\"type\"]],\"select-attr\"],null]],null,{\"statements\":[[0,\"                    \"],[6,\"li\"],[10,\"class\",\"input\"],[10,\"role\",\"presentation\"],[8],[0,\"\\n                      \"],[6,\"select\"],[10,\"role\",\"menuitem\"],[11,\"tabindex\",[26,\"aria-menu-item-tabindex\",[[22,[\"index\"]]],null],null],[11,\"onchange\",[26,\"action\",[[22,[\"menuAction\"]],\"setBlockAttribute\",[21,2,[\"attr\"]],\"ev.target.value\"],null],null],[8],[0,\"\\n\"],[4,\"each\",[[21,2,[\"values\"]]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"                          \"],[6,\"option\"],[11,\"value\",[21,5,[\"key\"]],null],[11,\"selected\",[26,\"eq\",[[26,\"get\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],[21,1,[\"context\"]]],null],\"attrs\"],null],[21,2,[\"attr\"]]],null],[21,5,[\"key\"]]],null],null],[8],[1,[21,5,[\"value\"]],false],[9],[0,\"\\n\"]],\"parameters\":[5]},null],[4,\"each\",[[26,\"get\",[[21,7,[]],[21,2,[\"valueSource\"]]],null]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"                          \"],[6,\"option\"],[11,\"value\",[21,4,[\"id\"]],null],[11,\"selected\",[26,\"eq\",[[26,\"get\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],[21,1,[\"context\"]]],null],\"attrs\"],null],[21,2,[\"attr\"]]],null],[21,4,[\"id\"]]],null],null],[8],[1,[21,4,[\"id\"]],false],[9],[0,\"\\n\"]],\"parameters\":[4]},null],[0,\"                      \"],[9],[0,\"\\n                    \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[21,2,[\"type\"]],\"set-attr\"],null]],null,{\"statements\":[[0,\"                    \"],[5,\"AriaMenuAction\",[],[[\"@tabindex\",\"@label\",\"@current\",\"@action\"],[[26,\"aria-menu-item-tabindex\",[[22,[\"index\"]]],null],[21,2,[\"label\"]],[26,\"boolean-str\",[[26,\"eq\",[[26,\"get\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],[21,1,[\"context\"]]],null],\"attrs\"],null],[21,2,[\"attr\"]]],null],[21,2,[\"value\"]]],null]],null],[26,\"action\",[[22,[\"menuAction\"]],\"setBlockAttribute\",[21,2,[\"attr\"]],[21,2,[\"value\"]]],null]]],{\"statements\":[[0,\"\\n\"],[4,\"if\",[[21,2,[\"icon\"]]],null,{\"statements\":[[4,\"if\",[[26,\"and\",[[21,2,[\"icon\",\"on\"]],[21,2,[\"icon\",\"off\"]]],null]],null,{\"statements\":[[4,\"if\",[[26,\"eq\",[[26,\"get\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],[21,1,[\"context\"]]],null],\"attrs\"],null],[21,2,[\"attr\"]]],null],[21,2,[\"value\"]]],null]],null,{\"statements\":[[0,\"                            \"],[1,[21,2,[\"icon\",\"on\"]],true],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"                            \"],[1,[21,2,[\"icon\",\"off\"]],true],[0,\"\\n\"]],\"parameters\":[]}]],\"parameters\":[]},{\"statements\":[[0,\"                          \"],[1,[21,2,[\"icon\"]],true],[0,\"\\n\"]],\"parameters\":[]}]],\"parameters\":[]},{\"statements\":[[0,\"                        \"],[1,[21,2,[\"label\"]],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"                    \"]],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[21,2,[\"type\"]],\"toggle-attr\"],null]],null,{\"statements\":[[0,\"                    \"],[5,\"AriaMenuAction\",[],[[\"@tabindex\",\"@label\",\"@current\",\"@action\"],[[26,\"aria-menu-item-tabindex\",[[22,[\"index\"]]],null],[21,2,[\"label\"]],[26,\"boolean-str\",[[26,\"get\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],[21,1,[\"context\"]]],null],\"attrs\"],null],[21,2,[\"attr\"]]],null]],null],[26,\"action\",[[22,[\"menuAction\"]],\"toggleBlockAttribute\",[21,2,[\"attr\"]]],null]]],{\"statements\":[[0,\"\\n\"],[4,\"if\",[[21,2,[\"icon\"]]],null,{\"statements\":[[4,\"if\",[[26,\"and\",[[21,2,[\"icon\",\"on\"]],[21,2,[\"icon\",\"off\"]]],null]],null,{\"statements\":[[4,\"if\",[[26,\"get\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],[21,1,[\"context\"]]],null],\"attrs\"],null],[21,2,[\"attr\"]]],null]],null,{\"statements\":[[0,\"                            \"],[1,[21,2,[\"icon\",\"on\"]],true],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"                            \"],[1,[21,2,[\"icon\",\"off\"]],true],[0,\"\\n\"]],\"parameters\":[]}]],\"parameters\":[]},{\"statements\":[[0,\"                          \"],[1,[21,2,[\"icon\"]],true],[0,\"\\n\"]],\"parameters\":[]}]],\"parameters\":[]},{\"statements\":[[0,\"                        \"],[1,[21,2,[\"label\"]],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"                    \"]],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[21,2,[\"type\"]],\"toggle-mark\"],null]],null,{\"statements\":[[0,\"                    \"],[5,\"AriaMenuAction\",[],[[\"@tabindex\",\"@label\",\"@current\",\"@action\"],[[26,\"aria-menu-item-tabindex\",[[22,[\"index\"]]],null],[21,2,[\"label\"]],[26,\"boolean-str\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],[21,1,[\"context\"]]],null],[21,2,[\"mark\"]]],null]],null],[26,\"action\",[[22,[\"menuAction\"]],\"toggleMark\",[21,2,[\"mark\"]]],null]]],{\"statements\":[[0,\"\\n\"],[4,\"if\",[[21,2,[\"icon\"]]],null,{\"statements\":[[4,\"if\",[[26,\"and\",[[21,2,[\"icon\",\"on\"]],[21,2,[\"icon\",\"off\"]]],null]],null,{\"statements\":[[4,\"if\",[[26,\"get\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],[21,1,[\"context\"]]],null],\"attrs\"],null],[21,2,[\"attr\"]]],null]],null,{\"statements\":[[0,\"                            \"],[1,[21,2,[\"icon\",\"on\"]],true],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[0,\"                            \"],[1,[21,2,[\"icon\",\"off\"]],true],[0,\"\\n\"]],\"parameters\":[]}]],\"parameters\":[]},{\"statements\":[[0,\"                          \"],[1,[21,2,[\"icon\"]],true],[0,\"\\n\"]],\"parameters\":[]}]],\"parameters\":[]},{\"statements\":[[0,\"                        \"],[1,[21,2,[\"label\"]],false],[0,\"\\n\"]],\"parameters\":[]}],[0,\"                    \"]],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[21,2,[\"type\"]],\"text-attr\"],null]],null,{\"statements\":[[0,\"                    \"],[6,\"li\"],[10,\"class\",\"input\"],[10,\"role\",\"presentation\"],[8],[0,\"\\n                      \"],[6,\"input\"],[11,\"type\",[21,2,[\"dataType\"]],null],[11,\"value\",[26,\"get\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],[21,1,[\"context\"]]],null],\"attrs\"],null],[21,2,[\"attr\"]]],null],null],[11,\"onchange\",[26,\"action\",[[22,[\"menuAction\"]],\"setBlockAttribute\",[21,2,[\"attr\"]],\"ev.target.value\"],null],null],[8],[9],[0,\"\\n                    \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[21,2,[\"type\"]],\"text-block-attr\"],null]],null,{\"statements\":[[0,\"                    \"],[6,\"li\"],[10,\"class\",\"input\"],[10,\"role\",\"presentation\"],[8],[0,\"\\n                      \"],[6,\"textarea\"],[11,\"onchange\",[26,\"action\",[[22,[\"menuAction\"]],\"setBlockAttribute\",[21,2,[\"attr\"]],\"ev.target.value\"],null],null],[8],[1,[26,\"get\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],[21,1,[\"context\"]]],null],\"attrs\"],null],[21,2,[\"attr\"]]],null],false],[9],[0,\"\\n                    \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[21,2,[\"type\"]],\"doc-text-attr\"],null]],null,{\"statements\":[[0,\"                    \"],[6,\"li\"],[10,\"class\",\"input\"],[10,\"role\",\"presentation\"],[8],[0,\"\\n                      \"],[6,\"input\"],[11,\"type\",[21,2,[\"dataType\"]],null],[11,\"value\",[26,\"get\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],[21,1,[\"context\"]]],null],\"attrs\"],null],[21,2,[\"attr\"]]],null],null],[11,\"onchange\",[26,\"action\",[[22,[\"menuAction\"]],\"setDocAttribute\",[21,2,[\"attr\"]],\"ev.target.value\"],null],null],[8],[9],[0,\"\\n                    \"],[9],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[21,2,[\"type\"]],\"select-mark-attr\"],null]],null,{\"statements\":[[0,\"                    \"],[6,\"li\"],[10,\"class\",\"input\"],[10,\"role\",\"presentation\"],[8],[0,\"\\n                      \"],[6,\"select\"],[10,\"role\",\"menuitem\"],[11,\"tabindex\",[26,\"aria-menu-item-tabindex\",[[22,[\"index\"]]],null],null],[11,\"onchange\",[26,\"action\",[[22,[\"menuAction\"]],\"setMarkAttribute\",[26,\"join\",[\".\",[21,2,[\"mark\"]],[21,2,[\"attr\"]]],null],\"ev.target.value\"],null],null],[8],[0,\"\\n\"],[4,\"each\",[[21,2,[\"values\"]]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"                          \"],[6,\"option\"],[11,\"value\",[21,3,[\"key\"]],null],[11,\"selected\",[26,\"eq\",[[26,\"get\",[[26,\"get\",[[26,\"get\",[[26,\"get\",[[22,[\"status\"]],\"marks\"],null],[21,2,[\"mark\"]]],null],\"attrs\"],null],[21,2,[\"attr\"]]],null],[21,3,[\"key\"]]],null],null],[8],[1,[21,3,[\"label\"]],false],[9],[0,\"\\n\"]],\"parameters\":[3]},null],[0,\"                      \"],[9],[0,\"\\n                    \"],[9],[0,\"\\n\"]],\"parameters\":[]},null]],\"parameters\":[2]},null],[0,\"              \"]],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},null],[0,\"          \"],[9],[0,\"\\n\"]],\"parameters\":[]},null]],\"parameters\":[1]},null],[0,\"    \"],[9],[0,\"\\n  \"],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/tei-editor/components/ProsemirrorEditor" } };

    function nsResolver(prefix) {
        if (prefix === 'tei') {
            return 'http://www.tei-c.org/ns/1.0';
        } else if (prefix === 'xml') {
            return 'http://www.w3.org/XML/1998/namespace';
        } else {
            return 'http://www.tei-c.org/ns/1.0';
        }
    }
    class XPathEvaluator {
        constructor(dom) {
            this.dom = dom;
        }
        evaluate(node, xpath, result_type) {
            return this.dom.evaluate(xpath, node, nsResolver, result_type, null);
        }
        firstNode(node, xpath) {
            return this.evaluate(node, xpath, XPathResult.FIRST_ORDERED_NODE_TYPE).singleNodeValue;
        }
        nodeIterator(node, xpath) {
            return this.evaluate(node, xpath, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
        }
        stringValue(node, xpath) {
            return this.evaluate(node, xpath, XPathResult.STRING_TYPE).stringValue;
        }
        booleanValue(node, xpath) {
            return this.evaluate(node, xpath, XPathResult.BOOLEAN_TYPE).booleanValue;
        }
        numberValue(node, xpath) {
            return this.evaluate(node, xpath, XPathResult.NUMBER_TYPE).numberValue;
        }
    }
    class TEIParser {
        constructor(data, sections) {
            let domParser = new DOMParser();
            this.dom = domParser.parseFromString(data, 'application/xml');
            this.xpath = new XPathEvaluator(this.dom);
            this.sections = sections;
            this.parsed = {};
        }
        get(section) {
            if (this.parsed[section] === undefined) {
                if (this.sections[section].type === 'single-text') {
                    this.parsed[section] = this.parseSingleText(this.sections[section]);
                } else if (this.sections[section].type === 'header') {
                    this.parsed[section] = this.parseHeader(this.sections[section]);
                } else if (this.sections[section].type === 'multi-text') {
                    this.parsed[section] = this.parseMultiText(this.sections[section]);
                }
            }
            return this.parsed[section];
        }
        parseSingleText(section) {
            let node = this.xpath.firstNode(this.dom.documentElement, section.parser.selector);
            if (node) {
                return this.parseContentNode(node, section);
            } else {
                return null;
            }
        }
        parseContentAttributes(node, attrs) {
            // Parse attributes for nodes or marks. Attributes can have a type which is boolean, number, static, or string (default).
            let result = {};
            Object.entries(attrs).forEach(entry => {
                let key = entry[0];
                let schema = entry[1];
                let parsers = [];
                if (schema.parser) {
                    parsers.push(schema.parser);
                } else if (schema.parsers) {
                    parsers = schema.parsers;
                }
                for (let idx = 0; idx < parsers.length; idx++) {
                    let parser = parsers[idx];
                    if (parser.type === 'boolean') {
                        result[key] = this.xpath.booleanValue(node, parser.selector);
                    } else if (parser.type === 'number') {
                        try {
                            result[key] = this.xpath.numberValue(node, parser.selector);
                        } catch (e) {
                            console.log(e);
                        }
                    } else if (parser.type === 'static') {
                        if (this.xpath.booleanValue(node, parser.selector)) {
                            result[key] = parser.value;
                        }
                    } else {
                        try {
                            let value = this.xpath.stringValue(node, parser.selector);
                            if (value && value !== '') {
                                result[key] = value;
                            }
                        } catch (e) {
                            console.log(e);
                        }
                    }
                }
            });
            return result;
        }
        parseContentMarks(node, marks) {
            // Parse the marks of a text node
            let result = [];
            Object.entries(marks).forEach(entry => {
                let key = entry[0];
                let schema = entry[1];
                let parsers = [];
                if (schema.parser) {
                    parsers.push(schema.parser);
                } else if (schema.parsers) {
                    parsers = schema.parsers;
                }
                for (let idx = 0; idx < parsers.length; idx++) {
                    if (this.xpath.booleanValue(node, parsers[idx].selector)) {
                        let mark = {
                            type: key
                        };
                        if (schema.attrs) {
                            mark.attrs = this.parseContentAttributes(node, schema.attrs);
                        }
                        result.push(mark);
                    }
                }
            });
            return result;
        }
        parseContentNode(node, section) {
            // Parse a single content node
            let entries = Object.entries(section.schema.nodes);
            for (let idx = 0; idx < entries.length; idx++) {
                let key = entries[idx][0];
                let nodeSchema = entries[idx][1];
                let parsers = [];
                if (nodeSchema.parser) {
                    parsers.push(nodeSchema.parser);
                } else if (nodeSchema.parsers) {
                    parsers = parsers.concat(nodeSchema.parsers);
                }
                for (let idx2 = 0; idx2 < parsers.length; idx2++) {
                    let parser = parsers[idx2];
                    if (this.xpath.firstNode(node, 'self::' + parser.selector) !== null) {
                        // The first schema node where the parser selector matches is chosen as the result
                        let result = {
                            type: key
                        };
                        if (nodeSchema.attrs) {
                            result.attrs = this.parseContentAttributes(node, nodeSchema.attrs);
                        }
                        if (nodeSchema.inline) {
                            // Inline nodes are either loaded as text nodes with marks or as complex text nodes
                            if (key === 'text') {
                                result.text = this.xpath.stringValue(node, parser.text);
                                result.marks = this.parseContentMarks(node, section.schema.marks);
                                if (node.children.length === 1) {
                                    let temp = this.parseContentNode(node.children[0], section);
                                    if (temp.text && temp.text !== '') {
                                        result.text = temp.text;
                                    }
                                    result.marks = result.marks.concat(temp.marks);
                                }
                            } else {
                                if (node.children.length === 0) {
                                    // Inline nodes without children need a virtual text node added
                                    result.content = [{
                                        type: 'text',
                                        text: this.xpath.stringValue(node, parser.text),
                                        marks: this.parseContentMarks(node, section.schema.marks)
                                    }];
                                } else {
                                    let content = [];
                                    for (let idx3 = 0; idx3 < node.children.length; idx3++) {
                                        let child = this.parseContentNode(node.children[idx3], section);
                                        if (child) {
                                            content.push(child);
                                        }
                                    }
                                    result.content = content;
                                }
                            }
                        } else {
                            let content = [];
                            for (let idx3 = 0; idx3 < node.children.length; idx3++) {
                                let child = this.parseContentNode(node.children[idx3], section);
                                if (child) {
                                    content.push(child);
                                }
                            }
                            result.content = content;
                        }
                        return result;
                    }
                }
            }
        }
        parseHeaderNode(node, schema) {
            let elements = this.xpath.nodeIterator(node, schema.tag);
            let result = [];
            let element = elements.iterateNext();
            while (element) {
                let obj = {
                    _attrs: {},
                    _text: element.children.length === 0 ? this.xpath.stringValue(element, 'text()') : null
                };
                for (let idx = 0; idx < element.attributes.length; idx++) {
                    obj._attrs[element.attributes[idx].name] = element.attributes[idx].value;
                }
                if (schema.children) {
                    for (let idx = 0; idx < schema.children.length; idx++) {
                        let temp = this.parseHeaderNode(element, schema.children[idx]);
                        if (temp) {
                            obj[schema.children[idx].tag.substring(4)] = temp;
                        }
                    }
                }
                result.push(obj);
                element = elements.iterateNext();
            }
            if (result.length === 0) {
                return null;
            } else {
                if (schema.multiple) {
                    return result;
                } else {
                    return result[0];
                }
            }
        }
        parseHeader(section) {
            let header = this.xpath.firstNode(this.dom.documentElement, section.tag);
            let data = {};
            for (let idx = 0; idx < section.schema.length; idx++) {
                let temp = this.parseHeaderNode(header, section.schema[idx]);
                if (temp) {
                    data[section.schema[idx].tag.substring(4)] = temp;
                }
            }
            return data;
        }
        parseMultiText(section) {
            let root = this.xpath.firstNode(this.dom.documentElement, section.parser.selector);
            if (root) {
                let parts = [];
                let nodes = this.xpath.nodeIterator(root, section.parts.parser.selector);
                let node = nodes.iterateNext();
                while (node) {
                    let part = this.parseContentNode(node, section);
                    if (part) {
                        parts.push({
                            id: node.getAttribute('xml:id'),
                            text: part
                        });
                    }
                    node = nodes.iterateNext();
                }
                return parts;
            }
            return [];
        }
    }
    class TEISerializer {
        serialize(data, sections) {
            let root = {
                node: 'tei:TEI',
                attrs: {
                    'xmlns:tei': ['http://www.tei-c.org/ns/1.0']
                },
                children: []
            };
            let keys = Object.keys(sections);
            for (let idx = 0; idx < keys.length; idx++) {
                let key = keys[idx];
                if (sections[key].type === 'single-text') {
                    this.mergeTrees(root, this.serializeSingleText(data[key], sections[key]));
                } else if (sections[key].type === 'header') {
                    this.mergeTrees(root, this.serializeHeader(data[key], sections[key]));
                } else if (sections[key].type === 'multi-text') {
                    this.mergeTrees(root, this.serializeMultiText(data[key], sections[key]));
                }
            }
            let lines = this.toString(root, '');
            lines.splice(0, 0, '<?xml version="1.0" encoding="UTF-8"?>');
            lines.push('');
            return lines.join('\n');
        }
        mergeTrees(base, merge) {
            // Merge one tree into another. If either of the two trees tries to merge at a level where sibling nodes have the
            // same tags, this will break
            if (base && merge) {
                for (let idx = 0; idx < merge.children.length; idx++) {
                    let found = false;
                    for (let idx2 = 0; idx2 < base.children.length; idx2++) {
                        if (base.children[idx2].node === merge.children[idx].node && this.objectsMatch(base.children[idx2].attrs, merge.children[idx].attrs)) {
                            this.mergeTrees(base.children[idx2], merge.children[idx]);
                            found = true;
                        }
                    }
                    if (!found) {
                        base.children.push(merge.children[idx]);
                    }
                }
            }
        }
        objectsMatch(a, b) {
            if (a && b) {
                if (typeof a !== typeof b) {
                    return false;
                } else if (typeof a === 'string' || typeof a === 'number' || typeof a === 'boolean') {
                    return a === b;
                }
                let keysA = Object.keys(a);
                let keysB = Object.keys(b);
                keysA.forEach(key => {
                    if (keysB.indexOf(key) < 0) {
                        return false;
                    }
                    if (!this.objectsMatch(a[key], b[key])) {
                        return false;
                    }
                    keysB.splice(keysB.indexOf(key), 1);
                });
                if (keysB.length > 0) {
                    return false;
                }
                return true;
            } else if (!a && !b) {
                return true;
            } else {
                return false;
            }
        }
        serializeSingleText(data, section) {
            if (data) {
                return {
                    node: 'tei:TEI',
                    children: [{
                        node: section.serializer.tag,
                        children: [this.serializeTextNode(data, section)]
                    }]
                };
            } else {
                return null;
            }
        }
        serializeTextNode(node, section) {
            // Basic structure
            let obj = {
                node: section.schema.nodes[node.type].serializer.tag,
                attrs: {},
                children: [],
                text: null
            };
            // Optional static attributes defined by the node itself
            if (section.schema.nodes[node.type].serializer.attrs) {
                Object.entries(section.schema.nodes[node.type].serializer.attrs).forEach(entry => {
                    obj.attrs[entry[0]] = [entry[1]];
                });
            }
            // Attributes are serialised as a dict of key => list pairs to simplify handling multi-value attributes
            if (node.attrs) {
                Object.entries(node.attrs).forEach(entry => {
                    let serializer = section.schema.nodes[node.type].attrs[entry[0]].serializer;
                    let value = undefined;
                    // Values can either be serialised directly, through string replacement in the value key, or
                    // through value lookup in the values key.
                    if (serializer.values) {
                        if (serializer.values[entry[1]]) {
                            value = serializer.values[entry[1]];
                        }
                    } else if (serializer.value) {
                        value = serializer.value.replace('${value}', entry[1]);
                    } else {
                        value = entry[1];
                    }
                    if (value !== undefined) {
                        if (serializer.attr === 'text()') {
                            obj.text = value;
                        } else {
                            if (obj.attrs[serializer.attr]) {
                                obj.attrs[serializer.attr].push(value);
                            } else {
                                obj.attrs[serializer.attr] = [value];
                            }
                        }
                    }
                });
            }
            if (section.schema.nodes[node.type].inline) {
                if (node.content) {
                    // Inline nodes with content are serialised like any other block node, if they have more than one
                    // content element. Otherwise the text is fetched from the single child element
                    if (node.content.length > 1 || node.content[0].marks && node.content[0].marks.length > 0) {
                        node.content.forEach(child => {
                            obj.children.push(this.serializeTextNode(child, section));
                        });
                    } else {
                        let temp = this.serializeTextNode(node.content[0], section);
                        if (section.schema.nodes[node.type].serializer.text) {
                            // By setting the text.attr value in the serialiser, the text can be serialised into an attribute
                            if (obj.attrs[section.schema.nodes[node.type].serializer.text.attr]) {
                                obj.attrs[section.schema.nodes[node.type].serializer.text.attr].push(temp.text);
                            } else {
                                obj.attrs[section.schema.nodes[node.type].serializer.text.attr] = [temp.text];
                            }
                        } else {
                            obj.text = temp.text;
                        }
                    }
                } else if (node.text) {
                    // As above allow serialisation of text into an attribute
                    if (section.schema.nodes[node.type].serializer.text) {
                        if (obj.attrs[section.schema.nodes[node.type].serializer.text.attr]) {
                            obj.attrs[section.schema.nodes[node.type].serializer.text.attr].push(node.text);
                        } else {
                            obj.attrs[section.schema.nodes[node.type].serializer.text.attr] = [node.text];
                        }
                    } else {
                        obj.text = node.text;
                    }
                }
                if (node.marks) {
                    // First map all marks to temporary objects
                    let markObjs = node.marks.map(mark => {
                        let markObj = {
                            node: obj.node,
                            attrs: {}
                        };
                        let serializer = section.schema.marks[mark.type].serializer;
                        if (serializer.tag) {
                            markObj.node = serializer.tag;
                        }
                        if (serializer.attrs) {
                            // Static attribute values can be serialised into the node for marks
                            Object.entries(serializer.attrs).forEach(entry => {
                                if (entry[1].value) {
                                    if (markObj.attrs[entry[0]]) {
                                        markObj.attrs[entry[0]].push(entry[1].value);
                                    } else {
                                        markObj.attrs[entry[0]] = [entry[1].value];
                                    }
                                }
                            });
                        }
                        if (mark.attrs) {
                            Object.entries(mark.attrs).forEach(entry => {
                                // Marks with attributes can have those attributes serialised either via a value replacement
                                // or through value lookup in the values dict.
                                let value = undefined;
                                if (section.schema.marks[mark.type].attrs[entry[0]].serializer.value) {
                                    value = section.schema.marks[mark.type].attrs[entry[0]].serializer.value.replace('${value}', entry[1]);
                                } else if (section.schema.marks[mark.type].attrs[entry[0]].serializer.values) {
                                    if (section.schema.marks[mark.type].attrs[entry[0]].serializer.values[entry[1]]) {
                                        value = section.schema.marks[mark.type].attrs[entry[0]].serializer.values[entry[1]];
                                    }
                                }
                                if (value !== undefined) {
                                    if (markObj.attrs[section.schema.marks[mark.type].attrs[entry[0]].serializer.attr]) {
                                        markObj.attrs[section.schema.marks[mark.type].attrs[entry[0]].serializer.attr].push(value);
                                    } else {
                                        markObj.attrs[section.schema.marks[mark.type].attrs[entry[0]].serializer.attr] = [value];
                                    }
                                }
                            });
                        }
                        return markObj;
                    });
                    if (new Set(markObjs.map(markObj => {
                        return markObj.node;
                    })).size > 1) {
                        // If there are multiple nodes in the marks, then the output needs to be nested
                        markObjs.sort((a, b) => {
                            if (a.node < b.node) {
                                return -1;
                            } else if (a.node > b.node) {
                                return 1;
                            } else if (a.node === b.node) {
                                return 0;
                            }
                        });
                        let target = obj;
                        target.node = null;
                        // Build the nested structure
                        markObjs.forEach(markObj => {
                            if (target.node === null || target.node === markObj.node) {
                                target.node = markObj.node;
                                Object.entries(markObj.attrs).forEach(entry => {
                                    if (target.attrs[entry[0]]) {
                                        target.attrs[entry[0]] = target.attrs[entry[0]].concat(entry[1]);
                                    } else {
                                        target.attrs[entry[0]] = entry[1];
                                    }
                                });
                            } else {
                                let tmpObj = {
                                    node: markObj.node,
                                    attrs: markObj.attrs,
                                    children: [],
                                    text: target.text
                                };
                                target.text = null;
                                target.children.push(tmpObj);
                                target = tmpObj;
                            }
                        });
                    } else {
                        // If there is only one node in the marks, then the output can be flattened
                        markObjs.forEach(markObj => {
                            if (markObj.node) {
                                obj.node = markObj.node;
                            }
                            if (markObj.attrs) {
                                Object.entries(markObj.attrs).forEach(entry => {
                                    if (obj.attrs[entry[0]]) {
                                        obj.attrs[entry[0]] = obj.attrs[entry[0]].concat(entry[1]);
                                    } else {
                                        obj.attrs[entry[0]] = entry[1];
                                    }
                                });
                            }
                        });
                    }
                }
            } else if (node.content) {
                // Block nodes simply get their content
                node.content.forEach(child => {
                    obj.children.push(this.serializeTextNode(child, section));
                });
            }
            return obj;
        }
        serializeHeader(data, section) {
            return {
                node: 'tei:TEI',
                children: [{
                    node: section.tag,
                    children: section.schema.map(config => {
                        return this.serializeMetadataNode(data[config.tag.substring(4)], config);
                    })
                }]
            };
        }
        serializeMetadataNode(data, config) {
            if (config.multiple) {
                return data.map(item => {
                    let result = {
                        node: config.tag
                    };
                    if (item._text) {
                        result.text = item._text;
                    }
                    if (item._attrs) {
                        result.attrs = {};
                        Object.entries(item._attrs).forEach(entry => {
                            result.attrs[entry[0]] = [entry[1]];
                        });
                    }
                    if (config.children) {
                        result.children = [];
                        for (let idx = 0; idx < config.children.length; idx++) {
                            if (item[config.children[idx].tag.substring(4)]) {
                                let temp = this.serializeMetadataNode(item[config.children[idx].tag.substring(4)], config.children[idx]);
                                if (Array.isArray(temp)) {
                                    result.children = result.children.concat(temp);
                                } else {
                                    result.children.push(temp);
                                }
                            }
                        }
                    }
                    return result;
                });
            } else {
                let result = {
                    node: config.tag
                };
                if (data._text) {
                    result.text = data._text;
                }
                if (data._attrs) {
                    result.attrs = {};
                    Object.entries(data._attrs).forEach(entry => {
                        result.attrs[entry[0]] = [entry[1]];
                    });
                }
                if (config.children) {
                    result.children = [];
                    for (let idx = 0; idx < config.children.length; idx++) {
                        if (data[config.children[idx].tag.substring(4)]) {
                            let temp = this.serializeMetadataNode(data[config.children[idx].tag.substring(4)], config.children[idx]);
                            if (Array.isArray(temp)) {
                                result.children = result.children.concat(temp);
                            } else {
                                result.children.push(temp);
                            }
                        }
                    }
                }
                return result;
            }
        }
        serializeMultiText(data, section) {
            let wrapperNode = {
                node: section.parts.serializer.tag,
                children: data.map(text => {
                    return this.serializeTextNode(text.text, section);
                })
            };
            if (section.parts.serializer.attrs) {
                wrapperNode.attrs = {};
                Object.entries(section.parts.serializer.attrs).forEach(entry => {
                    wrapperNode.attrs[entry[0]] = [entry[1]];
                });
            }
            return {
                node: 'tei:TEI',
                children: [{
                    node: section.serializer.tag,
                    children: [wrapperNode]
                }]
            };
        }
        toString(node, indentation) {
            function xmlSafe(txt) {
                return txt.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;');
            }
            // Render a node into an XML string representation as a list of lines
            let lines = [];
            let buffer = [indentation, '<', node.node];
            if (node.attrs) {
                Object.entries(node.attrs).forEach(entry => {
                    if (entry[1].length > 0) {
                        entry[1].sort();
                        buffer.push(' ' + entry[0] + '="' + xmlSafe(entry[1].join(' ')) + '"');
                    }
                });
            }
            if (node.children && node.children.length > 0) {
                buffer.push('>');
                lines.push(buffer.join(''));
                node.children.forEach(child => {
                    lines = lines.concat(this.toString(child, indentation + '  '));
                });
                lines.push(indentation + '</' + node.node + '>');
            } else {
                if (node.text) {
                    buffer.push('>');
                    buffer.push(xmlSafe(node.text));
                    buffer.push('</' + node.node + '>');
                } else {
                    buffer.push('/>');
                }
                lines.push(buffer.join(''));
            }
            return lines;
        }
    }
    var __ui_components_TeiEditor_tei__ = null;

    var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
        var c = arguments.length,
            r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
            d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    class TeiEditor extends Component {
        constructor(options) {
            super(options);
            //schema: Schema = null;
            this.loaded = false;
            this.sections = null;
            this.data = null;
            this.currentView = '';
            this.sections = deepclone([window.teiEditorConfig.sections]);
            this.currentView = Object.keys(this.sections)[0];
        }
        didInsertElement() {
            if (window.teiEditorConfig.actions && window.teiEditorConfig.actions.initLoad) {
                let component = this;
                window.teiEditorConfig.actions.initLoad().then(function (data) {
                    let parser = new TEIParser(data, window.teiEditorConfig.sections);
                    data = {};
                    Object.keys(window.teiEditorConfig.sections).forEach(key => {
                        data[key] = parser.get(key);
                    });
                    component.data = data;
                    component.loaded = true;
                });
            }
        }
        // Computed properties
        /**
         * Returns the main UI config
         */
        get mainUIConfig() {
            return window.teiEditorConfig.ui.main;
        }
        /**
         * Returns a dictionary of all loaded multi-texts.
         */
        get multiTexts() {
            let multiTexts = {};
            if (this.sections && this.data) {
                Object.entries(this.sections).forEach(entry => {
                    if (entry[1].type === 'multi-text' && this.data && this.data[entry[0]]) {
                        multiTexts[entry[0]] = this.data[entry[0]];
                    }
                });
            }
            return multiTexts;
        }
        // Action handlers
        loadFile(ev) {
            ev.preventDefault();
            let component = this;
            if (window.teiEditorConfig.actions && window.teiEditorConfig.actions.load) {
                window.teiEditorConfig.actions.load().then(function (data) {
                    let parser = new TEIParser(data, window.teiEditorConfig.parser);
                    component.mainText = parser.body;
                    component.displayedMainText = parser.body;
                    component.metadata = parser.metadata;
                    component.globalAnnotationText = parser.globalAnnotationText;
                    component.displayedGlobalAnnotationText = parser.globalAnnotationText;
                    component.individualAnnotations = parser.individualAnnotations;
                    component.loaded = true;
                });
            } else {
                let fileSelector = document.createElement('input');
                fileSelector.setAttribute('type', 'file');
                fileSelector.setAttribute('class', 'hidden');
                document.querySelector('body').appendChild(fileSelector);
                fileSelector.click();
                fileSelector.addEventListener('change', function (ev) {
                    let files = ev.target.files;
                    if (files.length > 0) {
                        let reader = new FileReader();
                        reader.onload = ev => {
                            let parser = new TEIParser(ev.target.result, window.teiEditorConfig.parser);
                            component.mainText = parser.body;
                            component.displayedMainText = parser.body;
                            component.metadata = parser.metadata;
                            component.globalAnnotationText = parser.globalAnnotationText;
                            component.displayedGlobalAnnotationText = parser.globalAnnotationText;
                            component.individualAnnotations = parser.individualAnnotations;
                            component.loaded = true;
                        };
                        reader.readAsText(files[0]);
                    }
                    fileSelector.remove();
                });
            }
        }
        saveFile(ev) {
            ev.preventDefault();
            let serializer = new TEISerializer();
            let content = serializer.serialize(this.data, this.sections);
            if (window.teiEditorConfig.actions && window.teiEditorConfig.actions.save) {
                window.teiEditorConfig.actions.save(content);
            } else {
                let blob = new Blob([content], { type: 'text/xml;charset=utf-8' });
                let link = document.createElement('a');
                link.setAttribute('href', URL.createObjectURL(blob));
                link.setAttribute('download', 'download.tei');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
        /**
         * Switch the active view.
         */
        setView(view, ev) {
            ev.preventDefault();
            this.currentView = view;
        }
        updateData(key, data) {
            let newData = deepclone([this.data]);
            newData[key] = data;
            this.data = newData;
        }
    }
    __decorate$4([tracked], TeiEditor.prototype, "loaded", void 0);
    __decorate$4([tracked], TeiEditor.prototype, "sections", void 0);
    __decorate$4([tracked], TeiEditor.prototype, "data", void 0);
    __decorate$4([tracked], TeiEditor.prototype, "currentView", void 0);
    __decorate$4([tracked], TeiEditor.prototype, "multiTexts", null);

    var __ui_components_TeiEditor_template__ = { "id": "doP/P5p0", "block": "{\"symbols\":[\"value\",\"key\",\"value\",\"key\"],\"statements\":[[6,\"div\"],[10,\"class\",\"tei-editor\"],[8],[0,\"\\n  \"],[6,\"div\"],[8],[0,\"\\n    \"],[5,\"AriaMenu\",[],[[\"@class\"],[\"tei-editor-menubar\"]],{\"statements\":[[0,\"\\n      \"],[5,\"AriaDropdownMenu\",[],[[\"@title\"],[\"File\"]],{\"statements\":[[0,\"\\n        \"],[5,\"AriaMenuAction\",[],[[\"@action\"],[[26,\"action\",[[22,[\"saveFile\"]]],null]]],{\"statements\":[[0,\"Save\"]],\"parameters\":[]}],[0,\"\\n      \"]],\"parameters\":[]}],[0,\"\\n\"],[4,\"each\",[[22,[\"sections\"]]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"        \"],[5,\"AriaMenuAction\",[],[[\"@current\",\"@hidden\",\"@action\"],[[26,\"boolean-str\",[[26,\"eq\",[[22,[\"currentView\"]],[21,4,[]]],null]],null],[26,\"boolean-str\",[[26,\"not\",[[22,[\"loaded\"]]],null]],null],[26,\"action\",[[22,[\"setView\"]],[21,4,[]]],null]]],{\"statements\":[[1,[21,3,[\"title\"]],false]],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[3,4]},null],[0,\"    \"]],\"parameters\":[]}],[0,\"\\n  \"],[9],[0,\"\\n  \"],[6,\"div\"],[11,\"aria-hidden\",[26,\"boolean-str\",[[26,\"not\",[[22,[\"loaded\"]]],null]],null],null],[8],[0,\"\\n\"],[4,\"each\",[[22,[\"sections\"]]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"      \"],[6,\"div\"],[11,\"id\",[27,[[21,2,[]]]]],[11,\"class\",[27,[\"tei-editor-view-\",[26,\"get\",[[26,\"get\",[[22,[\"sections\"]],[21,2,[]]],null],\"type\"],null]]]],[11,\"aria-hidden\",[26,\"boolean-str\",[[26,\"not\",[[26,\"eq\",[[22,[\"currentView\"]],[21,2,[]]],null]],null]],null],null],[8],[0,\"\\n\"],[4,\"if\",[[26,\"eq\",[[26,\"get\",[[26,\"get\",[[22,[\"sections\"]],[21,2,[]]],null],\"type\"],null],\"header\"],null]],null,{\"statements\":[[0,\"          \"],[5,\"MetadataEditor\",[],[[\"@config\",\"@metadata\",\"@update\"],[[26,\"get\",[[26,\"get\",[[22,[\"sections\"]],[21,2,[]]],null],\"ui\"],null],[26,\"get\",[[22,[\"data\"]],[21,2,[]]],null],[26,\"action\",[[22,[\"updateData\"]],[21,2,[]]],null]]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[26,\"get\",[[26,\"get\",[[22,[\"sections\"]],[21,2,[]]],null],\"type\"],null],\"single-text\"],null]],null,{\"statements\":[[0,\"          \"],[5,\"ProsemirrorEditor\",[],[[\"@schema\",\"@ui\",\"@multiTexts\",\"@text\",\"@update\"],[[26,\"get\",[[26,\"get\",[[22,[\"sections\"]],[21,2,[]]],null],\"schema\"],null],[26,\"get\",[[26,\"get\",[[22,[\"sections\"]],[21,2,[]]],null],\"ui\"],null],[20,\"multiTexts\"],[26,\"get\",[[22,[\"data\"]],[21,2,[]]],null],[26,\"action\",[[22,[\"updateData\"]],[21,2,[]]],null]]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},null],[4,\"if\",[[26,\"eq\",[[26,\"get\",[[26,\"get\",[[22,[\"sections\"]],[21,2,[]]],null],\"type\"],null],\"multi-text\"],null]],null,{\"statements\":[[0,\"          \"],[5,\"MultiText\",[],[[\"@schema\",\"@ui\",\"@default\",\"@texts\",\"@multiTexts\",\"@update\"],[[26,\"get\",[[26,\"get\",[[22,[\"sections\"]],[21,2,[]]],null],\"schema\"],null],[26,\"get\",[[26,\"get\",[[22,[\"sections\"]],[21,2,[]]],null],\"ui\"],null],[26,\"get\",[[26,\"get\",[[22,[\"sections\"]],[21,2,[]]],null],\"default\"],null],[26,\"get\",[[22,[\"data\"]],[21,2,[]]],null],[20,\"multiTexts\"],[26,\"action\",[[22,[\"updateData\"]],[21,2,[]]],null]]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n\"]],\"parameters\":[]},null],[0,\"      \"],[9],[0,\"\\n\"]],\"parameters\":[1,2]},null],[0,\"  \"],[9],[0,\"\\n\"],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/tei-editor/components/TeiEditor" } };

    function and(params) {
        for (let idx = 0; idx < params.length; idx++) {
            if (!params[idx]) {
                return false;
            }
        }
        return true;
    }

    function ariaMenuItemTabindex(params) {
        if (params[0] === 0) {
            return 0;
        } else {
            return -1;
        }
    }

    /**
     * Tests if the index is the first element in the array.
     */
    function arrayFirst(params) {
      return params[0].length > 0 && params[1] === 0;
    }

    /**
     * Tests if the index is the last element in the array.
     */
    function arrayLast(params) {
      return params[1] === params[0].length - 1;
    }

    /**
     * Converts the first parameter into a boolean string "true"/"false".
     */
    function booleanStr(params) {
        if (params[0]) {
            return 'true';
        } else {
            return 'false';
        }
    }

    /**
     * Compare whether the first two parameters are equal.
     */
    function eq(params) {
      return params[0] === params[1];
    }

    function join(params) {
        return params.slice(1).join(params[0]);
    }

    /**
     * Boolean invert the first parameter.
     */
    function not(params) {
      return !params[0];
    }

    function or(params) {
        for (let idx = 0; idx < params.length; idx++) {
            if (params[idx]) {
                return true;
            }
        }
        return false;
    }

    function statusDisplayEntry(params) {
        let status = params[0];
        let test = params[1];
        if (status && test) {
            if (typeof test === 'string') {
                return get([status, test]);
            } else if (test.key && test.value) {
                return get([status, test.key]) === test.value;
            }
        } else if (status && !test) {
            return true;
        }
        return false;
    }

    var moduleMap = { 'component:/tei-editor/components/AriaDropdownMenu': AriaDropdownMenu, 'template:/tei-editor/components/AriaDropdownMenu': __ui_components_AriaDropdownMenu_template__, 'component:/tei-editor/components/AriaMenu': AriaMenu, 'template:/tei-editor/components/AriaMenu': __ui_components_AriaMenu_template__, 'component:/tei-editor/components/AriaMenuAction': AriaMenuAction, 'template:/tei-editor/components/AriaMenuAction': __ui_components_AriaMenuAction_template__, 'component:/tei-editor/components/MetadataEditor': MetadataEditor, 'template:/tei-editor/components/MetadataEditor': __ui_components_MetadataEditor_template__, 'component:/tei-editor/components/MultiText': MultiText, 'template:/tei-editor/components/MultiText': __ui_components_MultiText_template__, 'component:/tei-editor/components/ProsemirrorEditor': ProsemirrorEditor, 'component:/tei-editor/components/ProsemirrorEditor/set-doc-attr': SetDocAttr, 'template:/tei-editor/components/ProsemirrorEditor': __ui_components_ProsemirrorEditor_template__, 'component:/tei-editor/components/TeiEditor': TeiEditor, 'component:/tei-editor/components/TeiEditor/tei': __ui_components_TeiEditor_tei__, 'template:/tei-editor/components/TeiEditor': __ui_components_TeiEditor_template__, 'helper:/tei-editor/components/and': and, 'helper:/tei-editor/components/aria-menu-item-tabindex': ariaMenuItemTabindex, 'helper:/tei-editor/components/array-first': arrayFirst, 'helper:/tei-editor/components/array-last': arrayLast, 'helper:/tei-editor/components/boolean-str': booleanStr, 'helper:/tei-editor/components/deepclone': deepclone, 'helper:/tei-editor/components/eq': eq, 'helper:/tei-editor/components/get': get, 'helper:/tei-editor/components/join': join, 'helper:/tei-editor/components/not': not, 'helper:/tei-editor/components/or': or, 'helper:/tei-editor/components/set': set, 'helper:/tei-editor/components/status-display-entry': statusDisplayEntry };

    var resolverConfiguration = { "app": { "name": "tei-editor", "rootName": "tei-editor" }, "types": { "application": { "definitiveCollection": "main" }, "component": { "definitiveCollection": "components" }, "component-test": { "unresolvable": true }, "helper": { "definitiveCollection": "components" }, "helper-test": { "unresolvable": true }, "renderer": { "definitiveCollection": "main" }, "template": { "definitiveCollection": "components" } }, "collections": { "main": { "types": ["application", "renderer"] }, "components": { "group": "ui", "types": ["component", "component-test", "template", "helper", "helper-test"], "defaultType": "component", "privateCollections": ["utils"] }, "styles": { "group": "ui", "unresolvable": true }, "utils": { "unresolvable": true } } };

    class App extends Application {
        constructor() {
            let moduleRegistry = new BasicRegistry(moduleMap);
            let resolver = new Resolver(resolverConfiguration, moduleRegistry);
            const element = document.body;
            super({
                builder: new DOMBuilder({ element, nextSibling: null }),
                loader: new RuntimeCompilerLoader(resolver),
                renderer: new SyncRenderer(),
                resolver,
                rootName: resolverConfiguration.app.rootName
            });
        }
    }

    const app = new App();
    const containerElement = document.getElementById('app');
    setPropertyDidChange(() => {
        app.scheduleRerender();
    });
    app.registerInitializer({
        initialize(registry) {
            registry.register(`component-manager:/${app.rootName}/component-managers/main`, ComponentManager);
        }
    });
    app.renderComponent('TeiEditor', containerElement, null);
    app.boot();
    initializeCustomElements(app, { 'tei-editor': 'TeiEditor' });

})));
//# sourceMappingURL=app.js.map